{
  "hash": "1bca0a056d3002c07b55d6b1df1da402",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Estimating pi\"\nformat: html \nimage: 'logisticmapsolscreenshot.png'\ncategories: [integration, geometry]\nfilters:\n  - shinylive\n---\n\n\n# Estimating $\\pi$\n\n## A circle\n\nConsider a circle of radius $R$ centred at the origin.\n\n:::: {#fig-hmm fig-align=\"center\"}\n\n::: {#18e18e3c .cell fig-width='1' execution_count=1}\n\n::: {.cell-output .cell-output-display}\n![](EstimatingPi_files/figure-html/cell-2-output-1.png){width=457 height=429}\n:::\n:::\n\n\n::::\n\n\nThe equation of the circle is given by\n$$\nx^2+y^2=R^2.\n$$ {#eq-circle}\n\nThe area of the circle is given by the familiar formula\n\n$$\n\\pi R^2.\n$$\n\nThe smallest square within which the circle can be inscribed will have side length $2R$.\n\n::: {#fig-squarecircle fig-align=\"center\"}\n\n::: {#a029c020 .cell execution_count=2}\n\n::: {.cell-output .cell-output-display}\n![](EstimatingPi_files/figure-html/cell-3-output-1.png){width=457 height=429}\n:::\n:::\n\n\n:::\n\n\nHence the ratio of the area of the circle to that of the square is\n\n$$\n\\frac{\\pi R^2}{4 R^2}=\\frac{\\pi}{4}.\n$$\n\n\n## Estimating $\\pi$\n\nWe can use the above result to estimate $\\pi$ by randomly sampling points that sit inside the square. The probability of a randomly sampled point falling inside the inscribed circle in @fig-squarecircle is equal to the ratio of the areas, i.e.\n$$\n\\frac{\\pi}{4}.\n$$ \n\n\nWe can use a random number generator to uniformly sample $N_s$ points within the square, i.e. \n$$\nx_i \\in U_{0,2R}, \\quad y_i \\in U_{0,2R}, \\quad i=1,..,N.\n$$\nHere $U$ represents a uniform distribution and $N$ is the number of sampled points. \n\nWe can then count the number of randomly sampled points, $N_c$, that sit inside the circle, i.e. with coordinates that satisfy the inequality\n$$\nx_i^2+y_i^2< R^2.\n$$\n\nWe can then estimate $\\pi$ using the formula\n$$\n\\hat{\\pi}\\sim 4\\frac{N_c}{N_s}.\n$$\n\nIn @fig-apppi  we use an app to explore the approximation of $\\pi$. Here you can explore how the estimate for $\\pi$ depends on the number of samples and consider circles of different radii.\n\nIn the top plot the distribution of sampled points is plotted for a given realisation with the parameter values as you have chosen. In the bottom plot the estimate of $\\pi$ is averaged over 100 realisations and plotted against the number of sampled points, $N$.\n\n\n\n\n::: {#fig-apppi fig-align=\"center\"}\n\n```{shinylive-python}\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"N\",label=\"N\",min=10,max=3000,value=10,step=1),\n    ui.input_slider(id=\"R\",label=\"R\",min=2.0,max=15.0,value=10.0,step=1),\n    ui.input_slider(id=\"L\",label=\"L\",min=15.0,max=30.0,value=20.0,step=1),             \n     \n              \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def estimate_pi(N,R,L): \n        x = np.random.uniform(0,L,N)\n        y = np.random.uniform(0,L,N)\n\n        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n        num_points_inside_circle=len(radius[radius<=R])\n\n        pi_est=(4.0*num_points_inside_circle/N)\n\n        return x,y,pi_est\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(2,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        N=int(input.N())\n        R=float(input.R())\n        L=float(input.L())\n        \n    \n        x,y,pi_est=estimate_pi(N,R,L)\n\n        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n        \n        ax[0].plot(x[radius<R],y[radius<R],'b.')\n        ax[0].plot(x[radius>R],y[radius>R],'k.')\n\n        ax[0].set_xlabel('$x$')\n        ax[0].set_ylabel('$y$')\n\n        theta=np.linspace(0,2*np.pi,1000)\n        ax[0].plot(R*np.cos(theta)+L/2.0,R*np.sin(theta)+L/2.0,'r')\n        ax[0].set_title('$\\hat{\\pi}$='+str(pi_est))\n\n        \n        N_vec=np.linspace(10,3000,80,dtype=int)\n        pi_est_vec=np.zeros_like(N_vec,dtype=float)\n        n_samples=100\n        for i in range(len(N_vec)):\n            pi_est_i=np.zeros((n_samples,1),dtype=float)\n            for j in range(n_samples):\n                x,y,pi_est=estimate_pi(N_vec[i],R,L)\n                pi_est_i[j]=pi_est\n            pi_est_vec[i]=np.mean(pi_est_i)\n\n        ax[1].plot(N_vec,pi_est_vec,'.',N_vec,np.pi*np.ones_like(N_vec))\n        ax[1].set_xlabel('$N$')\n        ax[1].set_ylabel('$\\hat{\\pi}$')\n        #plt.Circle([0.0, 0.0 ],R,fill = False,axis=ax)\n        #ax.Circle((0.0, 0.0 ),R,fill = False )\n\n\n        fig.tight_layout()\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n```\n:::\n\n\n## Monte Carlo integration\n\nYou may have previously come across definite integrals of the form\n\n$$\nI=\\int_a^b f(x)\\mathrm{d}x.\n$$\n\nA specific  example is\n$$\n\\int_0^1 x^2 \\mathrm{d}x.\n$$\n\nIf you have not yet come across definite integrals that is fine.\nFor the purposes of this page, the value of the integral is simply the area underneath the curve (see blue shaded region in @fig-intdemo).\n\n::: {#fig-intdemo fig-align=\"center\"}\n\n::: {#be9af194 .cell execution_count=3}\n\n::: {.cell-output .cell-output-display}\n![](EstimatingPi_files/figure-html/cell-4-output-1.png){width=438 height=429}\n:::\n:::\n\n\n:::\n\n\nTo compute the integral we can use a similar method to that used for estimating $\\pi$:\n\n-  circumscribe the region to be integrated within a domain of known area (e.g. see rectangle in @fig-apppisquare) \n-  uniformly sample points within the rectangle\n-  count the fraction of points that lie in the shaded region\n- the value of the integral can be approximated by\n$$\n\\hat{I} \\sim \\textrm{Area of Rectangle} * \\textrm{Fraction of sampled points in target region}\n$$\n\n::: {#fig-apppisquare fig-align=\"center\"}\n\n::: {#bdb7f43b .cell execution_count=4}\n\n::: {.cell-output .cell-output-display}\n![](EstimatingPi_files/figure-html/cell-5-output-1.png){width=438 height=429}\n:::\n:::\n\n\n:::\n\n\n\nIn @fig-integapp you can use a Monte Carlo method to approximate many common integrals. @tbl-integrands provides the syntax needed for  available functions.\n\n\n| Integrand | Input text  |\n|---------|:-----|\n|$\\sqrt{x}$      | sqrt(x)   |\n| $\\sin{x}$     | sin(x)  |\n| $\\cos{x}$     | cos(x)  |\n| $\\ln{x}$       | log(x)   |\n| $x^2$       | x^2  |\n| $e^x$       | exp(x)  |\n| $\\pi$       | pi  |\n\n: Syntax for inputting elementary functions into the integrator in @fig-integapp. {#tbl-integrands}\n\nIn @tbl-integrands2 some examples are provided that demonstrate syntax for more complicated functions.\n\nIn the top plot the distribution of sampled points is plotted for a given realisation with the parameter values as you have chosen. In the bottom plot the estimate of the integral is averaged over 100 realisations and plotted against the number of sampled points, $N$.\n\n\n| Integrand | Input text  |\n|---------|:-----|\n| $x^2+2x+1$       | x^2+2*x+1  |\n| $e^{-\\sin^2{x}}$     | exp(-sin(x)*sin(x))  |\n\n: Examples of syntax for inputting more complex functions into the integrator in @fig-integapp. {#tbl-integrands2}\n\n\n::: {#fig-integapp}\n\n```{shinylive-python}\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"N\",label=\"N\",min=10,max=3000,value=10,step=1),\n    ui.input_slider(id=\"a\",label=\"a\",min=0.0,max=3.0,value=0.0,step=0.01),\n    ui.input_slider(id=\"b\",label=\"b\",min=1.0,max=10.0,value=1.0,step=0.01), \n    ui.input_text(id='text',label=\"Integrand as function of x\",value=\"sin(x)\")            \n     \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def function_f(x,text):\n\n        #f=np.sin(4*x)\n        f=np.sin(10*x)\n\n        f=parse_to_numpy_function(text,x)\n\n\n        return f\n\n    def parse_to_numpy_function(expression,x):\n        # Replace common mathematical operators with NumPy equivalents\n        expression = expression.replace(\"^\", \"**\")  # Replace '^' with '**'\n        expression = expression.replace(\"sin\", \"np.sin\")\n        expression = expression.replace(\"cos\", \"np.cos\")\n        expression = expression.replace(\"tan\", \"np.tan\")\n        expression = expression.replace(\"log\", \"np.log\")\n        expression = expression.replace(\"sqrt\", \"np.sqrt\")\n        expression = expression.replace(\"exp\", \"np.exp\")\n        expression = expression.replace(\"pi\", \"np.pi\")\n\n        # Create a lambda function for safe evaluation\n        #def numpy_function(x):\n        return eval(expression)\n    \n        #return expression\n\n\n    def estimate_int(a,b,N,text): \n        x = np.random.uniform(a,b,N)\n\n        f=function_f(x,text)\n        \n        max_f=np.max(f)\n        min_f=np.min(f)\n\n        y = np.random.uniform(min_f,max_f,N)\n\n        \n        num_points_inside_circle=len(y[(y>0)&(y<=f)])-len(y[(y<0)&(y>=f)])\n\n        int_est=(b-a)*(max_f-min_f)*num_points_inside_circle/N\n\n        return x,y,int_est\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(2,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        N=int(input.N())\n        a=float(input.a())\n        b=float(input.b())\n        text=input.text()\n\n        \n        \n        \n    \n        x,y,int_est=estimate_int(a,b,N,text)\n        \n        ax[0].plot(x[(y>0)&(y<function_f(x,text))],y[(y>0)&(y<function_f(x,text))],'b.')\n        ax[0].plot(x[(y<0)&(y>function_f(x,text))],y[(y<0)&(y>function_f(x,text))],'m.')\n        ax[0].plot(x[(y>0)&(y>function_f(x,text))],y[(y>0)&(y>function_f(x,text))],'k.')\n        ax[0].plot(x[(y<0)&(y<function_f(x,text))],y[(y<0)&(y<function_f(x,text))],'k.')\n        #ax[0].plot(x[(y>0)&(y>function_f(x))],y[(y>0)&(y>function_f(x))],'k.')\n\n        ax[0].set_xlabel('$x$')\n        ax[0].set_ylabel('$y$')\n\n        x_plot=np.linspace(a,b,1000,dtype=float)\n        y_plot=function_f(x_plot,text)\n        ax[0].plot(x_plot,y_plot,'r')\n        ax[0].set_title('$\\hat{I}$='+str(int_est))\n\n        \n        N_vec=np.linspace(10,3000,80,dtype=int)\n        int_est_vec=np.zeros_like(N_vec,dtype=float)\n        n_samples=200\n        for i in range(len(N_vec)):\n            int_est_i=np.zeros((n_samples,1),dtype=float)\n            for j in range(n_samples):\n                x,y,int_est=estimate_int(a,b,N_vec[i],text)\n                int_est_i[j]=int_est\n            int_est_vec[i]=np.median(int_est_i)\n\n        ax[1].plot(N_vec,int_est_vec,'.')\n        ax[1].set_xlabel('$N$')\n        ax[1].set_ylabel('$\\hat{I}$')\n\n        fig.tight_layout()\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n```\n:::\n\n\nExercises:\n\n - Show that\n $$ \n   \\int_0^{1}x^2 \\mathrm{d}x =\\frac{1}{3}.\n  $$\n\n\n - Estimate the integral \n $$\n f(x)=\\frac{\\sin(x)\\sin(x)\\sin(x)}{1+x^2}\n $$\n - Demonstrate that \n  $$ \n   \\int_0^{\\infty}e^{-x^2}\\mathrm{d}x =\\frac{\\sqrt{\\pi}}{2}\n  $$\n  Note that this calculation provides an alternative method to estimate $\\pi$!\n  - Estimate the integral \n  $$ \n   \\int_0^{1}\\frac{x^2}{1+x^2}\\mathrm{d}x.\n  $$\n  - Demonstrate that\n  $$ \n   \\int_0^{\\pi}\\sin(x) \\mathrm{d}x\\sim 2\n  $$\n  - Demonstrate that\n  $$ \n   \\int_0^{2\\pi}\\sin(x) \\mathrm{d}x\\sim 0\n  $$\n  Can you spot how the symmetry results in cancellation of the positive (blue) and negative (magenta) contributions?\n\n:::{.callout-warning}\n\n- The algorithm implemented in @fig-integapp above will always provide a numerical estimate. However, some functions are not integrable. In this case the numerical estimate provided by the app will be completely incorrect. We must understand the limitations of algorithms before trusting their output!\n- There exist functions that are integrable but cannot be estimated using the above technique. We cannot rely solely on algorithms. \n- How do we know how accurate the integral estimate is?\n- There exist much more computationally efficient methods for estimating integrals to a given accuracy.\n\n:::\n\n\n:::{.callout-note}\n\nAt Dundee, core concepts from integration  are introduced in the modules  *Maths 1A* and *Maths 1B* and developed further in the modules  *Maths 2A* and *Maths 2B*. \n\nIn the modules *Introduction to Programming* and *Computer Algebra and Dynamical systems* you would be introduced to techniques that enable you to perform numerical integration. \n\nYou can find out more about these modules [here](https://www.dundee.ac.uk/undergraduate/mathematics-bsc/teaching-and-assessment).\n\n:::\n\n",
    "supporting": [
      "EstimatingPi_files"
    ],
    "filters": [],
    "includes": {}
  }
}