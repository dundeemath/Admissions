{
  "hash": "d8cd36e5e5be71234da3ad8515655d1a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Estimating pi\"\nformat: html \nimage: 'EstimatingPi.png'\ncategories: [integration, geometry]\nfilters:\n  - shinylive\n---\n\n\n\n\n# Estimating $\\pi$\n\n## A circle\n\nConsider a circle of radius $R$ centred at the origin.\n\n:::: {#fig-hmm fig-align=\"center\"}\n\n::: {#c21e95c2 .cell fig-width='1' execution_count=1}\n\n::: {.cell-output .cell-output-display}\n![](EstimatingPi_files/figure-html/cell-2-output-1.png){width=457 height=429}\n:::\n:::\n\n\n::::\n\n\nThe equation of the circle is given by\n$$\nx^2+y^2=R^2.\n$$ {#eq-circle}\n\nThe area of the circle is given by the familiar formula\n\n$$\n\\pi R^2.\n$$\n\nThe smallest square within which the circle can be inscribed will have side length $2R$.\n\n::: {#fig-squarecircle fig-align=\"center\"}\n\n::: {#c9b42c6d .cell execution_count=2}\n\n::: {.cell-output .cell-output-display}\n![](EstimatingPi_files/figure-html/cell-3-output-1.png){width=457 height=429}\n:::\n:::\n\n\n:::\n\n\nHence the ratio of the area of the circle to that of the square is\n\n$$\n\\frac{\\pi R^2}{4 R^2}=\\frac{\\pi}{4}.\n$$\n\n\n## Estimating $\\pi$\n\nWe can use the above result to estimate $\\pi$ by randomly sampling points that sit inside the square. The probability of a randomly sampled point falling inside the inscribed circle in @fig-squarecircle is equal to the ratio of the areas, i.e.\n$$\n\\frac{\\pi}{4}.\n$$ \n\n\nWe can use a random number generator to uniformly sample $N_s$ points within the square, i.e. \n$$\nx_i \\in U_{0,2R}, \\quad y_i \\in U_{0,2R}, \\quad i=1,..,N.\n$$\nHere $U$ represents a uniform distribution and $N$ is the number of sampled points. \n\nWe can then count the number of randomly sampled points, $N_c$, that sit inside the circle, i.e. with coordinates that satisfy the inequality\n$$\nx_i^2+y_i^2< R^2.\n$$\n\nWe can then estimate $\\pi$ using the formula\n$$\n\\hat{\\pi}\\sim 4\\frac{N_c}{N_s}.\n$$\n\nIn @fig-apppi  we use an app to explore the approximation of $\\pi$. Here you can explore how the estimate for $\\pi$ depends on the number of samples and consider circles of different radii.\n\nIn the top plot the distribution of sampled points is plotted for a given realisation with the parameter values as you have chosen. In the bottom plot the estimate of $\\pi$ is averaged over 100 realisations and plotted against the number of sampled points, $N$.\n\n\n\n\n::: {#fig-apppi fig-align=\"center\"}\n\n```{shinylive-python}\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"N\",label=\"Num points per experiment\",min=10,max=3000,value=10,step=1),\n    ui.input_slider(id=\"R\",label=\"Radius\",min=2.0,max=15.0,value=10.0,step=1),\n    ui.input_slider(id=\"L\",label=\"Square side length\",min=15.0,max=30.0,value=20.0,step=1),  \n    ui.input_slider(id=\"N_Exp\",label=\"Num experiments\",min=1,max=300,value=1,step=1),           \n     \n              \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def estimate_pi(N,R,L): \n        x = np.random.uniform(0,L,N)\n        y = np.random.uniform(0,L,N)\n\n        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n        num_points_inside_circle=len(radius[radius<=R])\n\n        pi_est=(L/R)**2*(num_points_inside_circle/N)\n\n        return x,y,pi_est\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(2,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        N=int(input.N())\n        R=float(input.R())\n        L=float(input.L())\n        n_samples=int(input.N_Exp())\n        \n    \n        x,y,pi_est=estimate_pi(N,R,L)\n\n        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n        \n        ax[0].plot(x[radius<R],y[radius<R],'b.')\n        ax[0].plot(x[radius>R],y[radius>R],'k.')\n\n        ax[0].set_xlabel('$x$')\n        ax[0].set_ylabel('$y$')\n\n        theta=np.linspace(0,2*np.pi,1000)\n        ax[0].plot(R*np.cos(theta)+L/2.0,R*np.sin(theta)+L/2.0,'r')\n        ax[0].set_title('$\\hat{\\pi}$='+str(pi_est))\n\n        \n        N_vec=np.linspace(10,3000,80,dtype=int)\n        pi_est_vec=np.zeros_like(N_vec,dtype=float)\n        for i in range(len(N_vec)):\n            pi_est_i=np.zeros((n_samples,1),dtype=float)\n            for j in range(n_samples):\n                x,y,pi_est=estimate_pi(N_vec[i],R,L)\n                pi_est_i[j]=pi_est\n            pi_est_vec[i]=np.mean(pi_est_i)\n\n        ax[1].plot(N_vec,pi_est_vec,'.',N_vec,np.pi*np.ones_like(N_vec))\n        ax[1].set_xlabel('$N$')\n        ax[1].set_ylabel('$\\hat{\\pi}$')\n        #plt.Circle([0.0, 0.0 ],R,fill = False,axis=ax)\n        #ax.Circle((0.0, 0.0 ),R,fill = False )\n\n\n        fig.tight_layout()\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n```\n:::\n\n",
    "supporting": [
      "EstimatingPi_files"
    ],
    "filters": [],
    "includes": {}
  }
}