{
  "hash": "fc3b97e67620facd48106a13b36e74ed",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Turing patterns\"\nformat: html \nimage: 'DampedOscillation.png'\ncategories: [Differential Equations, Calculus, Mathematical Biology]\nfilters:\n  - shinylive\n---\n\n::: {#d040eeb7 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\nfrom scipy.sparse.linalg import inv\n\n# Model parameters\ngamma=100.0\na=0.2\nb=1.3\nD_u = 1           # Diffusion coefficient\nD_v = 35.0           # Diffusion coefficient\n\n# Parameters\nLx, Ly = 6.0, 1.0  # Domain size\nNx, Ny = 50,50     # Number of grid points\nT = 8         # Total simulation time\nNt = 1200          # Number of time steps\n\n\ndef build_A(D,dt,dy,dx,Ny,Nx):\n    # Build sparse matrix for implicit scheme\n    # Stability parameters\n    rx = D * dt / dx**2\n    ry = D * dt / dy**2\n    #assert rx + ry <= 0.5, \"Stability condition violated: Reduce dt or increase grid resolution.\"\n    N = Nx * Ny  # Total number of grid points\n    \n    # Construct the sparse matrix\n    offsets = [1, -1, Nx, -Nx]\n    diagonals = [-rx, -rx, -ry, -ry]\n    offsets = [1, -1, Nx, -Nx]\n    A = diags(diagonals, offsets,shape=(N,N), format=\"csr\")\n    \n    # Loop over left and right boundaries of domain\n    for left_bdy in range(Nx,Nx*(Ny-1),Nx):\n        A[left_bdy,left_bdy-1]=0.0\n\n        right_bdy=left_bdy+Nx-1\n        A[right_bdy,right_bdy+1]=0.0\n\n    # corners\n    A[Nx-1,Nx]=0\n    A[Nx*(Ny-1),Nx*(Ny-1)-1]=0\n\n    # Ensure Neumann boundary condition: Adjust diagonal elements so each row sums to zero\n    A = A.tolil()\n    for i in range(N):\n        row_sum = A[i,:].sum()\n        A[i, i] =1.0-row_sum  # Adjust diagonal to enforce sum zero\n    A = A.tocsr()\n\n    return A\n\ndef diffusion_2d_implicit(Lx, Ly, Nx, Ny, T, Nt, D_u,D_v):\n    \"\"\"\n    Solves  2D reaction diffusion equation using an implicit finite difference scheme.\n    \n    Parameters:\n        Lx, Ly: Length of the domain in x and y directions.\n        Nx, Ny: Number of grid points in x and y directions.\n        T: Total simulation time.\n        Nt: Number of time steps.\n        D_u: Diffusion coefficient.\n        D_v: Diffusion coefficient.\n\n    \n    Returns:\n        u, v: Solution array (Nx x Ny x Nt+1) at all time steps.\n        x, y: Spatial grid points.\n    \"\"\"\n    # Spatial and temporal grid\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n    dt = T / Nt\n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n\n    # Initialize solution\n    u = np.zeros((Nx, Ny))  # Initial condition (can be modified)\n    v = np.zeros((Nx, Ny))  # Initial condition (can be modified)\n\n    # Set initial condition (example: Gaussian peak in the center)\n    X, Y = np.meshgrid(x, y, indexing=\"ij\")\n    \n    #u=X\n    u[:, :]=(a+b)*np.ones_like(X)+0.01*np.random.uniform(low=-1.0, high=1.0, size=(X.shape))\n    v[:, :]= b*(1/(a+b)**2)*np.ones_like(X)+0.01*np.random.uniform(low=-1.0, high=1.0, size=(X.shape))\n\n    # Flatten the 2D grid into a 1D vector for solving the linear system\n    u = u.flatten()\n    v = v.flatten()\n\n    A_u=build_A(D_u,dt,dx,dy,Nx,Ny)\n    A_v=build_A(D_v,dt,dx,dy,Nx,Ny)\n    \n\n    for n in range(Nt):\n        # Solve the linear system: A * u^{n+1} = u^n\n        reaction_term_u=gamma*(a-u+(u**2)*v)\n        reaction_term_v=gamma*(b-(u**2)*v)\n\n        rhs_u=u+dt*reaction_term_u\n        u = spsolve(A_u, rhs_u)\n\n        rhs_v=v+dt*reaction_term_v\n        v = spsolve(A_v, rhs_v)\n\n    # Reshape the solution back into 2D\n    u = u.reshape((Nx, Ny))\n    v = v.reshape((Nx, Ny))\n\n    return u,v, x, y\n\n\n\n# Solve the 2D diffusion equation\nu,v, x, y = diffusion_2d_implicit(Lx, Ly, Nx, Ny, T, Nt, D_u,D_v)\n\n# Plot the final solution\nfig,ax=plt.subplots(1,2,figsize=(8, 6))\nim=ax[0].imshow(u,vmin=1,vmax=5,extent=[0,Ly,0,Lx])#, 20, cmap=\"viridis\")\nplt.colorbar(im,label=\"u\")\nax[0].set_xlabel(\"x\")\nax[0].set_ylabel(\"y\")\nax[0].set_title(\"u\")\n\nim=ax[1].imshow(v,extent=[0,Ly,0,Lx])#, 20, cmap=\"viridis\")\nplt.colorbar(im,label=\"v\")\nax[1].set_xlabel(\"x\")\nax[1].set_ylabel(\"y\")\nax[1].set_title(\"v\")\n\n\nplt.show()\n\n```\n\n::: {.cell-output .cell-output-display}\n![](TuringPatterns_files/figure-html/cell-2-output-1.png){width=547 height=523}\n:::\n:::\n\n\n```{shinylive-python}\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\nfrom scipy.sparse.linalg import inv\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=0.01,max=3,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=4.0,value=1.4,step=0.1),             \n    ui.input_slider(id=\"D_u\",label=\"D_u\",min=0.0,max=30.0,value=5.0,step=1.0),   \n    ui.input_slider(id=\"D_v\",label=\"D_v\",min=0.0,max=20.0,value=5.0,step=1.0),\n    ui.input_slider(id=\"L_x\",label=\"L_x\",min=1.0,max=4.0,value=1,step=0.2),\n    ui.input_slider(id=\"L_y\",label=\"L_y\",min=1.0,max=4.0,value=2.0,step=0.1),\n       ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        #gamma=float(input.gamma())\n        D_u=float(input.D_u())\n        D_v=float(input.D_v())\n        Lx=float(input.L_x())\n        Ly=float(input.L_y())\n        # Model parameters\n        #b=1.4\n\n        gamma=40.0\n        # Parameters\n        #Lx, Ly = 6.0, 1.0  # Domain size\n        Nx, Ny = 50,50     # Number of grid points\n        T = 8         # Total simulation time\n        Nt = 400          # Number of time steps\n\n        def build_A(D,dt,dy,dx,Ny,Nx):\n            # Build sparse matrix for implicit scheme\n            # Stability parameters\n            rx = D * dt / dx**2\n            ry = D * dt / dy**2\n            #assert rx + ry <= 0.5, \"Stability condition violated: Reduce dt or increase grid resolution.\"\n            N = Nx * Ny  # Total number of grid points\n            \n            # Construct the sparse matrix\n            offsets = [1, -1, Nx, -Nx]\n            diagonals = [-rx, -rx, -ry, -ry]\n            offsets = [1, -1, Nx, -Nx]\n            A = diags(diagonals, offsets,shape=(N,N), format=\"csr\")\n            \n            # Loop over left and right boundaries of domain\n            for left_bdy in range(Nx,Nx*(Ny-1),Nx):\n                A[left_bdy,left_bdy-1]=0.0\n\n                right_bdy=left_bdy+Nx-1\n                A[right_bdy,right_bdy+1]=0.0\n\n            # corners\n            A[Nx-1,Nx]=0\n            A[Nx*(Ny-1),Nx*(Ny-1)-1]=0\n\n            # Ensure Neumann boundary condition: Adjust diagonal elements so each row sums to zero\n            A = A.tolil()\n            for i in range(N):\n                row_sum = A[i,:].sum()\n                A[i, i] =1.0-row_sum  # Adjust diagonal to enforce sum zero\n            A = A.tocsr()\n\n            return A\n\n        def diffusion_2d_implicit(Lx, Ly, Nx, Ny, T, Nt, D_u,D_v):\n            \"\"\"\n            Solves  2D reaction diffusion equation using an implicit finite difference scheme.\n            \n            Parameters:\n                Lx, Ly: Length of the domain in x and y directions.\n                Nx, Ny: Number of grid points in x and y directions.\n                T: Total simulation time.\n                Nt: Number of time steps.\n                D_u: Diffusion coefficient.\n                D_v: Diffusion coefficient.\n\n            \n            Returns:\n                u, v: Solution array (Nx x Ny x Nt+1) at all time steps.\n                x, y: Spatial grid points.\n            \"\"\"\n            # Spatial and temporal grid\n            dx = Lx / (Nx - 1)\n            dy = Ly / (Ny - 1)\n            dt = T / Nt\n            x = np.linspace(0, Lx, Nx)\n            y = np.linspace(0, Ly, Ny)\n\n            # Initialize solution\n            u = np.zeros((Nx, Ny))  # Initial condition (can be modified)\n            v = np.zeros((Nx, Ny))  # Initial condition (can be modified)\n\n            # Set initial condition (example: Gaussian peak in the center)\n            X, Y = np.meshgrid(x, y, indexing=\"ij\")\n            \n            #u=X\n            u[:, :]=(a+b)*np.ones_like(X)+0.01*np.random.uniform(low=-1.0, high=1.0, size=(X.shape))\n            v[:, :]= b*(1/(a+b)**2)*np.ones_like(X)+0.01*np.random.uniform(low=-1.0, high=1.0, size=(X.shape))\n\n            # Flatten the 2D grid into a 1D vector for solving the linear system\n            u = u.flatten()\n            v = v.flatten()\n\n            A_u=build_A(D_u,dt,dx,dy,Nx,Ny)\n            A_v=build_A(D_v,dt,dx,dy,Nx,Ny)\n            \n\n            for n in range(Nt):\n                # Solve the linear system: A * u^{n+1} = u^n\n                reaction_term_u=gamma*(a-u+(u**2)*v)\n                reaction_term_v=gamma*(b-(u**2)*v)\n\n                rhs_u=u+dt*reaction_term_u\n                u = spsolve(A_u, rhs_u)\n\n                rhs_v=v+dt*reaction_term_v\n                v = spsolve(A_v, rhs_v)\n\n            # Reshape the solution back into 2D\n            u = u.reshape((Nx, Ny))\n            v = v.reshape((Nx, Ny))\n\n            return u,v, x, y\n\n\n\n        # Solve the 2D diffusion equation\n        u,v, x, y = diffusion_2d_implicit(Lx, Ly, Nx, Ny, T, Nt, D_u,D_v)\n\n        # Plot the final solution\n        fig,ax=plt.subplots(1,2,figsize=(8, 6))\n        im=ax[0].imshow(u,vmin=1,vmax=5,extent=[0,Ly,0,Lx])#, 20, cmap=\"viridis\")\n        plt.colorbar(im,label=\"u\")\n        ax[0].set_xlabel(\"x\")\n        ax[0].set_ylabel(\"y\")\n        ax[0].set_title(\"u\")\n\n        im=ax[1].imshow(v,extent=[0,Ly,0,Lx])#, 20, cmap=\"viridis\")\n        plt.colorbar(im,label=\"v\")\n        ax[1].set_xlabel(\"x\")\n        ax[1].set_ylabel(\"y\")\n        ax[1].set_title(\"v\")\n\n\n        plt.show()\n\n\n\n    \napp = App(app_ui, server)\n```\n:::\n\n\n\n\n\n\n:::{.callout-note}\n\nAt Dundee, core concepts from calculus (e.g. differential equations) are studied in the modules  *Maths 1A* and *Maths 1B* and developed further in the modules  *Maths 2A* and *Maths 2B*.\n\n\nAt Level 2  in the modules *Computer algebra and dynamical systems* and *Introduction to Programming* you would be introduced to techniques that are used to compute numerical solutions to differential equations. \n\nAt Level 3 in the module  *Differential Equations*  you would extend your knowledge of differential equations to include concepts such as Fourier Series and Partial Differential Equations. In the modules *Mathematical Biology I* and *Mathematical Biology II* you would also learn how to formulate and study mathematical models of biological systems.\n\nYou can find out more about these modules [here](https://www.dundee.ac.uk/undergraduate/mathematics-bsc/teaching-and-assessment).\n\n:::\n\n",
    "supporting": [
      "TuringPatterns_files"
    ],
    "filters": [],
    "includes": {}
  }
}