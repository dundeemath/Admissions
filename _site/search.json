[
  {
    "objectID": "WorkSheetPrintOut.html",
    "href": "WorkSheetPrintOut.html",
    "title": "Pop. dynamics worksheet",
    "section": "",
    "text": "The aim of this demonstration is to show how we can use ideas from calculus to study dynamical systems.\n\nIt is not intended that you work through all the questions in the available time.\nYou are encouraged to use your phone to explore the linked apps"
  },
  {
    "objectID": "WorkSheetPrintOut.html#formulating-a-model-of-population-dynamics",
    "href": "WorkSheetPrintOut.html#formulating-a-model-of-population-dynamics",
    "title": "Pop. dynamics worksheet",
    "section": "3.1 Formulating a model of population dynamics",
    "text": "3.1 Formulating a model of population dynamics\nLet’s consider a model for the number of people in a room at a given time. Let \\(t\\) represent time and \\(N(t)\\) represent the number of people in the room at time \\(t\\).\nSuppose that there are initially no people in the room, but people enter at a constant rate, \\(k\\).\nWe could formulate a model of population dynamics given by\n\\[\n\\frac{dN}{dt}=k, \\quad N(0)=0.\n\\tag{1}\\]\n\n\n\n\n\n\nQuestion\n\n\n\n\nCan you integrate Equation 1 (Hint: it is mathematically equivalent to the ODE introduced in Section 2)?\n\n\n\n\n\n\n\n\n\n\nCan you use the solution of the model to determine the amount of time taken for the number of people in the room to reach some capacity, \\(N_C\\).\n\n\n\n\n\n\n\n\nCan you use the app (see Figure 1) to identify what the entry rate, \\(k\\), needs to be such that the room reaches capacity of 40 people after 20 minutes?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: https://dundeemath.github.io/Admissions/posts/PopulationDynamicsIntro.html."
  },
  {
    "objectID": "WorkSheetPrintOut.html#what-if-people-enter-the-room-at-a-constant-rate-but-also-leave-the-room-at-random",
    "href": "WorkSheetPrintOut.html#what-if-people-enter-the-room-at-a-constant-rate-but-also-leave-the-room-at-random",
    "title": "Pop. dynamics worksheet",
    "section": "3.2 What if people enter the room at a constant rate but also leave the room at random?",
    "text": "3.2 What if people enter the room at a constant rate but also leave the room at random?\nTaking the previous model as a starting point, we now assume that people can also leave the room at a rate proportional to the number of people in the room\nThe model equation is now given by\n\\[\n\\frac{dN}{dt}=k - dN, \\quad N(0)=0.\n\\tag{2}\\]\n\n\n\n\n\n\nQuestion\n\n\n\nIt is possible to integrate Equation 2 and show that the solution is \\[\nN(t)=\\frac{k}{d}(1-e^{-dt})\n\\tag{3}\\]\nCan you do this? (hint: try using an integrating factor)?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nCan you use the model solution (Equation 3) to determine the amount of time taken for the number of people in the room to reach capacity, \\(N_C\\). Does a solution always exist?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nCan you use the app or the solution (Equation 3) to identify the entry rate needs to be such that the room reaches capacity of 40 people after 20 minutes given \\(d=0.1\\)?"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#why-maths",
    "href": "Slides/TasterDayMay2024.html#why-maths",
    "title": "Taster Day 2024",
    "section": "Why Maths?",
    "text": "Why Maths?"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#maths-careers",
    "href": "Slides/TasterDayMay2024.html#maths-careers",
    "title": "Taster Day 2024",
    "section": "Maths careers",
    "text": "Maths careers"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#recent-gradautes",
    "href": "Slides/TasterDayMay2024.html#recent-gradautes",
    "title": "Taster Day 2024",
    "section": "Recent gradautes",
    "text": "Recent gradautes\nOur recent graduates have gone on to work as:\n\naccountants\ntrade analysts\ntransport planners\nactuaries\nengineers\nteachers\nsoftware developers\ndata analysts\nand many others"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#mathematics-degrees-at-dundee",
    "href": "Slides/TasterDayMay2024.html#mathematics-degrees-at-dundee",
    "title": "Taster Day 2024",
    "section": "Mathematics degrees at Dundee",
    "text": "Mathematics degrees at Dundee\n\nSingle honours Mathematics degrees\nBSc Mathematics/MMath\nJoint degrees (e.g.)\n\nBSc Mathematical Biology\nBSc Maths and Economics\nBSc Maths and Physics\nBSc Maths and Accountancy"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#what-you-will-learn",
    "href": "Slides/TasterDayMay2024.html#what-you-will-learn",
    "title": "Taster Day 2024",
    "section": "What you will learn?",
    "text": "What you will learn?\n\nCore mathematical skills (e.g. calculus, integration, algebra)\nFoundations of mathematics\nApplication of mathematics to real world problems"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#how-you-will-learn",
    "href": "Slides/TasterDayMay2024.html#how-you-will-learn",
    "title": "Taster Day 2024",
    "section": "How you will learn?",
    "text": "How you will learn?\n\nTwo teaching semesters in the academic year\n3 or 4 modules in each semester\nIn each module (some combination of):\n\nlectures\ntutorials\nworkshops\ncomputer classes"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#final-year-project",
    "href": "Slides/TasterDayMay2024.html#final-year-project",
    "title": "Taster Day 2024",
    "section": "Final year project",
    "text": "Final year project\n\ndevelop independent problem solving skills\nwork on an exciting mathematical topic\ndevelop programming skills\ndevelop presentation skills\nTopics include:\n\nThe $25,000,000,000 eigenvector\nConformal mappings in the art of M.C. Escher\nThe Mathematics of monopoly\nHow Sat Navs work"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#skills-developed-throughout-your-degree",
    "href": "Slides/TasterDayMay2024.html#skills-developed-throughout-your-degree",
    "title": "Taster Day 2024",
    "section": "Skills developed throughout your degree",
    "text": "Skills developed throughout your degree\n\nYou will become a logical numerate problem solver\nMathematical skills\nPure mathematics\nApplied mathematics\nPresentation skills\nComputer programming skills"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#design-constraints",
    "href": "Slides/TasterDayMay2024.html#design-constraints",
    "title": "Taster Day 2024",
    "section": "Design constraints",
    "text": "Design constraints\nWe want to identify some interesting problem (s) that:\n\nconnect from high school syllabus to University level mathematics\nhave an element of visualisation\nhave some interesting mathematics\nare interactive\nare accessible"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#lets-look-at-some-working-examples",
    "href": "Slides/TasterDayMay2024.html#lets-look-at-some-working-examples",
    "title": "Taster Day 2024",
    "section": "Let’s look at some working examples",
    "text": "Let’s look at some working examples\nhttps://dundeemath.github.io/Admissions/\n\nExplore apps"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#possible-topics",
    "href": "Slides/TasterDayMay2024.html#possible-topics",
    "title": "Taster Day 2024",
    "section": "Possible topics",
    "text": "Possible topics\n\nGraphing functions and their derivatives\nRecursion relations\nTrigonometric identities\nDifferential equations\nStatistical tests\nComplex numbers\nWhat would you like to work on?"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#what-we-need-to-do-today",
    "href": "Slides/TasterDayMay2024.html#what-we-need-to-do-today",
    "title": "Taster Day 2024",
    "section": "What we need to do today",
    "text": "What we need to do today\n\nfocus on some ideas for a new app\nwrite some prototype code\ndecide how to make it interactive\nwrite some text to explain the ideas in the app\nbuild the app"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#section",
    "href": "Slides/TasterDayMay2024.html#section",
    "title": "Taster Day 2024",
    "section": "",
    "text": "## Prototype code that plots a trigonometric function and its derivative\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndx=0.01\nx = np.arange(0, 20, dx)\ny = np.sin(x)\n\ndy_dx=np.cos(x)\n\nfig, ax = plt.subplots(1,2)\nax[0].plot(x, y)\nax[0].set_xlabel('x')\nax[0].set_ylabel('y(x)')\n\nax[1].plot(x, dy_dx)\nax[1].set_xlabel('x')\nax[1].set_ylabel('dy/dx')\n\nax[0].grid(True)\nax[1].grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\nMathematics, University of Dundee"
  },
  {
    "objectID": "posts/GraduateEmployment.html",
    "href": "posts/GraduateEmployment.html",
    "title": "Graduate employment",
    "section": "",
    "text": "A mathematics degree will enable you to become a logical numerate problem solver. Over the course of your degree you will develop"
  },
  {
    "objectID": "posts/GraduateEmployment.html#career-earnings",
    "href": "posts/GraduateEmployment.html#career-earnings",
    "title": "Graduate employment",
    "section": "Career earnings",
    "text": "Career earnings\nMathematics degrees are associated with higher career earnings compared with many other disciplines. In the table below median salaries are compared across different discplines. In this dataset mathematical sciences degrees have the fourth highest median salary.\n\n\n\n\n\nData provided by HESA (2020/2021)"
  },
  {
    "objectID": "posts/GraduateEmployment.html#where-our-graduates-get-employed",
    "href": "posts/GraduateEmployment.html#where-our-graduates-get-employed",
    "title": "Graduate employment",
    "section": "Where our graduates get employed?",
    "text": "Where our graduates get employed?\n\nData analyst\nActuary\nAccountant\nPhD\nData scientist\nTransport engineer\nManagement consultant\nTeacher\nOperations analyst\nFinancial engineer\nOperations research\nTax consultant\nEnergy risk analyst\nInsurance underwriter\nSoftware engineer\nCredit risk analyst\nHedge fund analyst"
  },
  {
    "objectID": "posts/SecondOrderODEs.html",
    "href": "posts/SecondOrderODEs.html",
    "title": "Second order ODEs",
    "section": "",
    "text": "We can use calculus to study how quantities change in time. In the examples below we consider a second order linear ordinary differential equation (ODE) with constant coefficients."
  },
  {
    "objectID": "posts/SecondOrderODEs.html#formulating-a-model-of-population-dynamics",
    "href": "posts/SecondOrderODEs.html#formulating-a-model-of-population-dynamics",
    "title": "Second order ODEs",
    "section": "Formulating a model of population dynamics",
    "text": "Formulating a model of population dynamics\nLet’s consider a scalar second order ODE with constant coefficients. Let \\(t\\) represent time and \\(y=y(t)\\). Suppose that\n\\[\na\\frac{d^2 y}{dt^2}+b\\frac{dy}{dt}+cy=0,\n\\tag{2}\\] where \\(a\\), \\(b\\) and \\(c\\) are constants.\nConsider the initial conditions\n\\[\ny(t=0)=y_0 \\quad \\quad \\frac{dy}{dt}\\bigg|_{{t=0}}=d.\n\\tag{3}\\]\nThe app in Figure 1 allows you to explore the solution of the model (Equation 2 and Equation 3).\nCan you identify the following three behaviours by adjusting model parameters:\n\nperiodic oscillations\ndamped oscillations\nexpoentially decaying but non-oscillatory solutions\n\nCan you * describe model behaviour as \\(a\\rightarrow 0\\). * explore model behaviour as \\(c\\rightarrow 0\\). * describe how the oscillation period depends on model parameters.\nNote that it is possible to solve Equation 2 and Equation 3 by seeking a solution of the form \\[\ny=e^{\\lambda t}.\n\\] This is left as an exercise.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=0.01,max=3,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=15.0,value=10.0,step=0.1),             \n    ui.input_slider(id=\"c\",label=\"c\",min=0.0,max=30.0,value=5.0,step=1.0),   \n    ui.input_slider(id=\"y0\",label=\"y(t=0)\",min=0.0,max=20.0,value=5.0,step=1.0),\n    ui.input_slider(id=\"y0p\",label=\"dy/dt(t=0)\",min=0.0,max=20.0,value=1,step=1.0),\n    ui.input_slider(id=\"T\",label=\"Simulation time\",min=0.0,max=60.0,value=20.0,step=0.5),\n              \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        c=float(input.c())\n        y_0=float(input.y0())\n        y_0_p=float(input.y0p())\n        T=float(input.T())\n        \n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(y,t,a,b,c):\n          rhs=np.zeros_like(y,dtype=float)\n\n          z=y[1]\n\n          #ay'' + by'+cy=0\n          # y'=z\n          # z'=y''=-(by'+cy)/a\n\n\n          dy_dt=y[1]\n          dz_dt=-(b*z+c*y[0])/a\n\n          rhs[0]=dy_dt\n          rhs[1]=dz_dt\n\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[y_0,y_0_p]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_pop_model, init_cond,t,args=(a,b,c))\n\n        # Plot results\n        y=sol1[:,0]\n        yp=sol1[:,1]\n        \n        \n        ax.plot(t, y)\n        ax.set_xlabel('$t$')\n        ax.set_ylabel('$y(t)$')\n\n        plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) are studied in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the modules Computer algebra and dynamical systems and Introduction to Programming you would be introduced to techniques that are used to compute numerical solutions to differential equations.\nAt Level 3 in the module Differential Equations you would extend your knowledge of differential equations to include concepts such as Fourier Series and Partial Differential Equations. In the modules Mathematical Biology I and Mathematical Biology II you would also learn how to formulate and study mathematical models of biological systems.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/PopulationDynamicsIntro.html",
    "href": "posts/PopulationDynamicsIntro.html",
    "title": "Introduction to population dynamics",
    "section": "",
    "text": "We can use calculus to study how populations change in time. In the examples below we consider an illustative model of population dynamics in a class room. The developed concepts can be used to study population dynamics of infectious disease transmission.\n\n\nYou might have previously encountered differentiation. Suppose that \\(y\\) is some function of \\(x\\).\nConsider the differential equation\n\\[\n\\frac{dy}{dx}=1\n\\]\nUpon integration\n\\[\ny(x)=x+C\n\\] where \\(C\\) is an integration constant.\nWhat if \\[\n\\frac{dy}{dx}=x\n\\]\nCan you integrate this ordinary differential equation?"
  },
  {
    "objectID": "posts/PopulationDynamicsIntro.html#sec-background",
    "href": "posts/PopulationDynamicsIntro.html#sec-background",
    "title": "Introduction to population dynamics",
    "section": "",
    "text": "You might have previously encountered differentiation. Suppose that \\(y\\) is some function of \\(x\\).\nConsider the differential equation\n\\[\n\\frac{dy}{dx}=1\n\\]\nUpon integration\n\\[\ny(x)=x+C\n\\] where \\(C\\) is an integration constant.\nWhat if \\[\n\\frac{dy}{dx}=x\n\\]\nCan you integrate this ordinary differential equation?"
  },
  {
    "objectID": "posts/PopulationDynamicsIntro.html#constant-entry-rate",
    "href": "posts/PopulationDynamicsIntro.html#constant-entry-rate",
    "title": "Introduction to population dynamics",
    "section": "2.1 Constant entry rate",
    "text": "2.1 Constant entry rate\nLet’s consider a model for the number of people in a classroom at a given time. Let \\(t\\) represent time and \\(N(t)\\) represent the number of people in the room at time \\(t\\).\nSuppose that there are initially no people in the room, but people enter at a constant rate, \\(k\\).\nWe could formulate a model of population dynamics given by\n\\[\n\\frac{dN}{dt}=k, \\quad N(0)=0.\n\\]\n\nCan you integrate this ODE (hint: it is mathematically equivalent to the ODE introduced in Section 1.1)?\nCan you use the model to determine the amount of time taken for the number of people in the room to reach capacity, \\(N_C\\).\nThe app in Figure 1 allows you to explore the solution of the model. Can you identify what the entry rate needs to be such that the room reaches capacity of 40 people after 20 minutes?\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"k\",label=\"Entry rate (per minute)\",min=0.01,max=3,value=0.1,step=0.00001),\n    ui.input_slider(id=\"N0\",label=\"initial pop\",min=0.0,max=20.0,value=0.1,step=1.0),\n    \n    ui.input_slider(id=\"T\",label=\"Simulation time (minutes)\",min=0.0,max=60.0,value=20.0,step=0.5),\n    ui.input_slider(id=\"max_inf\",label=\"Max. num\",min=0.0,max=100.0,value=40.0,step=1.5),             \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        k=float(input.k())\n        N_0=float(input.N0())\n        T=float(input.T())\n        max_inf=float(input.max_inf())\n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(x,t,k,r):\n          rhs=np.zeros_like(x,dtype=float)\n          N=x[0]\n          dN_dt=k\n          rhs[0]=dN_dt\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[N_0]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_pop_model, init_cond,t,args=(k,1))\n\n        # Plot results\n        N=sol1[:,0]\n        \n        \n        ax.plot(t, N)\n        ax.plot(t,max_inf*np.ones_like(t),'--')\n        ax.legend(['N','Max. room occupancy'],loc='best')\n        ax.set_xlabel('$t$ (minutes)')\n        ax.set_ylim([0,max_inf*1.4])\n\n        #plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1"
  },
  {
    "objectID": "posts/PopulationDynamicsIntro.html#what-if-people-enter-the-room-at-a-constant-rate-but-also-leave-the-room-at-random",
    "href": "posts/PopulationDynamicsIntro.html#what-if-people-enter-the-room-at-a-constant-rate-but-also-leave-the-room-at-random",
    "title": "Introduction to population dynamics",
    "section": "2.2 What if people enter the room at a constant rate but also leave the room at random?",
    "text": "2.2 What if people enter the room at a constant rate but also leave the room at random?\nTaking the previous model as a starting point, we now assume that people leave the room at a rate proportional to the number of people in the room\nThe model equation is now given by\n\\[\n\\frac{dN}{dt}=k - dN, \\quad N(0)=0.\n\\]\nCan you integrate this ODE (hint: try a technique called separation of variables)?\nIf so, can you use the model to determine the amount of time taken for the number of people in the room to reach capacity, \\(N_C\\).\nThe app in Figure 2 allows you to explore the solution of the model. Can you identify what the entry rate needs to be such that the room reaches capacity of 40 people after 20 minutes given \\(d=0.1\\)?\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 600\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"k\",label=\"Entry rate (per minute)\",min=0.01,max=10,value=0.1,step=0.00001),\n    ui.input_slider(id=\"d\",label=\"exit rate (per minute)\",min=0.01,max=3,value=0.1,step=0.00001),\n    ui.input_slider(id=\"N0\",label=\"initial pop\",min=0.0,max=20.0,value=0.1,step=1.0),\n    \n    ui.input_slider(id=\"T\",label=\"Simulation time (minutes)\",min=0.0,max=60.0,value=20.0,step=0.5),\n    ui.input_slider(id=\"max_inf\",label=\"Max. num\",min=0.0,max=100.0,value=40.0,step=1.5),             \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        k=float(input.k())\n        d=float(input.d())\n\n        N_0=float(input.N0())\n        T=float(input.T())\n        max_inf=float(input.max_inf())\n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(x,t,k,d):\n          rhs=np.zeros_like(x,dtype=float)\n          N=x[0]\n          dN_dt=k-d*N\n          rhs[0]=dN_dt\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[N_0]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_pop_model, init_cond,t,args=(k,d))\n\n        # Plot results\n        N=sol1[:,0]\n        \n        \n        ax.plot(t, N)\n        ax.plot(t,max_inf*np.ones_like(t),'--')\n        ax.legend(['N','Max. room occupancy'],loc='best')\n        ax.set_xlabel('$t$ (minutes)')\n        ax.set_ylim([0,max_inf*1.4])\n\n        #plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) are studied in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the modules Computer algebra and dynamical systems and Introduction to Programming you would be introduced to techniques that are used to compute numerical solutions to differential equations.\nAt Level 3 in the module Differential Equations you would extend your knowledge of differential equations to include concepts such as Fourier Series and Partial Differential Equations. In the modules Mathematical Biology I and Mathematical Biology II you would also learn how to formulate and study mathematical models of biological systems.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/RecurrenceRelations.html",
    "href": "posts/RecurrenceRelations.html",
    "title": "Recurrence relations and chaos",
    "section": "",
    "text": "You might have previously encountered a recurrence relation of the form\n\\[\nx_{n+1}=ax_n+b\n\\tag{1}\\] where \\(a\\) and \\(b\\) are constants.\nGiven numerical values for \\(a\\) and \\(b\\) and an initial condition, \\(x_0\\), a sequence can be computed that is a solution to Equation 1. This type of task is laborious and well suited to a computer (see Figure 1).\nExplore how the computed solution depend on model parameters as follows:\n\nset \\(b=0\\) by varying the parameter \\(a\\) identify solutions that:\n\ntend to zero monotonically\noscillate about 0\nblow up\n\nset b&gt;0\n\nshow that the solution converges to a non-zero value in the case where \\(0&lt;a&lt;1\\).\nshow that the solution is oscillatory for \\(-1&lt;a&lt;0\\).\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-1.0,max=3,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=15.0,value=10.0,step=0.01),             \n     \n    ui.input_slider(id=\"x0\",label=\"x_0\",min=0.0,max=20.0,value=5.0,step=1.0),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n              \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        x0=float(input.x0())\n        T=int(input.T())\n       \n        # Define rhs of LV ODEs\n        def rhs_pop_model(y,t,a,b):\n          \n\n          rhs=a*y+b\n\n          return rhs\n        def DiscreteSol(rhs_pop_model,y_0,t,a,b):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n                    y[i]=rhs_pop_model(y[i-1],t[i],a,b)\n            return y\n\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=x0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(rhs_pop_model,init_cond,t,a,b)\n\n        # Plot results\n        y=sol1\n        \n        ax.plot(t,y)\n        ax.set_xlabel('$n$')\n        ax.set_ylabel('$x_n$')\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1\n\n\n\n\n\n\nThe recurrence relation explored in Figure 1 is linear (the right-hand-side is a linear function of \\(x_n\\)). When the model is generalised much richer dynamical behaviours can be observed. One famous example is the logistic map, where the governing equation can be written as \\[\nx_{n+1}=rx_n(1-x_n).\n\\tag{2}\\]\nNote that the right-hand side is now a quadratic function of \\(x_n\\).\nYou can explore the solutions to Equation 2 using Figure 2.\n\nshow that when \\(0&lt;r&lt;1\\) the solution converges monotonically to 0.0.\nshow that when \\(0&lt;r&lt;2\\) the solution converges monotonically to a non-zero value.\nshow that when \\(2&lt;r&lt;3\\) the solution is oscillatory and converges to a non-zero value.\nshow that when \\(r=3.2\\) the solution is periodic and repeats every second step\nshow that when \\(r=3.47\\) the solution is periodic and repeats every fourth step\nshow that when \\(r=3.7\\) that the solution is neither periodic nor reaches a steady value.\n\nThe logistic map provides one of the simplest mathematical formulations of a phenomenon known as chaos. Whilst a precise definition of chaos involves some technical concepts, chaotic systems are broadly characterised by:\n\nhaving non-periodic, non-steady solution\nsensitivity to initial conditions\napprearing to be unpredictable even through they are deterministic.\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"r\",label=\"r\",min=0.0,max=5.0,value=0.1,step=0.01),             \n    ui.input_slider(id=\"x0\",label=\"x_0\",min=0.0,max=1.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n              \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        x0=float(input.x0())\n        T=int(input.T())\n       \n        # Define rhs of logistic map \n        def logistic_map(y,t,r):\n          rhs=r*y*(1-y)\n          return rhs\n        \n        def DiscreteSol(rhs_pop_model,y_0,t,r):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n\n                    y[i]=rhs_pop_model(y[i-1],t[i],r)\n            return y\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=x0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(logistic_map,init_cond,t,r)\n\n        # Plot results\n        y=sol1\n        \n        ax.plot(t,y)\n        ax.set_xlabel('$n$')\n        ax.set_ylabel('$x_n$')\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) and algebra that are needed to study dynamical systems are introduced in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the module Discrete Maths you would be introduced to discrete dynamical systems (e.g. recurrence relations, Markov chains). In the modules Introduction to Programming and Computer Algebra and Dynamical systems you would be introduced to techniques that enable you to numerically analyse difference equations.\nAt Level 3 in the module Mathematical Biology you would consider discrete dynamical systems model applied to Biological systems.\nAt Level 4 we offer a number of honours projects that investigate chaotic systems (e.g. the Lorenz equations, the double pendulum)\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/RecurrenceRelations.html#a-linear-recurrence-relation",
    "href": "posts/RecurrenceRelations.html#a-linear-recurrence-relation",
    "title": "Recurrence relations and chaos",
    "section": "",
    "text": "You might have previously encountered a recurrence relation of the form\n\\[\nx_{n+1}=ax_n+b\n\\tag{1}\\] where \\(a\\) and \\(b\\) are constants.\nGiven numerical values for \\(a\\) and \\(b\\) and an initial condition, \\(x_0\\), a sequence can be computed that is a solution to Equation 1. This type of task is laborious and well suited to a computer (see Figure 1).\nExplore how the computed solution depend on model parameters as follows:\n\nset \\(b=0\\) by varying the parameter \\(a\\) identify solutions that:\n\ntend to zero monotonically\noscillate about 0\nblow up\n\nset b&gt;0\n\nshow that the solution converges to a non-zero value in the case where \\(0&lt;a&lt;1\\).\nshow that the solution is oscillatory for \\(-1&lt;a&lt;0\\).\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-1.0,max=3,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=15.0,value=10.0,step=0.01),             \n     \n    ui.input_slider(id=\"x0\",label=\"x_0\",min=0.0,max=20.0,value=5.0,step=1.0),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n              \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        x0=float(input.x0())\n        T=int(input.T())\n       \n        # Define rhs of LV ODEs\n        def rhs_pop_model(y,t,a,b):\n          \n\n          rhs=a*y+b\n\n          return rhs\n        def DiscreteSol(rhs_pop_model,y_0,t,a,b):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n                    y[i]=rhs_pop_model(y[i-1],t[i],a,b)\n            return y\n\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=x0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(rhs_pop_model,init_cond,t,a,b)\n\n        # Plot results\n        y=sol1\n        \n        ax.plot(t,y)\n        ax.set_xlabel('$n$')\n        ax.set_ylabel('$x_n$')\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1"
  },
  {
    "objectID": "posts/RecurrenceRelations.html#the-logisitic-map",
    "href": "posts/RecurrenceRelations.html#the-logisitic-map",
    "title": "Recurrence relations and chaos",
    "section": "",
    "text": "The recurrence relation explored in Figure 1 is linear (the right-hand-side is a linear function of \\(x_n\\)). When the model is generalised much richer dynamical behaviours can be observed. One famous example is the logistic map, where the governing equation can be written as \\[\nx_{n+1}=rx_n(1-x_n).\n\\tag{2}\\]\nNote that the right-hand side is now a quadratic function of \\(x_n\\).\nYou can explore the solutions to Equation 2 using Figure 2.\n\nshow that when \\(0&lt;r&lt;1\\) the solution converges monotonically to 0.0.\nshow that when \\(0&lt;r&lt;2\\) the solution converges monotonically to a non-zero value.\nshow that when \\(2&lt;r&lt;3\\) the solution is oscillatory and converges to a non-zero value.\nshow that when \\(r=3.2\\) the solution is periodic and repeats every second step\nshow that when \\(r=3.47\\) the solution is periodic and repeats every fourth step\nshow that when \\(r=3.7\\) that the solution is neither periodic nor reaches a steady value.\n\nThe logistic map provides one of the simplest mathematical formulations of a phenomenon known as chaos. Whilst a precise definition of chaos involves some technical concepts, chaotic systems are broadly characterised by:\n\nhaving non-periodic, non-steady solution\nsensitivity to initial conditions\napprearing to be unpredictable even through they are deterministic.\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"r\",label=\"r\",min=0.0,max=5.0,value=0.1,step=0.01),             \n    ui.input_slider(id=\"x0\",label=\"x_0\",min=0.0,max=1.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n              \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        x0=float(input.x0())\n        T=int(input.T())\n       \n        # Define rhs of logistic map \n        def logistic_map(y,t,r):\n          rhs=r*y*(1-y)\n          return rhs\n        \n        def DiscreteSol(rhs_pop_model,y_0,t,r):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n\n                    y[i]=rhs_pop_model(y[i-1],t[i],r)\n            return y\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=x0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(logistic_map,init_cond,t,r)\n\n        # Plot results\n        y=sol1\n        \n        ax.plot(t,y)\n        ax.set_xlabel('$n$')\n        ax.set_ylabel('$x_n$')\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) and algebra that are needed to study dynamical systems are introduced in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the module Discrete Maths you would be introduced to discrete dynamical systems (e.g. recurrence relations, Markov chains). In the modules Introduction to Programming and Computer Algebra and Dynamical systems you would be introduced to techniques that enable you to numerically analyse difference equations.\nAt Level 3 in the module Mathematical Biology you would consider discrete dynamical systems model applied to Biological systems.\nAt Level 4 we offer a number of honours projects that investigate chaotic systems (e.g. the Lorenz equations, the double pendulum)\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/QuadraticCubicRoots.html",
    "href": "posts/QuadraticCubicRoots.html",
    "title": "Roots of quadratic/cubic equations",
    "section": "",
    "text": "Roots of quadratic and cubic equations\nConsider the cubic equation \\[\nax^3+bx^2+cx+d=0, \\ \\ \\quad a,b,c, d \\in \\Re.\n\\tag{1}\\]\nA special case you may have seen before occurs when \\(a=0\\). Hence \\[\nbx^2+cx+d=0.\n\\]\nIn this case the roots of the quadratic are \\[\nx=\\frac{-c\\pm\\sqrt{c^2-4bd}}{2b}.\n\\]\nIn the app in Figure 1 you can play with the parameter \\(a\\), \\(b\\), \\(c\\) and \\(d\\) and explore how they affect the form of the cubic equation Equation 1.\n\n\n\n\n\n\nTip\n\n\n\nPlease note that the app in Figure 1 is approximately 20 MB. If it does not display on your device:\n\nwait a few moments (it is downloading the Python code that will run the app)\nrefresh your browser.\n\ntry running on a faster connection/ more powerful device.\n\nIf it still does not load, here is a screenshot.\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-5,max=5,value=1.0,step=0.1),\n    ui.input_slider(id=\"b\",label=\"b\",min=-5.0,max=5.0,value=1.0,step=0.1),\n    ui.input_slider(id=\"c\",label=\"c\",min=-5.0,max=10.0,value=5.0,step=0.1),            \n    ui.input_slider(id=\"d\",label=\"d\",min=-5.0,max=10.0,value=5.0,step=0.1),            \n    ui.input_slider(id=\"min_x\",label=\"Min x \",min=-10.0,max=10.0,value=-5.0,step=0.1),  \n    ui.input_slider(id=\"max_x\",label=\"Max x\",min=-10.0,max=10.0,value=5.0,step=0.1),\n        \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        c=float((input.c()))\n        d=float((input.d()))\n\n        min_x=float(input.min_x())\n        max_x=float(input.max_x())\n\n        \n        # Define rhs of LV ODEs\n        def rhs(x,a,b,c,d):\n          rhs=np.zeros_like(x,dtype=float)\n          rhs=a*x**3+b*x**2+c*x+d\n\n          return rhs\n\n        # Define discretised t domain\n        x = np.linspace(min_x, max_x, 1000)\n\n        # define initial conditions\n        \n        # Compute numerical solution of ODEs\n        y = rhs(x,a,b,c,d)\n\n        coeff=[a,b,c,d]\n        roots=np.roots(coeff)\n\n        roots=np.round(roots,2)\n        ax.plot(x, y,np.real(roots),np.zeros_like(np.real(roots)),'rx')\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n        y_lim_p=-15.0 #np.min([100,np.max(y)])\n        y_lim_m=15.0 #np.max([-100,np.min(y)])\n\n        ax.set_ylim([y_lim_m,y_lim_p])\n        ax.invert_yaxis()\n        ax.grid()\n\n        text_x=0.25*(min_x+max_x)\n        text_y=np.mean(y)\n        #title_Str= = ' '.join(map(str, (roots)))\n        title_Str=[(\"R\"+ str(j) +\" = \" + str(roots[j]) ) for j in range(len(roots))]\n        title_Str = str(title_Str)[1:-1]\n\n        ax.set_title(title_Str)\n        #ax.set_title([(\"R\"+ str(j) +\" = \" + str(roots[j]) ) for j in range(len(roots))])\n\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1: Plot of a cubic function. The roots of the cubic are reported in the figure title. The red crosses depict the real parts of the roots.\n\n\n\n\n\nExercises\n\nset \\(a=0\\).\n\nhow many roots are there?\nhow does the local maximum/minimum of the quadratic depend on the sign of the parameter \\(b\\)?\nwhy are there complex roots when the condition \\(c^2-4bd&lt;0\\) is satisfied?\n\nconsider the case where \\(a&gt;0\\).\n\nhow many real roots are there?\ndemonstrate that there is always a trivial root (\\(x=0\\)) in the case \\(d=0\\).\ndemonstrate that in the case \\(a=d=1\\) with \\(b=c=0\\) the cubic takes the reduced form \\[\n  x^3=-1.\n\\] Can you show that the roots are \\(-1\\), \\(\\frac{1+j\\sqrt{3}}{2}\\), \\(\\frac{1-j\\sqrt{3}}{2}\\) where \\(j=\\sqrt{-1}\\).\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, you will develop your knowledge in algebra in modules\n\nMaths 1A\nMaths 1B\nMaths 2A\nMaths 2B\n\nAt Levels 2, 3 and 4 you will learn how to use computer programming to explore and communicate mathematical concepts.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome to the Dundee Mathematics Admissions page.\nYou can find lots of interesting information about mathematics careers here.\nYou can find a link to the Dundee Mathematics student society here."
  },
  {
    "objectID": "posts/TheSIRModel.html",
    "href": "posts/TheSIRModel.html",
    "title": "Modelling the spread of infectious disease",
    "section": "",
    "text": "Infectious disease\nInfectious diseases can have severe health outcomes for individuals who contract them. They can also place an unmanageably large demand on the health service.\nInfectious diseases can be characterised using their basic reproduction number, \\(R_0\\).\n\nInfectious disease basic reproduction numbers Source.\n\n\nDisease\n\\(R_0\\)\n\n\n\n\nMeasles\n12-18\n\n\nChickenpox\n10-12\n\n\nRubella\n6-7\n\n\nCommon cold\n2-3\n\n\nCovid 19 (Omicron)\n9.5\n\n\n\n\n\nMathematical modelling of infectious diseases\nWe can use mathematics to study the dynamics of an infectious disease within a population. In the SIR model a population is split into three compartments:\n\n\\(S(t)\\) - size of susceptible population at time \\(t\\)\n\\(I(t)\\) - size of infected population at time \\(t\\)\n\\(R(t)\\) - size of recovered/post-infected population at time \\(t\\)\n\nThe SIR model has two parameters:\n\n\\(r\\) - infection rate\n\\(a\\) - recovery rate\n\nFrom a public health perspective, one could propose that there is some level of infectiousness, \\(I_{max}\\), which must be avoided. The challenge is to manage the disease such that \\(I(t)&lt;I_{max}\\) for all \\(t\\).\nIn the app in Figure 1 you can investigate how the values of the parameters \\(r\\) and \\(a\\) affect the trajectory of the infectious disease.\n\n\n\n\n\n\nTip\n\n\n\nPlease note that the app in Figure 1 is approximately 20 MB. If it does not display on your device:\n\nwait a few moments (it is downloading the Python code that will run the app)\nrefresh your browser.\n\ntry running on a faster connection/ more powerful device.\n\nIf it still does not load, here is a screenshot.\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"r\",label=\"r\",min=0.00001,max=0.001,value=0.001,step=0.00001),\n    ui.input_slider(id=\"S0\",label=\"Initial susceptible pop. (S(0))\",min=1000.0,max=8000.0,value=4000.1,step=5.0),\n    ui.input_slider(id=\"a\",label=\"a\",min=0.01,max=0.2,value=0.05,step=0.001),            \n    ui.input_slider(id=\"I0\",label=\"Initial infectious pop. (I(0)) \",min=0.0,max=17.0,value=17.0,step=0.5),  \n    ui.input_slider(id=\"T\",label=\"Simulation time\",min=0.0,max=70.0,value=40.0,step=0.5),\n    ui.input_slider(id=\"max_inf\",label=\"Max. infectiousness\",min=0.0,max=10000.0,value=2500.0,step=100.5),             \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        S_0=float(input.S0())\n        a=float(input.a())\n        I_0=float(input.I0())\n        T=float(input.T())\n        max_inf=float(input.max_inf())\n\n        R_0=r*S_0/a\n        \n        # Define rhs of LV ODEs\n        def rhs_sir_model(x,t,r,a):\n          rhs=np.zeros_like(x,dtype=float)\n          S=x[0]\n          I=x[1]\n          R=x[2]\n\n          \n\n          dS_dt=-r*I*S\n          dI_dt=r*I*S-a*I\n          dR_dt=a*I\n\n          rhs[0]=dS_dt\n          rhs[1]=dI_dt\n          rhs[2]=dR_dt\n\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[S_0,I_0,0.0]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_sir_model, init_cond,t,args=(r,a))\n\n        # Plot results\n        S=sol1[:,0]\n        I=sol1[:,1]\n        R=sol1[:,2]\n        \n        ax.plot(t, S, 'b',t,I,'r',t,R,'k')\n        ax.plot(t,max_inf*np.ones_like(t),'--')\n        ax.legend(['S','I','R','Max. allowed infectiousness'],loc='best')\n        ax.set_xlabel('$t$')\n        ax.set_title('R_0 =' + str(R_0))\n\n        #plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1: The sizes of the different populations are plotted against time, \\(t\\). The model parameters are defined using the sliders on the left-hand side. The differential equations are in Equation 1.\n\n\n\n\n\nExercises with the app\n\ncan you determine what value the infectivity parameter, \\(r\\), must go below in order that \\(I(t)&lt;I_{max}\\)?\nsuppose that covid omicron in a susceptible population of \\(S_0=5000\\) has a recovery rate \\(a=0.05\\). Can you estimate the value of the infectivity parameter, \\(r\\), such that \\(R_0=9.5\\)?\nwhich parameters in the app best represent the effect of vaccination of a section of the population?\n\n\n\nThe SIR model equations\nThe SIR model is formulated as a system of ordinary differential equations.\nOn this page we consider a simpler case of a single population.\nThe governing equations in the SIR model are: \\[\n\\begin{aligned}\n\\frac{dS}{dt}&=-rIS, \\\\\n\\frac{dI}{dt}&=rIS-aI, \\\\\n\\frac{dR}{dt}&=aI.\n\\end{aligned}\n\\tag{1}\\]\nThe initial conditions are:\n\\[\n\\begin{aligned}\nS(t=0)&=S_0, \\\\\nI(t=0)&=I_0, \\\\\nR(t=0)&=R_0.\n\\end{aligned}\n\\]\nIn the app in Figure 1 Equation 1 are solved numerically for a given parameter set and the solution is plotted.\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, the mathematical tools needed are developed in modules:\n\nMaths 1A, 1B, 2A and 2B (Core maths modules)\nComputer algebra and dynamical systems\nMathematical Biology I\nMathematical Biology II\n\nAt Levels 2, 3 and 4 you will learn how to use computer programming to explore and communicate mathematical concepts.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/IntersectingLines.html",
    "href": "posts/IntersectingLines.html",
    "title": "Intersecting lines and linear algebra",
    "section": "",
    "text": "Intersecting lines in two dimensional space\nConsider the equations of two straight lines given by \\[\ny=m_1x+c_1\n\\tag{1}\\] and \\[\ny=m_2x+c_2,\n\\tag{2}\\] where \\(m_1\\), \\(m_2\\), \\(c_1\\) and \\(c_2\\) are constants.\nIn Figure 1 you can play with the slopes and intercepts of the lines. Can you spot a condition that holds on the slopes such that the straight lines do not intersect?\nProblems such as the intersection of straight lines can be formulated using linear algebra. In the title of Figure 1 the determinant of a matrix (defined below) is reported for given values of the slopes and intercept. Can you spot a relationship between the value of the matrix determinant and the geometric properties of the lines?\n\n\n\n\n\n\nTip\n\n\n\nPlease note that the app in Figure 1 is approximately 20 MB. If it does not display on your device:\n\nwait a moment (it is downloading the Python code that will run the app)\nrefresh your browser.\n\nIf it still does not load, here is a screenshot.\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"m_1\",label=\"m_1\",min=-5,max=5,value=1.0,step=0.2),\n    ui.input_slider(id=\"c_1\",label=\"c_1\",min=-5.0,max=5.0,value=1.0,step=0.2),\n    ui.input_slider(id=\"m_2\",label=\"m_2\",min=-5.0,max=10.0,value=5.0,step=0.2),            \n    ui.input_slider(id=\"c_2\",label=\"c_2\",min=-5.0,max=10.0,value=5.0,step=0.2),            \n    ),\n    ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        m_1=float(input.m_1())\n        c_1=float(input.c_1())\n        m_2=float((input.m_2()))\n        c_2=float((input.c_2()))\n\n        # Define discretised t domain\n        x = np.linspace(-10, 10, 100)\n        y_1 = m_1*x+c_1\n        y_2 = m_2*x+c_2\n\n        ax.plot(x, y_1, x,y_2)\n        matrix=np.zeros((2,2))\n        matrix[0,0]=m_1\n        matrix[0,1]=1.0\n        matrix[1,0]=m_2\n        matrix[1,1]=1.0\n\n        matrix=np.matrix(matrix)\n\n        determinant=np.linalg.det(matrix)\n        ax.set_title('$\\det{A}$ = ' +str(determinant))\n        ax.set_ylim([-10,10])\n        ax.set_xlim([-10,10])\n        ax.grid(True)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 1: A plot of two lines in 2D plane.\n\n\n\nTo find the intersection of the lines we can rearrange Equation 1 and Equation 2 to obtain \\[\n\\begin{aligned}\nm_1x-y&=-c_1, \\\\\nm_2x-y&=-c_2.\n\\end{aligned}\n\\] The equations can be written in matrix-vector form as \\[\nA \\mathbf{x}=\\mathbf{b},\n\\] where \\[\nA=\\begin{pmatrix} m_1 & -1 \\\\ m_2 & -1\\end{pmatrix},\n\\] and \\[\n\\mathbf{b}=\\begin{pmatrix} -c_1 \\\\ -c_2\\end{pmatrix},\n\\] with \\[\n\\mathbf{x}=\\begin{pmatrix} x \\\\ y\\end{pmatrix}.\n\\]\nThe matrix determinant is defined to be \\[\n\\det{A}=-m_1 +m_2.\n\\]\nHence when the slopes of the lines are equal, the matrix determinant is zero. In this case the lines are parallel and there is either:\n\nno intersection (the lines have distinct intercepts)\nan infinite family of intersections (the lines also have the same intercept).\n\n\n\nIntersecting lines in three dimensional space\nWe will now explore the intersection of two lines in 3D space.\nConsider a line in 3D with direction vector [1,1,1] that passes through the origin. The equation for the line can be written in parametric form as \\[\n\\mathbf{r}_1= \\lambda_1 [1,1,1]^T, \\quad \\lambda_1 \\in \\Re.\n\\]\nConsider a second line defined such that \\[\n\\mathbf{r}_2= \\lambda_2 \\mathbf{t}+ \\mathbf{c}, \\quad \\lambda_2 \\in \\Re.\n\\]\nIn Figure 2 you can play with the direction vector, \\(\\mathbf{t}\\), and the point \\(\\mathbf{c}\\) of the second line.\nIn the app set \\(c=[c_1,c_2,c_3]^T=[0,0,0]^T\\). Can you demonstrate that\n\nwhen \\(t=[t_1,t_2,t_3]^T=[1,-1,0]^T\\) that the lines intersect at the origin?\nwhen \\(t=[t_1,t_2,t_3]^T=[1,1,1]^T\\) the minimum distance between the lines is reported as nan (not a number)?\n\nTo compute the shortest distance between the two lines we can identify the points on each of the lines (parameters \\(\\lambda^*\\) and \\(\\mu^*\\)) that define closest approach. The equations to define \\(\\lambda^*\\) and \\(\\mu^*\\) can be written in matrix-vector form as \\[\nA \\mathbf{x}=\\mathbf{b},\n\\tag{3}\\] where \\[\nA=\\begin{pmatrix} \\mathbf{s}\\cdot\\mathbf{s} & -\\mathbf{t}\\cdot \\mathbf{s} \\\\ \\mathbf{t}\\cdot \\mathbf{s} & -\\mathbf{t}\\cdot \\mathbf{t}\\end{pmatrix},\n\\] and \\[\n\\mathbf{b}=\\begin{pmatrix} \\mathbf{c}\\cdot \\mathbf{s} \\\\ \\mathbf{c}\\cdot \\mathbf{t}\\end{pmatrix},\n\\] with \\[\n\\mathbf{x}=\\begin{pmatrix} \\lambda^* \\\\ \\mu^*\\end{pmatrix}.\n\\] Here \\(\\mathbf{s}\\) represents the direction vector for the first line.\nIf a solution to Equation 3 can be found then it is straightforward to calculate the shortest distance, \\(d\\), between the straight lines.\n\n\n\n\n\n\nTip\n\n\n\nPlease note that the app in Figure 2 is approximately 20 MB. If it does not display on your device:\n\nwait a moment (it is downloading the Python code that will run the app)\nrefresh your browser.\n\nIf it still does not work, here is a screenshot.\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    \n    ui.input_slider(id=\"t_1\",label=\"t_1\",min=-5.0,max=10.0,value=5.0,step=0.2),            \n    ui.input_slider(id=\"t_2\",label=\"t_2\",min=-5.0,max=10.0,value=2.0,step=0.2),     \n    ui.input_slider(id=\"t_3\",label=\"t_3\",min=-5.0,max=10.0,value=1.0,step=0.2),         \n    ui.input_slider(id=\"c_1\",label=\"c_1\",min=-10.0,max=10.0,value=-5.0,step=0.2),  \n    ui.input_slider(id=\"c_2\",label=\"c_2\",min=-10.0,max=10.0,value=5.0,step=0.2),\n    ui.input_slider(id=\"c_3\",label=\"c_3\",min=-10.0,max=10.0,value=5.0,step=0.2),\n    ui.input_slider(id=\"azim_ang\",label=\"Rotate view\",min=-180.0,max=180.0,value=0.0,step=0.1), \n            ),        \n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        ax = plt.figure().add_subplot(projection='3d')\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        s_1=1.0\n        s_2=1.0\n        s_3=1.0\n   \n        t_1=float((input.t_1()))\n        t_2=float((input.t_2()))\n        t_3=float((input.t_3()))\n        c_1=float((input.c_1()))\n        c_2=float((input.c_2()))\n        c_3=float((input.c_3()))\n        azim_ang=float((input.azim_ang()))\n\n        \n\n        # Define discretised t domain\n\n        # L1:r=s*lam+[0,0,0]\n        # L2:r=t*lam+[c_1,c_2,c_3]\n        #  Define  points on lines (need to used scatter as rendering of plot in 3d using matplotlib id a problem)\n        lam=np.linspace(-15.0,15.0,5000)\n        L1_x=lam*[s_1]+[0.0] \n        L1_y=lam*[s_2]+[0.0] \n        L1_z=lam*[s_3]+[0.0]\n        L2_x=lam*[t_1]+c_1 \n        L2_y=lam*[t_2]+c_2 \n        L2_z=lam*[t_3]+c_3\n\n\n        # define direction vectors of lines\n        c_0_vec=np.array([0,0,0])\n        c_2_vec=np.array([c_1,c_2,c_3])\n        s_vec=np.array([s_1,s_2,s_3] )\n        t_vec=np.array([t_1,t_2,t_3])  \n        # Find lambdas that define closest point on each lines\n        #lam_2=np.dot(c_2_vec-c_0_vec,s_vec-t_vec)/(np.dot(t_vec,t_vec)-np.dot(t_vec,s_vec))\n\n        A=np.array([[np.dot(s_vec,s_vec), -np.dot(t_vec,s_vec)],[np.dot(s_vec,t_vec), -np.dot(t_vec,t_vec)]])\n        b=np.array([np.dot(c_2_vec-c_0_vec,s_vec), np.dot(c_2_vec-c_0_vec,t_vec)])\n\n        determinant=np.linalg.det(A)\n\n        #A=np.array([[1,0],[0,1]])\n        #b=np.array([1,1])\n        x=np.dot(np.linalg.inv(A),b)\n\n        lam_1=x[0]\n        lam_2=x[1]    \n\n        # Expression for closest points\n        cp_1=lam_1*s_vec+c_0_vec\n        cp_2=lam_2*t_vec+c_2_vec\n        \n        # min distance\n        min_dist=np.linalg.norm(cp_2-cp_1)\n\n        #fig = plt.figure()\n        ax.scatter(L1_x,L1_y,L1_z)\n        ax.scatter(L2_x,L2_y,L2_z,'k*')\n        ax.plot([cp_1[0], cp_2[0]],[cp_1[1], cp_2[1]],[cp_1[2], cp_2[2]],'k')\n        ax.set_title('d = ' + str(np.round(min_dist,3))+ ', $\\det(A)$ = ' + str(np.round(determinant,3)))\n        my_matrix=np.array2string(A, suppress_small=True, formatter={'float': '{:0.4f}'.format})\n        \n        ax.text(-5,5,5.0, '$A=$'+my_matrix)\n        #ax.plot([L2_1[0],L2_2[0]], [L2_1[1],L2_2[1]],[L2_1[2],L2_2[2]],'r',alpha=0.8,linewidth=6)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n        ax.set_zlabel('$z$')\n\n        ax.set_xlim([-10,10])\n\n        ax.set_ylim([-10,10])\n        ax.set_zlim([-10,10])\n        #ax.view_init(elev=30, azim=45.0, roll=15)\n        ax.view_init(elev=30, azim=azim_ang)\n\n        #determinant=np.linalg.det(matrix)\n\n\n\n\n\n        \n        #from matplotlib import rc\n        #rc('text', usetex=True)\n        #my_matrix = \"$$A=\\\\  \\\\begin{array}{ll} 2 & 3 \\\\ 4 & 5 \\\\end{array} \\\\$$\"\n        #text(my_matrix, (1,1))\n       \n        #ax.text(-10,40, '$A=$'+my_matrix)\n        #ax.annotate('$A$ = ' + matrix, xy = (-10, 40), fontsize = 16, xytext = (-10, 40), arrowprops = dict(facecolor = 'red'),color = 'g')\n        \n\n       # ax.annotate(\n    #\"$\\begin{matrix} a & b  \\\\ d & e  \\end{matrix} $\",\n   # (0.25, 0.25),\n   # textcoords='axes fraction', size=20)\n\n        \n\n        #text_x=0.25*(min_x+max_x)\n        #text_y=np.mean(y)\n        #title_Str= = ' '.join(map(str, (roots)))\n        #title_Str=[(\"R\"+ str(j) +\" = \" + str(roots[j]) ) for j in range(len(roots))]\n        #title_Str = str(title_Str)[1:-1]\n\n        #ax.set_title(title_Str)\n        #ax.set_title([(\"R\"+ str(j) +\" = \" + str(roots[j]) ) for j in range(len(roots))])\n\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2: An app to explore the intersection between two straight lines in 3D. The blue line passes thorugh the origin and has direction vector \\([1,1,1]\\). The red line is controlled by the parameters in the left column. The black line connects the points on each line at which the distance between the lines is minimised. The minimal distance between the lines is reported in the title.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, the parametric equations of lines, spheres and planes are studied in the module Maths 1B.\nConcepts from geometry and linear algebra are generalised in the modules Maths 2A and Maths 2B.\nAt Level 3 in the module Differential Geometry geometrical concepts and tools that are essential for understanding classical and modern physics and engineering are further developed.\nAt Levels 2, 3 and 4 you will learn how to use computer programming to explore and communicate mathematical concepts.\nYou can find out more about these modules here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Maths-admissions",
    "section": "",
    "text": "Roots of quadratic/cubic equations\n\n\n\n\n\n\nPolynomials\n\n\nAlgebra\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrigonometric equations\n\n\n\n\n\n\nGeometry\n\n\nAlgebra\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRecurrence relations and chaos\n\n\n\n\n\n\nRecurrence relations\n\n\nDiscrete maths\n\n\nChaos\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to population dynamics\n\n\n\n\n\n\nPopulation dynamics\n\n\nCalculus\n\n\nDifferential Equations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModelling the spread of infectious disease\n\n\n\n\n\n\nInfectious diseases\n\n\nPopulation dynamics\n\n\nCalculus\n\n\nDifferential Equations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSecond order ODEs\n\n\n\n\n\n\nDifferential Equations\n\n\nCalculus\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntersecting lines and linear algebra\n\n\n\n\n\n\nGeometry\n\n\nAlgebra\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduate employment\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome\n\n\n\n\n\n\nWelcome\n\n\n\n\n\n\n\n\n\nMar 24, 2024\n\n\nPhilip Murray\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "These pages are hosted by Mathematics staff at the University of Dundee. They are intended to support ongoing student recruitment and outreach activities."
  },
  {
    "objectID": "posts/TrigonometricIdentities.html",
    "href": "posts/TrigonometricIdentities.html",
    "title": "Trigonometric equations",
    "section": "",
    "text": "You may have encountered trigonometric expression of the form \\[\na\\sin(x)+b\\cos(x)\n\\tag{1}\\]\nand shown that they can be expressed in the form \\[\nc\\sin(x+d).\n\\tag{2}\\]\nIn @cossinplot, - the individual terms in Equation 1 are plotted using dashed lines for given values of parameters \\(a\\) and \\(b\\).\n- the sum is plotted using a dot-dashed line. - Equation 2 is plotted for given values of \\(c\\) and \\(d\\).\nCan you identify values of the parameters \\(c\\) and \\(d\\) such that \\[\nc\\sin(x+d)=a\\sin(x)+b\\cos(x)\n\\] Are these values unique (i.e. is there more than one solution?)\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-5,max=5,value=1.0,step=0.2),\n    ui.input_slider(id=\"b\",label=\"b\",min=-5.0,max=5.0,value=1.0,step=0.2),\n    ui.input_slider(id=\"c\",label=\"c\",min=-5.0,max=10.0,value=5.0,step=0.02),            \n    ui.input_slider(id=\"d\",label=\"d\",min=-5.0,max=10.0,value=5.0,step=0.02),            \n    ),\n    ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        a =float(input.a())\n        b =float(input.b())\n        c =float((input.c()))\n        d =float((input.d()))\n\n        # Define discretised t domain\n        min_x=-10\n        max_x=10\n        x = np.linspace(min_x, max_x, 1000)\n        y_1 = a*np.sin(x)\n        y_2 = b*np.cos(x)\n        y_3=c*np.sin(x+d)\n\n        z=y_1+y_2\n        ax.plot(x, y_1,'--', x,y_2,'--',linewidth=1)\n        ax.plot(x,z,'-.',x,y_3,linewidth=6)\n        \n\n        min_y=-(np.abs(a)+np.abs(b)+np.abs(c))\n        max_y=-min_y\n        ax.set_ylim([min_y,max_y])\n        ax.set_xlim([min_x,max_x])\n        ax.grid(True)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 1: Sum of cosine and sine functions.\n\n\n\n\n\nDid you know that many functions defined on a domain [0,\\(L\\)] can be approximated by an infinite sum of sine functions of different frequencies, i.e. \\[\nf(x)\\sim A_1\\sin(k_1x)+A_2\\sin(k_2x)+A_3\\sin(k_3x) + A_4\n\\sin(k_4x) + ..\n\\]\nFor a given function \\(f(x)\\) the coefficients \\(A_0\\), \\(A_1\\) etc. can be chosen so that the sum provides an arbitrarily good approximation to the function.\n\nChoose the linear function f(x)=x. Is the approximation good for \\(N=5\\)? What happens to the approximation as you increase \\(N\\)? Notice that the approximation does not converge to the correct value on the boundary \\(x=L\\). This is known as the Gibbs phenomenon. It is not an error but requires a more detailed study of Fourier series to understand!\nConsider the sawtooth function. Compare the accuracy of the series aproximation at the boundary \\(x=L\\) between the functions \\(f(x)=x\\) and the sawtooth function. Note that the approximation now appears to be converging to the value of \\(f\\) on the boundary \\(x=L\\).\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\ntitle_str=['x','sawtooth','x^2','x^2-2x+1','exp(x)','tan(x)',]\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_select(id=\"fun\",label=\"Choose f(x)\",choices=title_str,selected=[\"x\"]),\n    ui.input_slider(id=\"L\",label=\"L\",min=1.0,max=20.0,value=10.0,step=1.0), \n    ui.input_slider(id=\"N\",label=\"N\",min=2,max=500,value=10,step=1),          \n    ),\n    ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        fun =(input.fun())\n        N =int(input.N())\n        L =float(input.L())\n\n        # Define discretised t domain\n   \n        x = np.linspace(0.0, L, 10000)\n        if fun == 'x':\n            f=x\n        elif fun == 'x^2':\n            f=x**2\n        elif fun=='x^2-2x+1':\n            f=x**2-2*x+1\n        elif fun=='exp(x)':\n            f=np.exp(x)\n        elif fun=='tan(x)':\n            f=np.tan(x)\n        elif fun=='sawtooth':\n            f=np.mod(x*5,L)\n\n        sum=0\n        for i in range(N):\n            k_i=i*np.pi/L\n\n            basis_fun=np.sin(k_i*x)\n            A_i= 2.0/L*np.trapz(f*basis_fun,x)\n            term_i=A_i*np.sin(k_i*x)\n            sum+=term_i \n\n        y_2 = sum\n\n        ax.plot(x, f,'--', x,y_2,'--')\n        \n\n        #min_y=-(np.abs(a)+np.abs(b)+np.abs(c))\n        #max_y=-min_y\n\n        min_y=np.max([np.min(f),-200.0])\n        max_y=np.min([np.max(f),200.0])\n\n        ax.set_ylim([min_y,max_y])\n        #ax.set_xlim([min_x,max_x])\n        ax.grid(True)\n        ax.legend(['f(x)','Approximation'])\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 2: Approximating a function as a sum of sinusoids.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, the parametric equations of lines, spheres and planes are studied in the module Maths 1B.\nConcepts from geometry and linear algebra are generalised in the modules Maths 2A and Maths 2B.\nAt Level 3 in the module Differential Geometry geometrical concepts and tools that are essential for understanding classical and modern physics and engineering are further developed.\nAt Levels 2, 3 and 4 you will learn how to use computer programming to explore and communicate mathematical concepts.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/TrigonometricIdentities.html#fourier-series",
    "href": "posts/TrigonometricIdentities.html#fourier-series",
    "title": "Trigonometric equations",
    "section": "",
    "text": "Did you know that many functions defined on a domain [0,\\(L\\)] can be approximated by an infinite sum of sine functions of different frequencies, i.e. \\[\nf(x)\\sim A_1\\sin(k_1x)+A_2\\sin(k_2x)+A_3\\sin(k_3x) + A_4\n\\sin(k_4x) + ..\n\\]\nFor a given function \\(f(x)\\) the coefficients \\(A_0\\), \\(A_1\\) etc. can be chosen so that the sum provides an arbitrarily good approximation to the function.\n\nChoose the linear function f(x)=x. Is the approximation good for \\(N=5\\)? What happens to the approximation as you increase \\(N\\)? Notice that the approximation does not converge to the correct value on the boundary \\(x=L\\). This is known as the Gibbs phenomenon. It is not an error but requires a more detailed study of Fourier series to understand!\nConsider the sawtooth function. Compare the accuracy of the series aproximation at the boundary \\(x=L\\) between the functions \\(f(x)=x\\) and the sawtooth function. Note that the approximation now appears to be converging to the value of \\(f\\) on the boundary \\(x=L\\).\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\ntitle_str=['x','sawtooth','x^2','x^2-2x+1','exp(x)','tan(x)',]\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_select(id=\"fun\",label=\"Choose f(x)\",choices=title_str,selected=[\"x\"]),\n    ui.input_slider(id=\"L\",label=\"L\",min=1.0,max=20.0,value=10.0,step=1.0), \n    ui.input_slider(id=\"N\",label=\"N\",min=2,max=500,value=10,step=1),          \n    ),\n    ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        fun =(input.fun())\n        N =int(input.N())\n        L =float(input.L())\n\n        # Define discretised t domain\n   \n        x = np.linspace(0.0, L, 10000)\n        if fun == 'x':\n            f=x\n        elif fun == 'x^2':\n            f=x**2\n        elif fun=='x^2-2x+1':\n            f=x**2-2*x+1\n        elif fun=='exp(x)':\n            f=np.exp(x)\n        elif fun=='tan(x)':\n            f=np.tan(x)\n        elif fun=='sawtooth':\n            f=np.mod(x*5,L)\n\n        sum=0\n        for i in range(N):\n            k_i=i*np.pi/L\n\n            basis_fun=np.sin(k_i*x)\n            A_i= 2.0/L*np.trapz(f*basis_fun,x)\n            term_i=A_i*np.sin(k_i*x)\n            sum+=term_i \n\n        y_2 = sum\n\n        ax.plot(x, f,'--', x,y_2,'--')\n        \n\n        #min_y=-(np.abs(a)+np.abs(b)+np.abs(c))\n        #max_y=-min_y\n\n        min_y=np.max([np.min(f),-200.0])\n        max_y=np.min([np.max(f),200.0])\n\n        ax.set_ylim([min_y,max_y])\n        #ax.set_xlim([min_x,max_x])\n        ax.grid(True)\n        ax.legend(['f(x)','Approximation'])\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 2: Approximating a function as a sum of sinusoids.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, the parametric equations of lines, spheres and planes are studied in the module Maths 1B.\nConcepts from geometry and linear algebra are generalised in the modules Maths 2A and Maths 2B.\nAt Level 3 in the module Differential Geometry geometrical concepts and tools that are essential for understanding classical and modern physics and engineering are further developed.\nAt Levels 2, 3 and 4 you will learn how to use computer programming to explore and communicate mathematical concepts.\nYou can find out more about these modules here."
  }
]