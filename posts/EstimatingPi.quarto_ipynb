{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Estimating pi\"\n",
        "format: html \n",
        "image: 'EstimatingPi.png'\n",
        "categories: [integration, geometry]\n",
        "filters:\n",
        "  - shinylive\n",
        "---\n",
        "\n",
        "# Estimating $\\pi$\n",
        "\n",
        "## A circle\n",
        "\n",
        "Consider a circle of radius $R$ centred at the origin.\n",
        "\n",
        ":::: {#fig-hmm fig-align=\"center\"}"
      ],
      "id": "2e302302"
    },
    {
      "cell_type": "code",
      "metadata": {
        "fig-width": 1
      },
      "source": [
        "#| echo: false\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "R=1.0\n",
        "theta=np.linspace(0,2*np.pi,1000)\n",
        "fig,ax=plt.subplots()\n",
        "ax.plot(R*np.cos(theta),R*np.sin(theta),'r')\n",
        "ax.set_xlabel('$x$')\n",
        "ax.set_ylabel('$y$')\n",
        "ax.set_aspect('equal')\n",
        "ax.axis('square')\n",
        "plt.show()"
      ],
      "id": "5e5d09b0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::::\n",
        "\n",
        "\n",
        "The equation of the circle is given by\n",
        "$$\n",
        "x^2+y^2=R^2.\n",
        "$$ {#eq-circle}\n",
        "\n",
        "The area of the circle is given by the familiar formula\n",
        "\n",
        "$$\n",
        "\\pi R^2.\n",
        "$$\n",
        "\n",
        "The smallest square within which the circle can be inscribed will have side length $2R$.\n",
        "\n",
        "::: {#fig-squarecircle fig-align=\"center\"}"
      ],
      "id": "a7feace3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "R=1.0\n",
        "theta=np.linspace(0,2*np.pi,1000)\n",
        "fig,ax=plt.subplots()\n",
        "ax.plot(R*np.cos(theta),R*np.sin(theta),'r')\n",
        "ax.plot([-R,-R],[-R,R],'b')\n",
        "ax.plot([-R,R],[R,R],'b')\n",
        "ax.plot([R,R],[R,-R],'b')\n",
        "ax.plot([R,-R],[-R,-R],'b')\n",
        "\n",
        "ax.set_xlabel('$x$')\n",
        "ax.set_ylabel('$y$')\n",
        "ax.axis('square')\n",
        "\n",
        "plt.show()"
      ],
      "id": "f7985462",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "\n",
        "Hence the ratio of the area of the circle to that of the square is\n",
        "\n",
        "$$\n",
        "\\frac{\\pi R^2}{4 R^2}=\\frac{\\pi}{4}.\n",
        "$$\n",
        "\n",
        "\n",
        "## Estimating $\\pi$\n",
        "\n",
        "We can use the above result to estimate $\\pi$ by randomly sampling points that sit inside the square. The probability of a randomly sampled point falling inside the inscribed circle in @fig-squarecircle is equal to the ratio of the areas, i.e.\n",
        "$$\n",
        "\\frac{\\pi}{4}.\n",
        "$$ \n",
        "\n",
        "\n",
        "We can use a random number generator to uniformly sample $N_s$ points within the square, i.e. \n",
        "$$\n",
        "x_i \\in U_{0,2R}, \\quad y_i \\in U_{0,2R}, \\quad i=1,..,N.\n",
        "$$\n",
        "Here $U$ represents a uniform distribution and $N$ is the number of sampled points. \n",
        "\n",
        "We can then count the number of randomly sampled points, $N_c$, that sit inside the circle, i.e. with coordinates that satisfy the inequality\n",
        "$$\n",
        "x_i^2+y_i^2< R^2.\n",
        "$$\n",
        "\n",
        "We can then estimate $\\pi$ using the formula\n",
        "$$\n",
        "\\hat{\\pi}\\sim 4\\frac{N_c}{N_s}.\n",
        "$$\n",
        "\n",
        "In @fig-apppi  we use an app to explore the approximation of $\\pi$. Here you can explore how the estimate for $\\pi$ depends on the number of samples and consider circles of different radii.\n",
        "\n",
        "In the top plot the distribution of sampled points is plotted for a given realisation with the parameter values as you have chosen. In the bottom plot the estimate of $\\pi$ is averaged over 100 realisations and plotted against the number of sampled points, $N$.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "::: {#fig-apppi fig-align=\"center\"}\n",
        "\n",
        "```{shinylive-python}\n",
        "#| standalone: true\n",
        "#| components: [viewer]\n",
        "#| viewerHeight: 500\n",
        "\n",
        "from shiny import App, Inputs, Outputs, Session, render, ui\n",
        "from shiny import reactive\n",
        "\n",
        "import numpy as np\n",
        "from pathlib import Path\n",
        "import matplotlib.pyplot as plt\n",
        "from scipy.integrate import odeint\n",
        "\n",
        "app_ui = ui.page_fluid(\n",
        "    ui.layout_sidebar(\n",
        "        ui.sidebar(\n",
        "    ui.input_slider(id=\"N\",label=\"Num points per experiment\",min=10,max=3000,value=10,step=1),\n",
        "    ui.input_slider(id=\"R\",label=\"Radius\",min=2.0,max=15.0,value=10.0,step=1),\n",
        "    ui.input_slider(id=\"L\",label=\"Square side length\",min=15.0,max=30.0,value=20.0,step=1),  \n",
        "    ui.input_slider(id=\"N_Exp\",label=\"Num experiments\",min=1,max=300,value=1,step=1),           \n",
        "     \n",
        "              \n",
        "          \n",
        "            ),\n",
        "\n",
        "        ui.output_plot(\"plot\"),\n",
        "    ),\n",
        ")\n",
        "\n",
        "def server(input, output, session):\n",
        "    \n",
        "\n",
        "    def estimate_pi(N,R,L): \n",
        "        x = np.random.uniform(0,L,N)\n",
        "        y = np.random.uniform(0,L,N)\n",
        "\n",
        "        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n",
        "        num_points_inside_circle=len(radius[radius<=R])\n",
        "\n",
        "        pi_est=(L/R)**2*(num_points_inside_circle/N)\n",
        "\n",
        "        return x,y,pi_est\n",
        "\n",
        "    @render.plot\n",
        "    def plot():\n",
        "        fig, ax = plt.subplots(2,1)\n",
        "        #ax.set_ylim([-2, 2])\n",
        "        # Filter fata\n",
        "        \n",
        "        \n",
        "        N=int(input.N())\n",
        "        R=float(input.R())\n",
        "        L=float(input.L())\n",
        "        n_samples=int(input.N_Exp())\n",
        "        \n",
        "    \n",
        "        x,y,pi_est=estimate_pi(N,R,L)\n",
        "\n",
        "        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n",
        "        \n",
        "        ax[0].plot(x[radius<R],y[radius<R],'b.')\n",
        "        ax[0].plot(x[radius>R],y[radius>R],'k.')\n",
        "\n",
        "        ax[0].set_xlabel('$x$')\n",
        "        ax[0].set_ylabel('$y$')\n",
        "\n",
        "        theta=np.linspace(0,2*np.pi,1000)\n",
        "        ax[0].plot(R*np.cos(theta)+L/2.0,R*np.sin(theta)+L/2.0,'r')\n",
        "        ax[0].set_title('$\\hat{\\pi}$='+str(pi_est))\n",
        "\n",
        "        \n",
        "        N_vec=np.linspace(10,3000,80,dtype=int)\n",
        "        pi_est_vec=np.zeros_like(N_vec,dtype=float)\n",
        "        for i in range(len(N_vec)):\n",
        "            pi_est_i=np.zeros((n_samples,1),dtype=float)\n",
        "            for j in range(n_samples):\n",
        "                x,y,pi_est=estimate_pi(N_vec[i],R,L)\n",
        "                pi_est_i[j]=pi_est\n",
        "            pi_est_vec[i]=np.mean(pi_est_i)\n",
        "\n",
        "        ax[1].plot(N_vec,pi_est_vec,'.',N_vec,np.pi*np.ones_like(N_vec))\n",
        "        ax[1].set_xlabel('$N$')\n",
        "        ax[1].set_ylabel('$\\hat{\\pi}$')\n",
        "        #plt.Circle([0.0, 0.0 ],R,fill = False,axis=ax)\n",
        "        #ax.Circle((0.0, 0.0 ),R,fill = False )\n",
        "\n",
        "\n",
        "        fig.tight_layout()\n",
        "        plt.grid()\n",
        "        plt.show()\n",
        "    \n",
        "app = App(app_ui, server)\n",
        "```\n",
        ":::"
      ],
      "id": "4ad82cb0"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/pmurray/anaconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}