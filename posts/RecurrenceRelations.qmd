---
title: "Recurrence relations and chaos"
format: html 
image: 'logisticmapsolscreenshot.png'
categories: [Recurrence relations, Discrete maths, Chaos]
filters:
  - shinylive
---

# Recurrence relations

## A linear recurrence relation

You might have previously encountered a recurrence relation of the form

$$
x_{n+1}=ax_n+b
$$ {#eq-linrecurrence}
where $a$ and $b$ are constants.

Given numerical values for $a$ and $b$ and an initial condition, $x_0$, a sequence can be computed that is a solution to @eq-linrecurrence. This type of task is laborious and well suited to a computer (see @fig-popmodel).

Explore how the computed solution depend on model parameters as follows:

* set $b=0$ 
    by varying the parameter $a$ identify solutions that:
    * tend to zero monotonically
    * oscillate about 0
    * blow up
* set b>0
    * show that the solution converges to a non-zero value in the case where $0<a<1$.
    * show that the solution is oscillatory for $-1<a<0$.






::: {#fig-popmodel}

```{shinylive-python}
#| standalone: true
#| components: [viewer]
#| viewerHeight: 500

from shiny import App, Inputs, Outputs, Session, render, ui
from shiny import reactive

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.integrate import odeint

app_ui = ui.page_fluid(
    ui.layout_sidebar(
        ui.panel_sidebar(
    ui.input_slider(id="a",label="a",min=-1.0,max=3,value=0.1,step=0.001),
    ui.input_slider(id="b",label="b",min=0.0,max=15.0,value=10.0,step=0.01),             
     
    ui.input_slider(id="x0",label="x_0",min=0.0,max=20.0,value=5.0,step=1.0),
    ui.input_slider(id="T",label="Number of iterations",min=0.0,max=60.0,value=20.0,step=1.0),
              
          
            ),

        ui.panel_main(ui.output_plot("plot"),),
    ),
)

def server(input, output, session):
    
    @render.plot
    def plot():
        fig, ax = plt.subplots()
        #ax.set_ylim([-2, 2])
        # Filter fata
        
        
        a=float(input.a())
        b=float(input.b())
        x0=float(input.x0())
        T=int(input.T())
       
        # Define rhs of LV ODEs
        def rhs_pop_model(y,t,a,b):
          

          rhs=a*y+b

          return rhs
        def DiscreteSol(rhs_pop_model,y_0,t,a,b):
            y=np.zeros_like(t,dtype=float)
            y[0]=y_0
            for i in t:
                if i>0:
                    y[i]=rhs_pop_model(y[i-1],t[i],a,b)
            return y


        # Define discretised t domain
        t = np.arange(0, T, 1)
        # define initial conditions
        init_cond=x0
        
        # Compute numerical solution of ODEs
        sol1 = DiscreteSol(rhs_pop_model,init_cond,t,a,b)

        # Plot results
        y=sol1
        
        ax.plot(t,y)
        ax.set_xlabel('$n$')
        ax.set_ylabel('$x_n$')

        plt.grid()
        plt.show()
    
app = App(app_ui, server)
```
:::


## The logisitic map

The recurrence relation explored in @fig-popmodel is linear (the right-hand-side is a linear function of $x_n$).  When the model is generalised much richer dynamical behaviours can be observed. One famous example is the logistic map, where the governing equation can be written as
$$
x_{n+1}=rx_n(1-x_n).
$$ {#eq-logisticmap}

Note that the right-hand side is now a quadratic function of $x_n$. 

You can explore the solutions to  @eq-logisticmap using @fig-logisticmodel.

* show that when $0<r<1$ the solution converges monotonically to 0.0.
* show that when $0<r<2$ the solution converges monotonically to a non-zero value.
* show that when $2<r<3$ the solution is oscillatory and converges to a non-zero value.
* show that when $r=3.2$ the solution is periodic and repeats every second step
* show that when $r=3.47$ the solution is periodic and repeats every fourth step
* show that when $r=3.7$ that the solution is neither periodic nor reaches a steady value.


The logistic map provides one of the simplest mathematical formulations of a phenomenon known as chaos. Whilst a precise definition of chaos involves some technical concepts, chaotic systems are broadly characterised by:

* having non-periodic, non-steady solution
* sensitivity to initial conditions
* apprearing to be unpredictable even through they are deterministic.


::: {#fig-logisticmodel}

```{shinylive-python}
#| standalone: true
#| components: [viewer]
#| viewerHeight: 500

from shiny import App, Inputs, Outputs, Session, render, ui
from shiny import reactive

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.integrate import odeint

app_ui = ui.page_fluid(
    ui.layout_sidebar(
        ui.panel_sidebar(
    ui.input_slider(id="r",label="r",min=0.0,max=5.0,value=0.1,step=0.01),             
    ui.input_slider(id="x0",label="x_0",min=0.0,max=1.0,value=0.5,step=0.01),
    ui.input_slider(id="T",label="Number of iterations",min=0.0,max=60.0,value=20.0,step=1.0),
              
          
            ),

        ui.panel_main(ui.output_plot("plot"),),
    ),
)

def server(input, output, session):
    
    @render.plot
    def plot():
        fig, ax = plt.subplots()
        #ax.set_ylim([-2, 2])
        # Filter fata
        
        
        r=float(input.r())
        x0=float(input.x0())
        T=int(input.T())
       
        # Define rhs of logistic map 
        def logistic_map(y,t,r):
          rhs=r*y*(1-y)
          return rhs
        
        def DiscreteSol(rhs_pop_model,y_0,t,r):
            y=np.zeros_like(t,dtype=float)
            y[0]=y_0
            for i in t:
                if i>0:

                    y[i]=rhs_pop_model(y[i-1],t[i],r)
            return y

        # Define discretised t domain
        t = np.arange(0, T, 1)
        # define initial conditions
        init_cond=x0
        
        # Compute numerical solution of ODEs
        sol1 = DiscreteSol(logistic_map,init_cond,t,r)

        # Plot results
        y=sol1
        
        ax.plot(t,y)
        ax.set_xlabel('$n$')
        ax.set_ylabel('$x_n$')

        plt.grid()
        plt.show()
    
app = App(app_ui, server)
```
:::




:::{.callout-note}

At Dundee, core concepts from calculus (e.g. differential equations) and algebra that are needed to study dynamical systems are introduced in the modules  *Maths 1A* and *Maths 1B* and developed further in the modules  *Maths 2A* and *Maths 2B*.


At Level 2  in the module *Discrete Maths*  you would be introduced to discrete dynamical systems (e.g. recurrence relations, Markov chains). In the modules *Introduction to Programming* and *Computer Algebra and Dynamical systems* you would be introduced to techniques that enable you to numerically analyse difference equations. 

At Level 3 in the module  *Mathematical Biology*  you would consider discrete dynamical systems model applied to Biological systems.

At Level 4 we offer a number of honours projects that investigate chaotic systems (e.g. the Lorenz equations, the double pendulum)

You can find out more about these modules [here](https://www.dundee.ac.uk/undergraduate/mathematics-bsc/teaching-and-assessment).

:::





