<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Cryptography – University of Dundee Mathematics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<meta name="shinylive:serviceworker_dir" content="..">
<script src="../site_libs/quarto-contrib/shinylive-0.9.3/shinylive/load-shinylive-sw.js" type="module"></script>
<script src="../site_libs/quarto-contrib/shinylive-0.9.3/shinylive/run-python-blocks.js" type="module"></script>
<link href="../site_libs/quarto-contrib/shinylive-0.9.3/shinylive/shinylive.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/shinylive-quarto-css/shinylive-quarto.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-MQD60ZZ43S"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-MQD60ZZ43S', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../UoD_logo_RGB.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">University of Dundee Mathematics</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Cryptography</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">cryptography</div>
                <div class="quarto-category">number theory</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="cryptography" class="level2">
<h2 class="anchored" data-anchor-id="cryptography">Cryptography</h2>
<p>Cryptography is the practice and study of techniques for securing communication and information against unauthorized access, modification, or forgery. It is used to protect sensitive data by transforming it into a format that is difficult for unintended recipients to understand or manipulate. This transformation often relies on mathematical algorithms and cryptographic keys.</p>
</section>
<section id="decrypting-an-encrypted-message" class="level2">
<h2 class="anchored" data-anchor-id="decrypting-an-encrypted-message">Decrypting an encrypted message</h2>
<p>Suppose you happen upon the encrypted message:</p>
<p>92ff0e9b25c797469785ce73ba4ded76d7d4ba6154c84926aa52038a3cf06da800d36b68cb</p>
<p>If you paste the message into <a href="#fig-decrypt" class="quarto-xref">Figure&nbsp;1</a>, you can decrypt it if you can guess the <em>shared secret</em> used to encrypt the original message (Hint: use the slider to try different values of the shared secret … it is smaller than 100 for this example).</p>
<p>Note it may take a few moments for the code needed to run the app below to get installed via your web browser. It is advised to do this on a computer rather than a phone as it requires an approx. 20 MB download.</p>
<div id="fig-decrypt" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-decrypt-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="fig-decrypt" class="shinylive-python" data-engine="python"><code>#| standalone: true
#| components: [viewer]
#| viewerHeight: 200

from shiny import App, Inputs, Outputs, Session, render, ui
from shiny import reactive

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.integrate import odeint
import sympy as sp
import pandas as pd
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import dh
import os
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import base64


app_ui = ui.page_fluid(
    ui.layout_sidebar(
        ui.sidebar(
    ui.input_slider(id="shared_secret",label="Shared secret",min=10,max=3000,value=31,step=1),
    ui.input_text(id='text',label="Message to decrypt",value="8968d20bbc5b"),
            ),

        ui.output_table("result"),
    ),
)

def server(input, output, session):
    


    
    def decrypt_message(key, iv, ciphertext):
        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        return plaintext



    @render.table
    def result():
        # list of strings
        shared_secret=int(input.shared_secret())
        encrypted_text=str(input.text())

        encrypted_text=bytes.fromhex(encrypted_text)




        #text=text.encode(encoding="utf-8")
        #encrypted_text = encrypted_text.encode('ISO-8859-1')

        shared_secret_bytes=shared_secret.to_bytes(16,'big')
        derived_key = HKDF(
            algorithm=hashes.SHA256(),
            length=32,
            salt=None,
            info=b"diffie-hellman-key-exchange",
        ).derive(shared_secret_bytes)
        
        
        iv=5
        iv=iv.to_bytes(16, 'big')
                
        decrypted_message = decrypt_message(derived_key, iv, encrypted_text)

       
        data_dict = {
            'Decrypted Message':[decrypted_message]
            }

        # Create a DataFrame
        df = pd.DataFrame(data_dict)
        # Calling DataFrame constructor on list
        return df

app = App(app_ui, server)</code></pre>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-decrypt-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1
</figcaption>
</figure>
</div>
<p>The encryption in <a href="#fig-decrypt" class="quarto-xref">Figure&nbsp;1</a> is happening via algorithms (hash functions) that take an input and produce a fixed-size string of characters, which is unique to the input data. In <a href="#fig-encrypt" class="quarto-xref">Figure&nbsp;2</a> you can encrypt a message using a hash-function. The <em>shared secret</em> is the number that is required to encrypt the message. You can decrypt your own message using <a href="#fig-decrypt" class="quarto-xref">Figure&nbsp;1</a>.</p>
<div id="fig-encrypt" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-encrypt-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="fig-encrypt" class="shinylive-python" data-engine="python"><code>#| standalone: true
#| components: [viewer]
#| viewerHeight: 200

from shiny import App, Inputs, Outputs, Session, render, ui
from shiny import reactive

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.integrate import odeint
import sympy as sp
import pandas as pd
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import dh
import os
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes


app_ui = ui.page_fluid(
    ui.layout_sidebar(
        ui.sidebar(
    ui.input_slider(id="shared_secret",label="shared secret",min=10,max=3000,value=23,step=1),
    ui.input_text(id='text',label="Message to encrypt",value="Yarrrr"),
         
     
            ),

        ui.output_table("result"),
    ),
)

def server(input, output, session):
    

    def encrypt_message(key, plaintext):
        iv=5
        iv=iv.to_bytes(16, 'big')
        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(plaintext) + encryptor.finalize()
        return iv,ciphertext
    



    @render.table
    def result():
        # list of strings
        shared_secret=int(input.shared_secret())
        text=input.text()
        # Step 1: Generate Diffie-Hellman Parameters and Keys
       

        #shared_secret=int(np.mod(g**(a*b),p))
        shared_secret_bytes=shared_secret.to_bytes(16,'big')
        #shared_secret=g**(a*b)
        derived_key = HKDF(
            algorithm=hashes.SHA256(),
            length=32,
            salt=None,
            info=b"diffie-hellman-key-exchange",
        ).derive(shared_secret_bytes)
        
        # Step 4: Encrypt a Message Using AES
        message = text.encode(encoding="utf-8")
        iv, ciphertext = encrypt_message(derived_key, message)

         # Decrypt the message
        data_dict = {
            'Encrypted Message':[ciphertext.hex()],
            'Encrypted Message':[ciphertext.hex()],
            }

        # Create a DataFrame
        df = pd.DataFrame(data_dict)
        # Calling DataFrame constructor on list
        return df

   
app = App(app_ui, server)</code></pre>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-encrypt-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2
</figcaption>
</figure>
</div>
<p>The problem with the above encryption is that two parties must somehow safely share a secret in order that they can encrypt/decrypt messages. This is where the interesting mathematics happens!</p>
<section id="generating-a-shared-secret" class="level3">
<h3 class="anchored" data-anchor-id="generating-a-shared-secret">Generating a shared secret</h3>
<p>The Diffie-Hellman algorithm is used for two parties (Alice and Bob) to <em>safely</em> share a secret.</p>
<p>Some publicly shared information is firstly agreed between the two parties: a prime number, <span class="math inline">\(p\)</span>, and a generator <span class="math inline">\(g&lt;p\)</span>. We need to use Number Theory and Group Theory to identify <em>safe</em> values for <span class="math inline">\(g\)</span> and <span class="math inline">\(p\)</span>. But not today!</p>
<p>Alice and Bob then both generate their own private keys: <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>. These numbers are not publicly shared.</p>
<p>Alice uses her private key and the shared information to compute her public key</p>
<p><span class="math display">\[
X=g^x \pmod p.
\]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Modular arithmetic
</div>
</div>
<div class="callout-body-container callout-body">
<p>The Diffie Helmann algorithm uses modular arithmetic. Writing <span class="math display">\[
X=g^x \pmod p,
\]</span> the number <span class="math inline">\(X\)</span> is the remainder when the number <span class="math inline">\(g^x\)</span> is divided by <span class="math inline">\(p\)</span>. For example, if <span class="math inline">\(g=2\)</span>, <span class="math inline">\(x=3\)</span> and <span class="math inline">\(p=5\)</span> then</p>
<p><span class="math display">\[
g^x=2^3=8.
\]</span></p>
<p>The remainder when divided by 5 is 3. Hence for this example <span class="math display">\[
g^x \pmod p= 2^3 \pmod 5 = 3.
\]</span></p>
</div>
</div>
<p>Similarly, Bob uses his private key to compute <span class="math display">\[
Y=g^y \pmod p.
\]</span></p>
<p>Alice and Bob now exchange their public keys <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>. Alice uses Bob’s public key to compute</p>
<p><span class="math display">\[
Y^x \pmod p
\]</span></p>
<p>Similarly, Bob uses Alice’s public key to compute <span class="math display">\[
X^y \pmod p.
\]</span></p>
<p>Because of the commutativity of multiplication of exponents <span class="math display">\[
s=Y^x\pmod p = g^{xy}\pmod p = X^y\pmod p
\]</span></p>
<p>Hence Alice and Bob both have a shared secret. They can use this shared secret to encrypt/decrypt messages using hash functions.</p>
<p>You can explore the generation of a shared secret in <a href="#fig-sharedsecret" class="quarto-xref">Figure&nbsp;3</a>.</p>
<div id="fig-sharedsecret" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-sharedsecret-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="fig-sharedsecret" class="shinylive-python" data-engine="python"><code>#| standalone: true
#| components: [viewer]
#| viewerHeight: 450

from shiny import App, Inputs, Outputs, Session, render, ui
from shiny import reactive

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.integrate import odeint
import sympy as sp
import pandas as pd
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import dh
import os
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes


app_ui = ui.page_fluid(
    ui.layout_sidebar(
        ui.sidebar(
    ui.input_slider(id="p",label="p",min=10,max=3000,value=23,step=1),
    ui.input_slider(id="g",label="g (generator)",min=0,max=15.0,value=5,step=1),
    ui.input_slider(id="a",label="Private key Bob",min=1,max=10,value=2,step=1),
    ui.input_slider(id="b",label="Private key Alice",min=1,max=10,value=3,step=1), 
    
         
     
            ),

        ui.output_table("result"),
    ),
)

def server(input, output, session):
        



    @render.table
    def result():
        # list of strings
        p=int(input.p())
        g=int(input.g())
        a=int(input.a())
        b=int(input.b())
        # Step 1: Generate Diffie-Hellman Parameters and 


        alice_public_key=int(np.mod(g**(a),p))
        bob_public_key=int(np.mod(g**(b),p))

        shared_secret=int(np.mod(g**(a*b),p))
        
     
        data_dict = {
            'p': [p],
            'g': [g],
            'Alice public key': [alice_public_key],
            'Bob public key': [bob_public_key],
            'Shared secret': [shared_secret],
            }

        # Create a DataFrame
        df = pd.DataFrame(data_dict)
        # Calling DataFrame constructor on list
        return df

         


app = App(app_ui, server)</code></pre>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-sharedsecret-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3
</figcaption>
</figure>
</div>
</section>
<section id="the-discrete-logarithm-problem" class="level3">
<h3 class="anchored" data-anchor-id="the-discrete-logarithm-problem">The discrete logarithm problem</h3>
<p>For security of the Diffie Hellman algorithm it is required that the shared secret cannot be easily deduced from the publicly available information. If, for example, an outsider were to identify Alice’s private key, <span class="math inline">\(x\)</span>, then they could easily compute the shared secret</p>
<p><span class="math display">\[
Y^x \pmod p
\]</span> and therefore decrypt the message.</p>
<p>Consider the publicly available information: <span class="math inline">\(p\)</span>, <span class="math inline">\(g\)</span> and the public key <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>. To obtain the shared secret a hacker could try to solve the following problem</p>
<p><span class="math display">\[
g^x \pmod p = X,
\]</span></p>
<p>where <span class="math inline">\(x\)</span> is Alice’s private key. This is known as the discrete logarithm problem . In <a href="#fig-discretlog" class="quarto-xref">Figure&nbsp;4</a> you can explore how an observer could identify Alice’s private key, <span class="math inline">\(x\)</span> (where the marker sits on the horizontal line). The key point from the figure is that it is difficult to guess what the value of the variable on the <span class="math inline">\(x\)</span> axis will give rise to a <em>desired</em> value on the <span class="math inline">\(y\)</span> axis.</p>
<p>It can be proven (mathematically) that when <span class="math inline">\(p\)</span> and <span class="math inline">\(g\)</span> are chosen appropriately that there are not efficient methods to solve this problem. Hence the Diffie-Hellman is secure given appropriate choices for <span class="math inline">\(p\)</span> and <span class="math inline">\(g\)</span>.</p>
<div id="fig-discretlog" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-discretlog-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="fig-discretlog" class="shinylive-python" data-engine="python" data-fig-align="center"><code>#| standalone: true
#| components: [viewer]
#| viewerHeight: 500

from shiny import App, Inputs, Outputs, Session, render, ui
from shiny import reactive

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.integrate import odeint

app_ui = ui.page_fluid(
    ui.layout_sidebar(
        ui.sidebar(
    ui.input_slider(id="p",label="p (prime number)",min=5,max=300,value=23,step=1),
    ui.input_slider(id="g",label="g (generator)",min=0,max=30,value=5,step=1),
    ui.input_slider(id="s",label="Public key",min=1,max=100,value=5,step=1),      
            ),

        
        ui.output_plot("plot"),
    ),
)

def server(input, output, session):
    

    

    @render.plot
    def plot():
        fig, ax = plt.subplots()
        #ax.set_ylim([-2, 2])
        # Filter fata
        
        
        p=int(input.p())
        g=int(input.g())
        s=int(input.s())
        
    
    
        ax.set_xlabel('$x$')
        ax.set_ylabel('$f$')

       
        a_vec=np.linspace(0,p-1,p,dtype=int)
        
        function_mod=(g**a_vec)%p
        ax.plot(a_vec,function_mod,'x',a_vec,np.ones_like(a_vec)*s,'r--')

        fig.tight_layout()
        plt.grid()
        plt.show()
    
app = App(app_ui, server)</code></pre>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-discretlog-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4
</figcaption>
</figure>
</div>
</section>
</section>
<section id="encryption-with-diffie-helmann" class="level2">
<h2 class="anchored" data-anchor-id="encryption-with-diffie-helmann">Encryption with Diffie-Helmann</h2>
<p>In <a href="#fig-dhelmanencryption" class="quarto-xref">Figure&nbsp;5</a> you can explore the encryption of a message using the Diffie-Helmann algorithm.</p>
<div id="fig-dhelmanencryption" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-dhelmanencryption-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="fig-dhelmanencryption" class="shinylive-python" data-engine="python"><code>#| standalone: true
#| components: [viewer]
#| viewerHeight: 500

from shiny import App, Inputs, Outputs, Session, render, ui
from shiny import reactive

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.integrate import odeint
import sympy as sp
import pandas as pd
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import dh
import os
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes


app_ui = ui.page_fluid(
    ui.layout_sidebar(
        ui.sidebar(
    ui.input_slider(id="p",label="p (prime number)",min=10,max=3000,value=23,step=1),
    ui.input_slider(id="g",label="g (generator)",min=0,max=15.0,value=5,step=1),
    ui.input_slider(id="a",label="Private key Bob",min=1,max=10,value=2,step=1),
    ui.input_slider(id="b",label="Private key Alice",min=1,max=10,value=3,step=1), 
    ui.input_text(id='text',label="Message to encrypt",value="sin(x)"),
         
     
            ),

        ui.output_table("result"),
    ),
)

def server(input, output, session):
    

    def encrypt_message(key, plaintext):
        iv=5
        iv=iv.to_bytes(16, 'big')
        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(plaintext) + encryptor.finalize()
        return iv,ciphertext
    
    def decrypt_message(key, iv, ciphertext):
        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        return plaintext



    @render.table
    def result():
        # list of strings
        p=int(input.p())
        g=int(input.g())
        a=int(input.a())
        text=input.text()
        b=int(input.b())
        # Step 1: Generate Diffie-Hellman Parameters and Keys
        parameters = dh.generate_parameters(generator=2, key_size=512)

        # Generate private/public key pairs for two parties
        private_key_a = parameters.generate_private_key()
        private_key_b = parameters.generate_private_key()

        # Generate public keys
        public_key_a = private_key_a.public_key()
        public_key_b = private_key_b.public_key()

        # Step 2: Derive Shared Secret
        shared_key_a = private_key_a.exchange(public_key_b)
        shared_key_b = private_key_b.exchange(public_key_a)

        # Validate shared keys are identical
        assert shared_key_a == shared_key_b, "Shared keys are not equal!"

        shared_secret=int(np.mod(g**(a*b),p))
        shared_secret_bytes=shared_secret.to_bytes(16,'big')
        #shared_secret=g**(a*b)
        derived_key = HKDF(
            algorithm=hashes.SHA256(),
            length=32,
            salt=None,
            info=b"diffie-hellman-key-exchange",
        ).derive(shared_secret_bytes)
        
        # Step 4: Encrypt a Message Using AES
        message = text.encode(encoding="utf-8")
        iv, ciphertext = encrypt_message(derived_key, message)
        print("Ciphertext:", ciphertext.hex())

        # Decrypt the message
        decrypted_message = decrypt_message(derived_key, iv, ciphertext)
        data_dict = {
            'p': [p],
            'g': [g],
            'Message': [text],
            'Shared secret Alice': [shared_secret],
            'Encrypted Message':[ciphertext.hex()],
            }

        # Create a DataFrame
        df = pd.DataFrame(data_dict)
        # Calling DataFrame constructor on list
        return df

   
app = App(app_ui, server)</code></pre>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-dhelmanencryption-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5
</figcaption>
</figure>
</div>
</section>
<section id="decrypting-a-message" class="level2">
<h2 class="anchored" data-anchor-id="decrypting-a-message">Decrypting a message</h2>
<p>Let’s consider another description task, now using the full Diffie-Helmann.</p>
<p>Suppose that we want to decrypt the message</p>
<p>f04ed308495b04694943d414e0444151fe141d05581b3eb2a4f168</p>
<p>Suppose that we know that it has been encrypted using Diffie Helman algorithm. The encryptors have been a little slap dash and used the following values for publicly available information:</p>
<p>p=31 q=23</p>
<p>Can you use <a href="#fig-diffiehelmanndecrypt" class="quarto-xref">Figure&nbsp;6</a> to decrypt the message using the available information?</p>
<div id="fig-diffiehelmanndecrypt" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-diffiehelmanndecrypt-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="fig-diffiehelmanndecrypt" class="shinylive-python" data-engine="python"><code>#| standalone: true
#| components: [viewer]
#| viewerHeight: 500

from shiny import App, Inputs, Outputs, Session, render, ui
from shiny import reactive

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.integrate import odeint
import sympy as sp
import pandas as pd
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import dh
import os
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import base64


app_ui = ui.page_fluid(
    ui.layout_sidebar(
        ui.sidebar(
    ui.input_slider(id="p",label="p",min=10,max=3000,value=23,step=1),
    ui.input_slider(id="g",label="g (generator)",min=0,max=33,value=5,step=1),
    ui.input_slider(id="a",label="Private key Bob",min=1,max=10,value=2,step=1),
    ui.input_slider(id="b",label="Private key Sue",min=1,max=10,value=3,step=1),
 
    ui.input_text(id='text',label="Message to decrypt",value="8968d20bbc5b"),
            ),

        ui.output_table("result"),
    ),
)

def server(input, output, session):
    


    
    def decrypt_message(key, iv, ciphertext):
        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        return plaintext


    @render.table
    def result():
        # list of strings
        p=int(input.p())
        g=int(input.g())
        a=int(input.a())
        encrypted_text=str(input.text())
        b=int(input.b())

        encrypted_text=bytes.fromhex(encrypted_text)

        #text=text.encode(encoding="utf-8")
        #encrypted_text = encrypted_text.encode('ISO-8859-1')

        shared_secret=int(np.mod(g**(a*b),p))
        shared_secret_bytes=shared_secret.to_bytes(16,'big')
        derived_key = HKDF(
            algorithm=hashes.SHA256(),
            length=32,
            salt=None,
            info=b"diffie-hellman-key-exchange",
        ).derive(shared_secret_bytes)
        
        #bytes_data = bytes.fromhex(text)
        # Encode the bytes into a Base64 string
        #encrypted_text = base64.b64encode(text.encode())#.decode('utf-8')
        iv=5
        iv=iv.to_bytes(16, 'big')
                
        decrypted_message = decrypt_message(derived_key, iv, encrypted_text)

       
        data_dict = {
            'Decrypted Message':[decrypted_message]
            }

        # Create a DataFrame
        df = pd.DataFrame(data_dict)
        # Calling DataFrame constructor on list
        return df

         


app = App(app_ui, server)</code></pre>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-diffiehelmanndecrypt-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6
</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>At Dundee, core concepts from number theory are introduced in the module <em>Topics in Pure Mathematics</em></p>
<p>In the modules <em>Introduction to Programming</em> and <em>Computer Algebra and Dynamical systems</em> you would be introduced to programming techniques that enable you to explore encryption algorithms.</p>
<p>At Level 4 we offer honours projects that consider different aspects of cryptography and group theory.</p>
<p>You can find out more about these modules <a href="https://www.dundee.ac.uk/undergraduate/mathematics-bsc/teaching-and-assessment">here</a>.</p>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/dundeemath\.github\.io\/Admissions\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>