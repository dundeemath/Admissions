[
  {
    "objectID": "WorkSheetPrintOut.html",
    "href": "WorkSheetPrintOut.html",
    "title": "Pop. dynamics worksheet",
    "section": "",
    "text": "The aim of this demonstration is to show how we can use ideas from calculus to study dynamical systems.\n\nIt is not intended that you work through all the questions in the available time.\nYou are encouraged to use your phone to explore the linked apps"
  },
  {
    "objectID": "WorkSheetPrintOut.html#formulating-a-model-of-population-dynamics",
    "href": "WorkSheetPrintOut.html#formulating-a-model-of-population-dynamics",
    "title": "Pop. dynamics worksheet",
    "section": "3.1 Formulating a model of population dynamics",
    "text": "3.1 Formulating a model of population dynamics\nLet’s consider a model for the number of people in a room at a given time. Let \\(t\\) represent time and \\(N(t)\\) represent the number of people in the room at time \\(t\\).\nSuppose that there are initially no people in the room, but people enter at a constant rate, \\(k\\).\nWe could formulate a model of population dynamics given by\n\\[\n\\frac{dN}{dt}=k, \\quad N(0)=0.\n\\tag{1}\\]\n\n\n\n\n\n\nQuestion\n\n\n\n\nCan you integrate Equation 1 (Hint: it is mathematically equivalent to the ODE introduced in Section 2)?\n\n\n\n\n\n\n\n\n\n\nCan you use the solution of the model to determine the amount of time taken for the number of people in the room to reach some capacity, \\(N_C\\).\n\n\n\n\n\n\n\n\nCan you use the app (see Figure 1) to identify what the entry rate, \\(k\\), needs to be such that the room reaches capacity of 40 people after 20 minutes?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: https://dundeemath.github.io/Admissions/posts/PopulationDynamicsIntro.html."
  },
  {
    "objectID": "WorkSheetPrintOut.html#what-if-people-enter-the-room-at-a-constant-rate-but-also-leave-the-room-at-random",
    "href": "WorkSheetPrintOut.html#what-if-people-enter-the-room-at-a-constant-rate-but-also-leave-the-room-at-random",
    "title": "Pop. dynamics worksheet",
    "section": "3.2 What if people enter the room at a constant rate but also leave the room at random?",
    "text": "3.2 What if people enter the room at a constant rate but also leave the room at random?\nTaking the previous model as a starting point, we now assume that people can also leave the room at a rate proportional to the number of people in the room\nThe model equation is now given by\n\\[\n\\frac{dN}{dt}=k - dN, \\quad N(0)=0.\n\\tag{2}\\]\n\n\n\n\n\n\nQuestion\n\n\n\nIt is possible to integrate Equation 2 and show that the solution is \\[\nN(t)=\\frac{k}{d}(1-e^{-dt})\n\\tag{3}\\]\nCan you do this? (hint: try using an integrating factor)?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nCan you use the model solution (Equation 3) to determine the amount of time taken for the number of people in the room to reach capacity, \\(N_C\\). Does a solution always exist?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nCan you use the app or the solution (Equation 3) to identify the entry rate needs to be such that the room reaches capacity of 40 people after 20 minutes given \\(d=0.1\\)?"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#why-maths",
    "href": "Slides/TasterDayMay2024.html#why-maths",
    "title": "Taster Day 2024",
    "section": "Why Maths?",
    "text": "Why Maths?"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#maths-careers",
    "href": "Slides/TasterDayMay2024.html#maths-careers",
    "title": "Taster Day 2024",
    "section": "Maths careers",
    "text": "Maths careers"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#recent-gradautes",
    "href": "Slides/TasterDayMay2024.html#recent-gradautes",
    "title": "Taster Day 2024",
    "section": "Recent gradautes",
    "text": "Recent gradautes\nOur recent graduates have gone on to work as:\n\naccountants\ntrade analysts\ntransport planners\nactuaries\nengineers\nteachers\nsoftware developers\ndata analysts\nand many others"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#mathematics-degrees-at-dundee",
    "href": "Slides/TasterDayMay2024.html#mathematics-degrees-at-dundee",
    "title": "Taster Day 2024",
    "section": "Mathematics degrees at Dundee",
    "text": "Mathematics degrees at Dundee\n\nSingle honours Mathematics degrees\nBSc Mathematics/MMath\nJoint degrees (e.g.)\n\nBSc Mathematical Biology\nBSc Maths and Economics\nBSc Maths and Physics\nBSc Maths and Accountancy"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#what-you-will-learn",
    "href": "Slides/TasterDayMay2024.html#what-you-will-learn",
    "title": "Taster Day 2024",
    "section": "What you will learn?",
    "text": "What you will learn?\n\nCore mathematical skills (e.g. calculus, integration, algebra)\nFoundations of mathematics\nApplication of mathematics to real world problems"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#how-you-will-learn",
    "href": "Slides/TasterDayMay2024.html#how-you-will-learn",
    "title": "Taster Day 2024",
    "section": "How you will learn?",
    "text": "How you will learn?\n\nTwo teaching semesters in the academic year\n3 or 4 modules in each semester\nIn each module (some combination of):\n\nlectures\ntutorials\nworkshops\ncomputer classes"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#final-year-project",
    "href": "Slides/TasterDayMay2024.html#final-year-project",
    "title": "Taster Day 2024",
    "section": "Final year project",
    "text": "Final year project\n\ndevelop independent problem solving skills\nwork on an exciting mathematical topic\ndevelop programming skills\ndevelop presentation skills\nTopics include:\n\nThe $25,000,000,000 eigenvector\nConformal mappings in the art of M.C. Escher\nThe Mathematics of monopoly\nHow Sat Navs work"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#skills-developed-throughout-your-degree",
    "href": "Slides/TasterDayMay2024.html#skills-developed-throughout-your-degree",
    "title": "Taster Day 2024",
    "section": "Skills developed throughout your degree",
    "text": "Skills developed throughout your degree\n\nYou will become a logical numerate problem solver\nMathematical skills\nPure mathematics\nApplied mathematics\nPresentation skills\nComputer programming skills"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#design-constraints",
    "href": "Slides/TasterDayMay2024.html#design-constraints",
    "title": "Taster Day 2024",
    "section": "Design constraints",
    "text": "Design constraints\nWe want to identify some interesting problem (s) that:\n\nconnect from high school syllabus to University level mathematics\nhave an element of visualisation\nhave some interesting mathematics\nare interactive\nare accessible"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#lets-look-at-some-working-examples",
    "href": "Slides/TasterDayMay2024.html#lets-look-at-some-working-examples",
    "title": "Taster Day 2024",
    "section": "Let’s look at some working examples",
    "text": "Let’s look at some working examples\nhttps://dundeemath.github.io/Admissions/\n\nExplore apps"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#possible-topics",
    "href": "Slides/TasterDayMay2024.html#possible-topics",
    "title": "Taster Day 2024",
    "section": "Possible topics",
    "text": "Possible topics\n\nGraphing functions and their derivatives\nRecursion relations\nTrigonometric identities\nDifferential equations\nStatistical tests\nComplex numbers\nWhat would you like to work on?"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#what-we-need-to-do-today",
    "href": "Slides/TasterDayMay2024.html#what-we-need-to-do-today",
    "title": "Taster Day 2024",
    "section": "What we need to do today",
    "text": "What we need to do today\n\nfocus on some ideas for a new app\nwrite some prototype code\ndecide how to make it interactive\nwrite some text to explain the ideas in the app\nbuild the app"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#section",
    "href": "Slides/TasterDayMay2024.html#section",
    "title": "Taster Day 2024",
    "section": "",
    "text": "## Prototype code that plots a trigonometric function and its derivative\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndx=0.01\nx = np.arange(0, 20, dx)\ny = np.sin(x)\n\ndy_dx=np.cos(x)\n\nfig, ax = plt.subplots(1,2)\nax[0].plot(x, y)\nax[0].set_xlabel('x')\nax[0].set_ylabel('y(x)')\n\nax[1].plot(x, dy_dx)\nax[1].set_xlabel('x')\nax[1].set_ylabel('dy/dx')\n\nax[0].grid(True)\nax[1].grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\nMathematics, University of Dundee"
  },
  {
    "objectID": "MathsWeekScotland2024/Worksheet.html",
    "href": "MathsWeekScotland2024/Worksheet.html",
    "title": "D’Arcy Thompson and 2D mappings Worksheet",
    "section": "",
    "text": "We can represent a point, \\(P\\), in the plane using a vector with components representing its \\(x\\) and \\(y\\) coordinates, i.e. \\[\n\\mathbf{v}_P=[x_P,y_P]\n\\] represent a point with coordinates \\(x_P\\) and \\(y_P\\).\nA transformation is performed by defining a new point, \\(P'\\), with new cooridnates that are some functions of the old coordinates, i.e. \\[\n\\mathbf{v}_{P'}=[x_{P'},y_{P'}]=[f(x_{P},y_{P}),g(x_{P},y_{P})].\n\\] where \\(f(.,.)\\) and \\(g(.,.)\\) are functions that will represent a particular transformation."
  },
  {
    "objectID": "MathsWeekScotland2024/Worksheet.html#linear-transformation",
    "href": "MathsWeekScotland2024/Worksheet.html#linear-transformation",
    "title": "D’Arcy Thompson and 2D mappings Worksheet",
    "section": "Linear transformation",
    "text": "Linear transformation\n\nTranslation\nSuppose that \\(f\\) and \\(g\\) are defined such that \\[\nf(x,y)=x+t_x\n\\] and \\[\ng(x,y)=y+t_y\n\\]\nwhere \\(t_x\\) and \\(t_y\\) are constants.\n\nCompute the transformation of the point \\(P(1,2)\\) in the case \\((t_x,t_y)=(3,0)\\).\nIdentify the inverse of the transformation in 1.\n\n\n\n\n\n\n\n\n\n\n\n\nScalings\nConsider a scaling transformation defined such that \\[\nf(x,y)=a*x\n\\] and \\[\ng(x,y)=b*y\n\\] where \\(b\\) is a constant.\n\nCompute the transformation of the point \\(P(2,1)\\) in the case \\(b=2\\).\nIdentify the inverse of the transformation in 1. Are there values of \\(b\\) for which an inverse does not exist?\n\n\n\n\n\n\n\n\n\n\n\n\nRotation\nNow consider a transformation \\[\nf(x,y)=\\cos\\theta x -\\sin\\theta y\n\\] and \\[\ng(x,y)=\\sin\\theta x +\\cos\\theta y\n\\]\nwhere \\(\\theta\\) is a constant value.\n\nCompute the transformation of the point \\(P(2,0)\\) in the case \\(\\theta=90\\deg (\\frac{\\pi}{2} rad)\\).\nIdentify the inverse of the transformation in 1.\n\n\n\n\n\n\n\n\n\n\n\n\nShear\n\\[\nf(x,y)=x+ay\n\\] and \\[\ng(x,y)= y\n\\] where \\(a\\) is a positive constant.\n\nCompute the transformation of the point \\(P(0,2)\\) in the case \\(a=2\\).\n\n\n\n\n\n\n\n\n\n\n\n\nA general representation\nIf you have been introduced to vectors and matrices then you may spot that the above transformations can be represented as a matrix multiplication of a vector.\nConsider the matrix \\[\nA=\n\\begin{pmatrix}\na_{11} & a_{12} \\\\ a_{21} & a_{22}\n\\end{pmatrix}.\n\\]\nDefine \\[\n\\mathbf{v}_{P'}=A\\mathbf{v}_P\n\\]\nCan you identify values of the parameters \\(a_{11}\\), \\(a_{12}\\) etc. that descibe the rotation, shear and scaling transformations?"
  },
  {
    "objectID": "posts/IntersectingLines.html",
    "href": "posts/IntersectingLines.html",
    "title": "Intersecting lines and linear algebra",
    "section": "",
    "text": "Intersecting lines in two dimensional space\nConsider the equations of two straight lines given by \\[\ny=m_1x+c_1\n\\tag{1}\\] and \\[\ny=m_2x+c_2,\n\\tag{2}\\] where \\(m_1\\), \\(m_2\\), \\(c_1\\) and \\(c_2\\) are constants.\nIn Figure 1 you can play with the slopes and intercepts of the lines. Can you spot a condition that holds on the slopes such that the straight lines do not intersect?\nProblems such as the intersection of straight lines can be formulated using linear algebra. In the title of Figure 1 the determinant of a matrix (defined below) is reported for given values of the slopes and intercept. Can you spot a relationship between the value of the matrix determinant and the geometric properties of the lines?\n\n\n\n\n\n\nTip\n\n\n\nPlease note that the app in Figure 1 is approximately 20 MB. If it does not display on your device:\n\nwait a moment (it is downloading the Python code that will run the app)\nrefresh your browser.\n\nIf it still does not load, here is a screenshot.\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"m_1\",label=\"m_1\",min=-5,max=5,value=1.0,step=0.2),\n    ui.input_slider(id=\"c_1\",label=\"c_1\",min=-5.0,max=5.0,value=1.0,step=0.2),\n    ui.input_slider(id=\"m_2\",label=\"m_2\",min=-5.0,max=10.0,value=5.0,step=0.2),            \n    ui.input_slider(id=\"c_2\",label=\"c_2\",min=-5.0,max=10.0,value=5.0,step=0.2),            \n    ),\n    ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        m_1=float(input.m_1())\n        c_1=float(input.c_1())\n        m_2=float((input.m_2()))\n        c_2=float((input.c_2()))\n\n        # Define discretised t domain\n        x = np.linspace(-10, 10, 100)\n        y_1 = m_1*x+c_1\n        y_2 = m_2*x+c_2\n\n        ax.plot(x, y_1, x,y_2)\n        matrix=np.zeros((2,2))\n        matrix[0,0]=m_1\n        matrix[0,1]=1.0\n        matrix[1,0]=m_2\n        matrix[1,1]=1.0\n\n        matrix=np.matrix(matrix)\n\n        determinant=np.linalg.det(matrix)\n        ax.set_title('$\\det{A}$ = ' +str(determinant))\n        ax.set_ylim([-10,10])\n        ax.set_xlim([-10,10])\n        ax.grid(True)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 1: A plot of two lines in 2D plane.\n\n\n\nTo find the intersection of the lines we can rearrange Equation 1 and Equation 2 to obtain \\[\n\\begin{aligned}\nm_1x-y&=-c_1, \\\\\nm_2x-y&=-c_2.\n\\end{aligned}\n\\] The equations can be written in matrix-vector form as \\[\nA \\mathbf{x}=\\mathbf{b},\n\\] where \\[\nA=\\begin{pmatrix} m_1 & -1 \\\\ m_2 & -1\\end{pmatrix},\n\\] and \\[\n\\mathbf{b}=\\begin{pmatrix} -c_1 \\\\ -c_2\\end{pmatrix},\n\\] with \\[\n\\mathbf{x}=\\begin{pmatrix} x \\\\ y\\end{pmatrix}.\n\\]\nThe matrix determinant is defined to be \\[\n\\det{A}=-m_1 +m_2.\n\\]\nHence when the slopes of the lines are equal, the matrix determinant is zero. In this case the lines are parallel and there is either:\n\nno intersection (the lines have distinct intercepts)\nan infinite family of intersections (the lines also have the same intercept).\n\n\n\nIntersecting lines in three dimensional space\nWe will now explore the intersection of two lines in 3D space.\nConsider a line in 3D with direction vector [1,1,1] that passes through the origin. The equation for the line can be written in parametric form as \\[\n\\mathbf{r}_1= \\lambda_1 [1,1,1]^T, \\quad \\lambda_1 \\in \\Re.\n\\]\nConsider a second line defined such that \\[\n\\mathbf{r}_2= \\lambda_2 \\mathbf{t}+ \\mathbf{c}, \\quad \\lambda_2 \\in \\Re.\n\\]\nIn Figure 2 you can play with the direction vector, \\(\\mathbf{t}\\), and the point \\(\\mathbf{c}\\) of the second line.\nIn the app set \\(c=[c_1,c_2,c_3]^T=[0,0,0]^T\\). Can you demonstrate that\n\nwhen \\(t=[t_1,t_2,t_3]^T=[1,-1,0]^T\\) that the lines intersect at the origin?\nwhen \\(t=[t_1,t_2,t_3]^T=[1,1,1]^T\\) the minimum distance between the lines is reported as nan (not a number)?\n\nTo compute the shortest distance between the two lines we can identify the points on each of the lines (parameters \\(\\lambda^*\\) and \\(\\mu^*\\)) that define closest approach. The equations to define \\(\\lambda^*\\) and \\(\\mu^*\\) can be written in matrix-vector form as \\[\nA \\mathbf{x}=\\mathbf{b},\n\\tag{3}\\] where \\[\nA=\\begin{pmatrix} \\mathbf{s}\\cdot\\mathbf{s} & -\\mathbf{t}\\cdot \\mathbf{s} \\\\ \\mathbf{t}\\cdot \\mathbf{s} & -\\mathbf{t}\\cdot \\mathbf{t}\\end{pmatrix},\n\\] and \\[\n\\mathbf{b}=\\begin{pmatrix} \\mathbf{c}\\cdot \\mathbf{s} \\\\ \\mathbf{c}\\cdot \\mathbf{t}\\end{pmatrix},\n\\] with \\[\n\\mathbf{x}=\\begin{pmatrix} \\lambda^* \\\\ \\mu^*\\end{pmatrix}.\n\\] Here \\(\\mathbf{s}\\) represents the direction vector for the first line.\nIf a solution to Equation 3 can be found then it is straightforward to calculate the shortest distance, \\(d\\), between the straight lines.\n\n\n\n\n\n\nTip\n\n\n\nPlease note that the app in Figure 2 is approximately 20 MB. If it does not display on your device:\n\nwait a moment (it is downloading the Python code that will run the app)\nrefresh your browser.\n\nIf it still does not work, here is a screenshot.\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    \n    ui.input_slider(id=\"t_1\",label=\"t_1\",min=-5.0,max=10.0,value=5.0,step=0.2),            \n    ui.input_slider(id=\"t_2\",label=\"t_2\",min=-5.0,max=10.0,value=2.0,step=0.2),     \n    ui.input_slider(id=\"t_3\",label=\"t_3\",min=-5.0,max=10.0,value=1.0,step=0.2),         \n    ui.input_slider(id=\"c_1\",label=\"c_1\",min=-10.0,max=10.0,value=-5.0,step=0.2),  \n    ui.input_slider(id=\"c_2\",label=\"c_2\",min=-10.0,max=10.0,value=5.0,step=0.2),\n    ui.input_slider(id=\"c_3\",label=\"c_3\",min=-10.0,max=10.0,value=5.0,step=0.2),\n    ui.input_slider(id=\"azim_ang\",label=\"Rotate view\",min=-180.0,max=180.0,value=0.0,step=0.1), \n            ),        \n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        ax = plt.figure().add_subplot(projection='3d')\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        s_1=1.0\n        s_2=1.0\n        s_3=1.0\n   \n        t_1=float((input.t_1()))\n        t_2=float((input.t_2()))\n        t_3=float((input.t_3()))\n        c_1=float((input.c_1()))\n        c_2=float((input.c_2()))\n        c_3=float((input.c_3()))\n        azim_ang=float((input.azim_ang()))\n\n        \n\n        # Define discretised t domain\n\n        # L1:r=s*lam+[0,0,0]\n        # L2:r=t*lam+[c_1,c_2,c_3]\n        #  Define  points on lines (need to used scatter as rendering of plot in 3d using matplotlib id a problem)\n        lam=np.linspace(-15.0,15.0,5000)\n        L1_x=lam*[s_1]+[0.0] \n        L1_y=lam*[s_2]+[0.0] \n        L1_z=lam*[s_3]+[0.0]\n        L2_x=lam*[t_1]+c_1 \n        L2_y=lam*[t_2]+c_2 \n        L2_z=lam*[t_3]+c_3\n\n\n        # define direction vectors of lines\n        c_0_vec=np.array([0,0,0])\n        c_2_vec=np.array([c_1,c_2,c_3])\n        s_vec=np.array([s_1,s_2,s_3] )\n        t_vec=np.array([t_1,t_2,t_3])  \n        # Find lambdas that define closest point on each lines\n        #lam_2=np.dot(c_2_vec-c_0_vec,s_vec-t_vec)/(np.dot(t_vec,t_vec)-np.dot(t_vec,s_vec))\n\n        A=np.array([[np.dot(s_vec,s_vec), -np.dot(t_vec,s_vec)],[np.dot(s_vec,t_vec), -np.dot(t_vec,t_vec)]])\n        b=np.array([np.dot(c_2_vec-c_0_vec,s_vec), np.dot(c_2_vec-c_0_vec,t_vec)])\n\n        determinant=np.linalg.det(A)\n\n        #A=np.array([[1,0],[0,1]])\n        #b=np.array([1,1])\n        x=np.dot(np.linalg.inv(A),b)\n\n        lam_1=x[0]\n        lam_2=x[1]    \n\n        # Expression for closest points\n        cp_1=lam_1*s_vec+c_0_vec\n        cp_2=lam_2*t_vec+c_2_vec\n        \n        # min distance\n        min_dist=np.linalg.norm(cp_2-cp_1)\n\n        #fig = plt.figure()\n        ax.scatter(L1_x,L1_y,L1_z)\n        ax.scatter(L2_x,L2_y,L2_z,'k*')\n        ax.plot([cp_1[0], cp_2[0]],[cp_1[1], cp_2[1]],[cp_1[2], cp_2[2]],'k')\n        ax.set_title('d = ' + str(np.round(min_dist,3))+ ', $\\det(A)$ = ' + str(np.round(determinant,3)))\n        my_matrix=np.array2string(A, suppress_small=True, formatter={'float': '{:0.4f}'.format})\n        \n        ax.text(-5,5,5.0, '$A=$'+my_matrix)\n        #ax.plot([L2_1[0],L2_2[0]], [L2_1[1],L2_2[1]],[L2_1[2],L2_2[2]],'r',alpha=0.8,linewidth=6)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n        ax.set_zlabel('$z$')\n\n        ax.set_xlim([-10,10])\n\n        ax.set_ylim([-10,10])\n        ax.set_zlim([-10,10])\n        #ax.view_init(elev=30, azim=45.0, roll=15)\n        ax.view_init(elev=30, azim=azim_ang)\n\n        #determinant=np.linalg.det(matrix)\n\n\n\n\n\n        \n        #from matplotlib import rc\n        #rc('text', usetex=True)\n        #my_matrix = \"$$A=\\\\  \\\\begin{array}{ll} 2 & 3 \\\\ 4 & 5 \\\\end{array} \\\\$$\"\n        #text(my_matrix, (1,1))\n       \n        #ax.text(-10,40, '$A=$'+my_matrix)\n        #ax.annotate('$A$ = ' + matrix, xy = (-10, 40), fontsize = 16, xytext = (-10, 40), arrowprops = dict(facecolor = 'red'),color = 'g')\n        \n\n       # ax.annotate(\n    #\"$\\begin{matrix} a & b  \\\\ d & e  \\end{matrix} $\",\n   # (0.25, 0.25),\n   # textcoords='axes fraction', size=20)\n\n        \n\n        #text_x=0.25*(min_x+max_x)\n        #text_y=np.mean(y)\n        #title_Str= = ' '.join(map(str, (roots)))\n        #title_Str=[(\"R\"+ str(j) +\" = \" + str(roots[j]) ) for j in range(len(roots))]\n        #title_Str = str(title_Str)[1:-1]\n\n        #ax.set_title(title_Str)\n        #ax.set_title([(\"R\"+ str(j) +\" = \" + str(roots[j]) ) for j in range(len(roots))])\n\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2: An app to explore the intersection between two straight lines in 3D. The blue line passes thorugh the origin and has direction vector \\([1,1,1]\\). The red line is controlled by the parameters in the left column. The black line connects the points on each line at which the distance between the lines is minimised. The minimal distance between the lines is reported in the title.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, the parametric equations of lines, spheres and planes are studied in the module Maths 1B.\nConcepts from geometry and linear algebra are generalised in the modules Maths 2A and Maths 2B.\nAt Level 3 in the module Differential Geometry geometrical concepts and tools that are essential for understanding classical and modern physics and engineering are further developed.\nAt Levels 2, 3 and 4 you will learn how to use computer programming to explore and communicate mathematical concepts.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/TheSIRModel.html",
    "href": "posts/TheSIRModel.html",
    "title": "Modelling the spread of infectious disease",
    "section": "",
    "text": "Infectious disease\nInfectious diseases can have severe health outcomes for individuals who contract them. They can also place an unmanageably large demand on the health service.\nInfectious diseases can be characterised using their basic reproduction number, \\(R_0\\).\n\nInfectious disease basic reproduction numbers Source.\n\n\nDisease\n\\(R_0\\)\n\n\n\n\nMeasles\n12-18\n\n\nChickenpox\n10-12\n\n\nRubella\n6-7\n\n\nCommon cold\n2-3\n\n\nCovid 19 (Omicron)\n9.5\n\n\n\n\n\nMathematical modelling of infectious diseases\nWe can use mathematics to study the dynamics of an infectious disease within a population. In the SIR model a population is split into three compartments:\n\n\\(S(t)\\) - size of susceptible population at time \\(t\\)\n\\(I(t)\\) - size of infected population at time \\(t\\)\n\\(R(t)\\) - size of recovered/post-infected population at time \\(t\\)\n\nThe SIR model has two parameters:\n\n\\(r\\) - infection rate\n\\(a\\) - recovery rate\n\nFrom a public health perspective, one could propose that there is some level of infectiousness, \\(I_{max}\\), which must be avoided. The challenge is to manage the disease such that \\(I(t)&lt;I_{max}\\) for all \\(t\\).\nIn the app in Figure 1 you can investigate how the values of the parameters \\(r\\) and \\(a\\) affect the trajectory of the infectious disease.\n\n\n\n\n\n\nTip\n\n\n\nPlease note that the app in Figure 1 is approximately 20 MB. If it does not display on your device:\n\nwait a few moments (it is downloading the Python code that will run the app)\nrefresh your browser.\n\ntry running on a faster connection/ more powerful device.\n\nIf it still does not load, here is a screenshot.\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"r\",label=\"r\",min=0.00001,max=0.001,value=0.001,step=0.00001),\n    ui.input_slider(id=\"S0\",label=\"Initial susceptible pop. (S(0))\",min=1000.0,max=8000.0,value=4000.1,step=5.0),\n    ui.input_slider(id=\"a\",label=\"a\",min=0.01,max=0.2,value=0.05,step=0.001),            \n    ui.input_slider(id=\"I0\",label=\"Initial infectious pop. (I(0)) \",min=0.0,max=17.0,value=17.0,step=0.5),  \n    ui.input_slider(id=\"T\",label=\"Simulation time\",min=0.0,max=70.0,value=40.0,step=0.5),\n    ui.input_slider(id=\"max_inf\",label=\"Max. infectiousness\",min=0.0,max=10000.0,value=2500.0,step=100.5),             \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        S_0=float(input.S0())\n        a=float(input.a())\n        I_0=float(input.I0())\n        T=float(input.T())\n        max_inf=float(input.max_inf())\n\n        R_0=r*S_0/a\n        \n        # Define rhs of LV ODEs\n        def rhs_sir_model(x,t,r,a):\n          rhs=np.zeros_like(x,dtype=float)\n          S=x[0]\n          I=x[1]\n          R=x[2]\n\n          \n\n          dS_dt=-r*I*S\n          dI_dt=r*I*S-a*I\n          dR_dt=a*I\n\n          rhs[0]=dS_dt\n          rhs[1]=dI_dt\n          rhs[2]=dR_dt\n\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[S_0,I_0,0.0]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_sir_model, init_cond,t,args=(r,a))\n\n        # Plot results\n        S=sol1[:,0]\n        I=sol1[:,1]\n        R=sol1[:,2]\n        \n        ax.plot(t, S, 'b',t,I,'r',t,R,'k')\n        ax.plot(t,max_inf*np.ones_like(t),'--')\n        ax.legend(['S','I','R','Max. allowed infectiousness'],loc='best')\n        ax.set_xlabel('$t$')\n        ax.set_title('R_0 =' + str(R_0))\n\n        #plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1: The sizes of the different populations are plotted against time, \\(t\\). The model parameters are defined using the sliders on the left-hand side. The differential equations are in Equation 1.\n\n\n\n\n\nExercises with the app\n\ncan you determine what value the infectivity parameter, \\(r\\), must go below in order that \\(I(t)&lt;I_{max}\\)?\nsuppose that covid omicron in a susceptible population of \\(S_0=5000\\) has a recovery rate \\(a=0.05\\). Can you estimate the value of the infectivity parameter, \\(r\\), such that \\(R_0=9.5\\)?\nwhich parameters in the app best represent the effect of vaccination of a section of the population?\n\n\n\nThe SIR model equations\nThe SIR model is formulated as a system of ordinary differential equations.\nOn this page we consider a simpler case of a single population.\nThe governing equations in the SIR model are: \\[\n\\begin{aligned}\n\\frac{dS}{dt}&=-rIS, \\\\\n\\frac{dI}{dt}&=rIS-aI, \\\\\n\\frac{dR}{dt}&=aI.\n\\end{aligned}\n\\tag{1}\\]\nThe initial conditions are:\n\\[\n\\begin{aligned}\nS(t=0)&=S_0, \\\\\nI(t=0)&=I_0, \\\\\nR(t=0)&=R_0.\n\\end{aligned}\n\\]\nIn the app in Figure 1 Equation 1 are solved numerically for a given parameter set and the solution is plotted.\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, the mathematical tools needed are developed in modules:\n\nMaths 1A, 1B, 2A and 2B (Core maths modules)\nComputer algebra and dynamical systems\nMathematical Biology I\nMathematical Biology II\n\nAt Levels 2, 3 and 4 you will learn how to use computer programming to explore and communicate mathematical concepts.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/PopulationDynamicsIntro.html",
    "href": "posts/PopulationDynamicsIntro.html",
    "title": "Introduction to population dynamics",
    "section": "",
    "text": "We can use calculus to study how populations change in time. In the examples below we consider an illustrative model of population dynamics in a class room. The developed concepts can be used to study population dynamics of infectious disease transmission.\n\n\nYou might have previously encountered differentiation. Suppose that \\(y\\) is some function of \\(x\\).\nConsider the differential equation\n\\[\n\\frac{dy}{dx}=1\n\\]\nUpon integration\n\\[\ny(x)=x+C\n\\] where \\(C\\) is an integration constant.\nWhat if \\[\n\\frac{dy}{dx}=x\n\\]\nCan you integrate this ordinary differential equation?"
  },
  {
    "objectID": "posts/PopulationDynamicsIntro.html#sec-background",
    "href": "posts/PopulationDynamicsIntro.html#sec-background",
    "title": "Introduction to population dynamics",
    "section": "",
    "text": "You might have previously encountered differentiation. Suppose that \\(y\\) is some function of \\(x\\).\nConsider the differential equation\n\\[\n\\frac{dy}{dx}=1\n\\]\nUpon integration\n\\[\ny(x)=x+C\n\\] where \\(C\\) is an integration constant.\nWhat if \\[\n\\frac{dy}{dx}=x\n\\]\nCan you integrate this ordinary differential equation?"
  },
  {
    "objectID": "posts/PopulationDynamicsIntro.html#constant-entry-rate",
    "href": "posts/PopulationDynamicsIntro.html#constant-entry-rate",
    "title": "Introduction to population dynamics",
    "section": "2.1 Constant entry rate",
    "text": "2.1 Constant entry rate\nLet’s consider a model for the number of people in a classroom at a given time. Let \\(t\\) represent time and \\(N(t)\\) represent the number of people in the room at time \\(t\\).\nSuppose that there are initially no people in the room, but people enter at a constant rate, \\(k\\).\nWe could formulate a model of population dynamics given by\n\\[\n\\frac{dN}{dt}=k, \\quad N(0)=0.\n\\]\n\nCan you integrate this ODE (hint: it is mathematically equivalent to the ODE introduced in Section 1.1)?\nCan you use the model to determine the amount of time taken for the number of people in the room to reach capacity, \\(N_C\\).\nThe app in Figure 1 allows you to explore the solution of the model. Can you identify what the entry rate needs to be such that the room reaches capacity of 40 people after 20 minutes?\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"k\",label=\"Entry rate (per minute)\",min=0.01,max=3,value=0.1,step=0.00001),\n    ui.input_slider(id=\"N0\",label=\"initial pop\",min=0.0,max=20.0,value=0.1,step=1.0),\n    \n    ui.input_slider(id=\"T\",label=\"Simulation time (minutes)\",min=0.0,max=60.0,value=20.0,step=0.5),\n    ui.input_slider(id=\"max_inf\",label=\"Max. num\",min=0.0,max=100.0,value=40.0,step=1.5),             \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        k=float(input.k())\n        N_0=float(input.N0())\n        T=float(input.T())\n        max_inf=float(input.max_inf())\n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(x,t,k,r):\n          rhs=np.zeros_like(x,dtype=float)\n          N=x[0]\n          dN_dt=k\n          rhs[0]=dN_dt\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[N_0]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_pop_model, init_cond,t,args=(k,1))\n\n        # Plot results\n        N=sol1[:,0]\n        \n        \n        ax.plot(t, N)\n        ax.plot(t,max_inf*np.ones_like(t),'--')\n        ax.legend(['N','Max. room occupancy'],loc='best')\n        ax.set_xlabel('$t$ (minutes)')\n        ax.set_ylim([0,max_inf*1.4])\n\n        #plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1"
  },
  {
    "objectID": "posts/PopulationDynamicsIntro.html#what-if-people-enter-the-room-at-a-constant-rate-but-also-leave-the-room-at-random",
    "href": "posts/PopulationDynamicsIntro.html#what-if-people-enter-the-room-at-a-constant-rate-but-also-leave-the-room-at-random",
    "title": "Introduction to population dynamics",
    "section": "2.2 What if people enter the room at a constant rate but also leave the room at random?",
    "text": "2.2 What if people enter the room at a constant rate but also leave the room at random?\nTaking the previous model as a starting point, we now assume that people leave the room at a rate proportional to the number of people in the room\nThe model equation is now given by\n\\[\n\\frac{dN}{dt}=k - dN, \\quad N(0)=0.\n\\]\nCan you integrate this ODE (hint: try a technique called separation of variables)?\nIf so, can you use the model to determine the amount of time taken for the number of people in the room to reach capacity, \\(N_C\\).\nThe app in Figure 2 allows you to explore the solution of the model. Can you identify what the entry rate needs to be such that the room reaches capacity of 40 people after 20 minutes given \\(d=0.1\\)?\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 600\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"k\",label=\"Entry rate (per minute)\",min=0.01,max=10,value=0.1,step=0.00001),\n    ui.input_slider(id=\"d\",label=\"exit rate (per minute)\",min=0.01,max=3,value=0.1,step=0.00001),\n    ui.input_slider(id=\"N0\",label=\"initial pop\",min=0.0,max=20.0,value=0.1,step=1.0),\n    \n    ui.input_slider(id=\"T\",label=\"Simulation time (minutes)\",min=0.0,max=60.0,value=20.0,step=0.5),\n    ui.input_slider(id=\"max_inf\",label=\"Max. num\",min=0.0,max=100.0,value=40.0,step=1.5),             \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        k=float(input.k())\n        d=float(input.d())\n\n        N_0=float(input.N0())\n        T=float(input.T())\n        max_inf=float(input.max_inf())\n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(x,t,k,d):\n          rhs=np.zeros_like(x,dtype=float)\n          N=x[0]\n          dN_dt=k-d*N\n          rhs[0]=dN_dt\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[N_0]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_pop_model, init_cond,t,args=(k,d))\n\n        # Plot results\n        N=sol1[:,0]\n        \n        \n        ax.plot(t, N)\n        ax.plot(t,max_inf*np.ones_like(t),'--')\n        ax.legend(['N','Max. room occupancy'],loc='best')\n        ax.set_xlabel('$t$ (minutes)')\n        ax.set_ylim([0,max_inf*1.4])\n\n        #plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) are studied in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the modules Computer algebra and dynamical systems and Introduction to Programming you would be introduced to techniques that are used to compute numerical solutions to differential equations.\nAt Level 3 in the module Differential Equations you would extend your knowledge of differential equations to include concepts such as Fourier Series and Partial Differential Equations. In the modules Mathematical Biology I and Mathematical Biology II you would also learn how to formulate and study mathematical models of biological systems.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/Mappings2D.html",
    "href": "posts/Mappings2D.html",
    "title": "D’Arcy Thompson and 2D mappings",
    "section": "",
    "text": "In D’Arcy Thompson’s book ‘On Growth and Form’ he considers how the shapes of related species can be understood using mathematical maps.The underlying idea is that the observed morphological form of an organism (i.e. what you see) is a function of the history of the growth rates of different parts of the organism during development. Although related species can quite different, their shape and size can be sometimes related by quite simple mathematical rules.\nIn Figure 1 you can see two different species of fish."
  },
  {
    "objectID": "posts/Mappings2D.html#explore-mappings-via-an-app",
    "href": "posts/Mappings2D.html#explore-mappings-via-an-app",
    "title": "D’Arcy Thompson and 2D mappings",
    "section": "Explore mappings via an app",
    "text": "Explore mappings via an app\nIn the app in Figure 2 you can explore mappings similar to those considered by D’Arcy Thompson. The default image initially used is a stock image used in image processing.\n\n\n\n\n\n\nInteractivity in the App:\n\n\n\n\nEach map depends on the value of a single parameter.\nA number of different maps are considered.\nYou can upload images from your device using the upload button.\nYou can download transformed images by right-clicking and saving.\n\n\n\nIf you save the images in Figure 1 to your computer (right click and ‘Save Image to Download’) you can upload them to the App and explore the effect of the different transformations.\nYou can also upload your own images (in .png or .jpg format).\n\n\n\n\n\n\n\n\nArgyropelecusOlfersi\n\n\n\n\n\n\n\nScarus\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 600\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport skimage as ski\nimport pyodide\nfrom skimage.transform import SimilarityTransform\nfrom skimage.transform import warp\nfrom skimage.transform import PiecewiseAffineTransform\nfrom skimage.transform import AffineTransform\nfrom skimage.io import imread\nimport io\nfrom pathlib import Path\nfrom skimage.transform import resize, rescale\n\ndef ChooseTransform(transform,im_shape,a,num_disc_points,old_centre):\n    rows=im_shape[0]\n    cols=im_shape[1]\n\n    src_cols = np.linspace(0, cols, num_disc_points)\n    src_rows = np.linspace(0, rows, num_disc_points)\n    src_rows, src_cols = np.meshgrid(src_rows, src_cols)\n    src = np.dstack([src_cols.flat, src_rows.flat])[0]\n    dst_rows = src[:, 1] \n    dst_cols = src[:, 0]\n\n    #['Identity','Y stretch','Pinch','Fish eye','Shear','Y squish','Radial']\n    # add sinusoidal oscillation to row coordinates\n    #transform='yscaleDarcy299Fig147'\n    if transform=='Identity':\n        dst_rows = src[:, 1] \n        dst_cols = src[:, 0]\n    elif transform=='Y stretch':\n        yscaleparam=a\n        dst_rows = dst_rows*yscaleparam\n        dst_cols = src[:, 0]\n    elif transform=='Pinch': #'yscaleDarcy299Fig151':\n        sc_factor=a\n        k_x=sc_factor*((dst_cols-cols/2.0)/cols)**1.0+1.0\n        dst_rows = k_x*(dst_rows-rows/2.0)+rows/2.0\n        #dst_cols = src[:, 0]\n    elif transform=='Fish eye': #'yscaleDarcy299Fig149':\n        dst_rows = ((dst_rows-rows/2.0)*(3.0-a*((dst_cols-cols/2.0)/(cols/2.0))**2.0))+rows/2.0\n        #dst_cols = (dst_cols-cols/2.0)*(dst_rows-rows/2.0)**2.0+cols/2.0\n\n        #dst_cols = src[:, 0]  \n\n        #dst_cols = src[:, 0]  \n    elif transform=='Shear': #'yscaleDarcy299Fig147':\n        k_y=-a\n        dst_cols = dst_cols+k_y*dst_rows\n        #dst_cols = src[:, 0]    \n    elif transform=='Y squish':\n        L=np.max(dst_rows)\n        dst_rows = (np.log(1.0+a*(dst_rows)/L))*L/np.log(2.0)\n        #dst_cols = src[:, 0]    \n    elif transform=='yscalepower':\n        L=np.max(dst_rows)\n        n=a\n        dst_rows = L*(dst_rows/L)**n\n        #dst_cols = src[:, 0]        \n    elif transform=='Radial':\n        dst_rows_max=np.max(dst_rows)\n        dst_cols_max=np.max(dst_cols)\n\n        centre=[cols/2.0,rows/2.0]\n        radius=np.sqrt((dst_rows-old_centre[0])**2+(dst_cols-old_centre[1])**2)\n        theta=np.arctan2(dst_rows-old_centre[0],dst_cols-old_centre[1])\n\n        R_typical=np.max(centre)\n        radius=R_typical*((radius.astype(float))/R_typical)**a\n        #theta=theta*1.0\n        dst_rows=radius*np.sin(theta)+old_centre[0]\n        dst_cols=radius*np.cos(theta)+old_centre[1]\n\n        #dst_rows=dst_rows/np.max(dst_rows)*dst_rows_max\n        #dst_cols=dst_cols/np.max(dst_cols)*dst_cols_max\n    elif transform =='thetascale':\n        dst_rows_max=np.max(dst_rows)\n        dst_cols_max=np.max(dst_cols)\n\n        radius=(radius.astype(float))**1.25\n        theta=theta*0.25\n        dst_rows=radius*np.sin(theta)+centre[0]\n        dst_cols=radius*np.cos(theta)+centre[1]\n\n\n    elif transform=='sine':\n        dst_rows = src[:, 1] - np.sin(np.linspace(0, 3 * np.pi, src.shape[0])) * 50\n        dst_cols = src[:, 0]\n        dst_rows *= 1.5\n        dst_rows -= 1.5 * 50\n\n\n    \n    dst = np.vstack([dst_cols, dst_rows]).T\n\n\n    # Calculate the corners of the rotated image\n    tform = PiecewiseAffineTransform()\n    tform.estimate(src, dst)\n\n    return tform, dst,src, rows, cols,dst_cols,dst_rows\n\n\n\n\n\nappdir = Path(__file__).parent\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"Parameter\",min=-3.0,max=3,value=1.0,step=0.16),\n    \n    ui.input_select(id=\"trans\",label=\"Transform\",choices=['Identity','Y stretch','Pinch','Fish eye','Shear','Y squish','Radial'],selected=['Pinch']),\n    ui.input_file(id='input_file',label='Input file',width='1%',button_label='Upload',accept=['.png,.jpg','jpeg'])                 \n    ,width=3,),\n    ui.panel_main(ui.output_plot(\"plot\")),\n    ),\n)\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    \n    @reactive.calc\n    def load_image():\n        im_index=1#input.d()\n        #load_image=1\n        if im_index==1:\n            image =  ski.data.coins()\n        image_orig=image[-1:0:-1,:]\n        return image_orig\n\n    @render.plot\n    def plot():\n\n        image= load_image()\n\n        def parsed_file():\n            file: list[FileInfo] | None = input.input_file()\n            if file is None:\n                return pd.DataFrame()\n            \n            return imread(  # pyright: ignore[reportUnknownMemberType]\n            file[0][\"datapath\"])\n\n\n        if input.input_file():\n            image = parsed_file()\n            #image=image[-1:0:-1]\n\n        if len(image.shape)==3:\n            im_num_voxels=float(image.shape[0]*image.shape[1])\n            target_num_voxels=100000.0\n            target_num_voxels=np.min([target_num_voxels,im_num_voxels])\n\n            rescale_factor= target_num_voxels/im_num_voxels\n            image=rescale(image,rescale_factor,channel_axis=2,anti_aliasing=True)\n            \n        old_centre=np.array((image.shape[0]/2.0,image.shape[1]/2.0))\n\n        fig,ax=plt.subplots(1,2,sharey=True,sharex=True)\n\n        # Input parameters\n        a =float(input.a())\n        trans=input.trans()\n        new_image=image\n        transform=trans\n        a_i=a\n        tform,dst,src,rows, cols,dst_cols,dst_rows= ChooseTransform(transform,new_image.shape,a_i,4,old_centre) \n\n        # Find corners\n        corners = np.array([[0, 0], [0, new_image.shape[0]], [new_image.shape[1], 0], [new_image.shape[1], new_image.shape[0]]])\n        tformed_corners = tform(corners)\n\n\n        minc = tformed_corners.min(axis=0)\n        maxc = tformed_corners.max(axis=0)\n\n        # Find dimensions of transformed box\n        output_shape = 2*(np.ceil(maxc)[::-1]-np.ceil(minc)[::-1]).astype(int)\n\n\n        # Calculate the translation required to move all points into positive coordinates\n        min_coords = dst.min(axis=0)\n        translation = -min_coords\n        tform_shift = AffineTransform(translation=translation)\n\n        # Apply the warp with translation to ensure positive coordinates\n        output_shape = (int(rows + 2*translation[1]), int(cols + 2*translation[0]))\n        new_image_trans = warp(new_image, tform_shift.inverse , output_shape=output_shape)\n    \n        # Define transform on new image\n        # Define the forward transform and transform the image\n        tform,dst,src,rows, cols,dst_cols,dst_rows= ChooseTransform(transform,new_image_trans.shape,a_i,30,old_centre)\n    \n        new_image = warp(new_image_trans,tform.inverse)\n\n        # Plot image + transform\n        ax[0].imshow(image)\n        ax[0].set_title('Original')\n        \n        ax[1].imshow(new_image)\n        ax[1].set_title('Transformed')\n\n        fig.subplots_adjust(wspace=0, hspace=0)\n        fig.tight_layout()\n        plt.show()\n    \n    \n\n\napp = App(app_ui, server)\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "posts/Mappings2D.html#composite-maps",
    "href": "posts/Mappings2D.html#composite-maps",
    "title": "D’Arcy Thompson and 2D mappings",
    "section": "Composite maps",
    "text": "Composite maps\nWe can build composite maps by using the output image from one transform as the input image for another. In Figure 3 you can explore the effect of combining two transforms successively. This allows for the construction of many interesting final images.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 600\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport skimage as ski\nimport pyodide\nfrom skimage.transform import SimilarityTransform\nfrom skimage.transform import warp\nfrom skimage.transform import PiecewiseAffineTransform\nfrom skimage.transform import AffineTransform\nfrom skimage.io import imread\nimport io\nfrom pathlib import Path\nfrom skimage.transform import resize, rescale\n\ndef ChooseTransform(transform,im_shape,a,num_disc_points,old_centre):\n    rows=im_shape[0]\n    cols=im_shape[1]\n\n    src_cols = np.linspace(0, cols, num_disc_points)\n    src_rows = np.linspace(0, rows, num_disc_points)\n    src_rows, src_cols = np.meshgrid(src_rows, src_cols)\n    src = np.dstack([src_cols.flat, src_rows.flat])[0]\n    dst_rows = src[:, 1] \n    dst_cols = src[:, 0]\n\n    #['Identity','Y stretch','Pinch','Fish eye','Shear','Y squish','Radial']\n    # add sinusoidal oscillation to row coordinates\n    #transform='yscaleDarcy299Fig147'\n    if transform=='Identity':\n        dst_rows = src[:, 1] \n        dst_cols = src[:, 0]\n    elif transform=='Y stretch':\n        yscaleparam=a\n        dst_rows = dst_rows*yscaleparam\n        dst_cols = src[:, 0]\n    elif transform=='Pinch': #'yscaleDarcy299Fig151':\n        sc_factor=a\n        k_x=sc_factor*((dst_cols-cols/2.0)/cols)**1.0+1.0\n        dst_rows = k_x*(dst_rows-rows/2.0)+rows/2.0\n        #dst_cols = src[:, 0]\n    elif transform=='Fish eye': #'yscaleDarcy299Fig149':\n        dst_rows = (dst_rows-rows/2.0)*(2.5-a*((dst_cols-cols/2.0)/(cols/2.0))**2.0)+rows/2.0\n        #dst_cols = (dst_cols-cols/2.0)*(dst_rows-rows/2.0)**2.0+cols/2.0\n\n        #dst_cols = src[:, 0]  \n\n        #dst_cols = src[:, 0]  \n    elif transform=='Shear': #'yscaleDarcy299Fig147':\n        k_y=-a\n        dst_cols = dst_cols+k_y*dst_rows\n        #dst_cols = src[:, 0]    \n    elif transform=='Y squish':\n        L=np.max(dst_rows)\n        dst_rows = (np.log(1.0+a*(dst_rows)/L))*L/np.log(2.0)\n        #dst_cols = src[:, 0]    \n    elif transform=='yscalepower':\n        L=np.max(dst_rows)\n        n=a\n        dst_rows = L*(dst_rows/L)**n\n        #dst_cols = src[:, 0]        \n    elif transform=='Radial':\n        dst_rows_max=np.max(dst_rows)\n        dst_cols_max=np.max(dst_cols)\n\n        centre=[cols/2.0,rows/2.0]\n        radius=np.sqrt((dst_rows-old_centre[0])**2+(dst_cols-old_centre[1])**2)\n        theta=np.arctan2(dst_rows-old_centre[0],dst_cols-old_centre[1])\n\n        R_typical=np.max(centre)\n        radius=R_typical*((radius.astype(float))/R_typical)**a\n        #theta=theta*1.0\n        dst_rows=radius*np.sin(theta)+old_centre[0]\n        dst_cols=radius*np.cos(theta)+old_centre[1]\n\n        #dst_rows=dst_rows/np.max(dst_rows)*dst_rows_max\n        #dst_cols=dst_cols/np.max(dst_cols)*dst_cols_max\n    elif transform =='thetascale':\n        dst_rows_max=np.max(dst_rows)\n        dst_cols_max=np.max(dst_cols)\n\n        radius=(radius.astype(float))**1.25\n        theta=theta*0.25\n        dst_rows=radius*np.sin(theta)+centre[0]\n        dst_cols=radius*np.cos(theta)+centre[1]\n\n\n    elif transform=='sine':\n        dst_rows = src[:, 1] - np.sin(np.linspace(0, 3 * np.pi, src.shape[0])) * 50\n        dst_cols = src[:, 0]\n        dst_rows *= 1.5\n        dst_rows -= 1.5 * 50\n\n\n    \n    dst = np.vstack([dst_cols, dst_rows]).T\n\n\n    # Calculate the corners of the rotated image\n\n\n    tform = PiecewiseAffineTransform()\n    tform.estimate(src, dst)\n\n    return tform, dst,src, rows, cols,dst_cols,dst_rows\n\n\nappdir = Path(__file__).parent\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a1\",label=\"Parameter 1\",min=-3.0,max=3,value=1.0,step=0.16),\n    ui.input_slider(id=\"a2\",label=\"Parameter 2\",min=-3.0,max=3,value=1.0,step=0.16),\n    \n    \n    ui.input_select(id=\"trans1\",label=\"Transform 1\",choices=['Identity','Y stretch','Pinch','Fish eye','Shear','Y squish','Radial'],selected=['Pinch']),\n    ui.input_select(id=\"trans2\",label=\"Transform 2\",choices=['Identity','Y stretch','Pinch','Fish eye','Shear','Y squish','Radial'],selected=['Pinch']),\n    ui.input_file(id='input_file',label='Input file',width='1%',button_label='Upload',accept=['.png,.jpg','jpeg'])                 \n    ,width=3,),\n    ui.panel_main(ui.output_plot(\"plot\")),\n    ),\n)\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    \n\n\n    @reactive.calc\n    def load_image():\n        im_index=1#input.d()\n        #load_image=1\n        if im_index==1:\n            image =  ski.data.coins()\n        image_orig=image[-1:0:-1,:]\n        return image_orig\n\n    @render.plot\n    def plot():\n\n        image= load_image()\n\n        def parsed_file():\n            file: list[FileInfo] | None = input.input_file()\n            if file is None:\n                return pd.DataFrame()\n            \n            return imread(  # pyright: ignore[reportUnknownMemberType]\n            file[0][\"datapath\"])\n\n\n        if input.input_file():\n            image = parsed_file()\n            #image=image[-1:0:-1]\n\n        if len(image.shape)==3:\n            im_num_voxels=float(image.shape[0]*image.shape[1])\n            target_num_voxels=100000.0\n            target_num_voxels=np.min([target_num_voxels,im_num_voxels])\n\n            rescale_factor= target_num_voxels/im_num_voxels\n            image=rescale(image,rescale_factor,channel_axis=2,anti_aliasing=True)\n\n        fig,ax=plt.subplots(1,2,sharey=True,sharex=True)\n\n        # Input parameters\n        a1 =float(input.a1())\n        a2 =float(input.a2())\n\n        trans1 =input.trans1()\n        trans2 =input.trans2()\n        trans=[trans1,trans2]\n\n        old_centre=np.array((image.shape[0]/2.0,image.shape[1]/2.0))\n       \n        trans=[trans1,trans2]\n        a=[a1,a2]\n\n        new_image=image\n        for tranform_i,a_i in zip(trans,a):\n            transform=tranform_i\n            tform,dst,src,rows, cols,dst_cols,dst_rows= ChooseTransform(transform,new_image.shape,a_i,4,old_centre) \n\n            # Find corners\n            corners = np.array([[0, 0], [0, new_image.shape[0]], [new_image.shape[1], 0], [new_image.shape[1], new_image.shape[0]]])\n            tformed_corners = tform(corners)\n\n\n            minc = tformed_corners.min(axis=0)\n            maxc = tformed_corners.max(axis=0)\n\n            # Find dimensions of transformed box\n            output_shape = 2*(np.ceil(maxc)[::-1]-np.ceil(minc)[::-1]).astype(int)\n\n\n            # Calculate the translation required to move all points into positive coordinates\n            min_coords = dst.min(axis=0)\n            translation = -min_coords\n            tform_shift = AffineTransform(translation=translation)\n\n            # Apply the warp with translation to ensure positive coordinates\n            output_shape = (int(rows + 2*translation[1]), int(cols + 2*translation[0]))\n            new_image_trans = warp(new_image, tform_shift.inverse , output_shape=output_shape)\n        \n            # Define transform on new image\n            # Define the forward transform and transform the image\n            tform,dst,src,rows, cols,dst_cols,dst_rows= ChooseTransform(transform,new_image_trans.shape,a_i,30,old_centre)\n       \n            new_image = warp(new_image_trans,tform.inverse)\n\n        # Plot image + transform\n        ax[0].imshow(image)\n        ax[0].set_title('Original')\n        \n        ax[1].imshow(new_image)\n        ax[1].set_title('Composite transformed')\n\n        fig.subplots_adjust(wspace=0, hspace=0)\n        fig.tight_layout()\n        plt.show()\n    \n    \n\n\napp = App(app_ui, server)\n\n\n\n\nFigure 3\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nSuppose we have an image, \\(I\\), and two mappings, \\(f\\) and \\(g\\).\nWe represent transformation of the image via the first transform as\n\\[\nI'=f \\circ I.\n\\]\nApplying the second transform yields \\[\nI''=g\\circ (f \\circ I).\n\\]\nWe might then ask:\n\nis the final image affected by the order in which you perform the transformations (i.e. is \\(f\\circ g = g\\circ f\\))?\ndoes an inverse mapping exist such that any transformation can be reversed via a further transformation? i.e. for a given \\(f\\) can we find a \\(g\\) such that \\[\nI''=g\\circ (f \\circ I)=I.\n\\]\n\nBy understanding whether such properties hold, we can classify different families of mappings and better understand why particular mappings behave the way that they do.\nAt Dundee, concepts from geometry are studied in core modules Maths 1A and Maths 1B.\nAt Level 3 in the module Differential Geometry students study generalisations of 2D mappings to arbitrarily curved spaces.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/TrigonometricIdentities.html",
    "href": "posts/TrigonometricIdentities.html",
    "title": "Trigonometric equations and Fourier series",
    "section": "",
    "text": "Trigonometric functions appear throughout mathematics (e.g. geometry, calculus, differential equations, signal analysis). Here we explore some properties of trigonometric functions with which you might be familiar. Then we take a leap into demonstrating how arbitrary functions can be approximated using sums of trigonometric functions.\n\n\nYou may have encountered trigonometric expressions of the form \\[\na\\sin(x)+b\\cos(x),\n\\tag{1}\\]\nand shown that they can be expressed in the wave-function form \\[\nc\\sin(x+d).\n\\tag{2}\\]\nThis idea is explored in Figure 1: - the individual terms in Equation 1 are plotted using dashed lines for given values of parameters \\(a\\) and \\(b\\).\n- the sum on the right-hand side of Equation 1 is plotted using a dot-dashed line. - Equation 2 is plotted for given values of \\(c\\) and \\(d\\).\nCan you identify values of the parameters \\(c\\) and \\(d\\) such that \\[\nc\\sin(x+d)=a\\sin(x)+b\\cos(x)\n\\] Are these values unique (i.e. is there more than one solution?)\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-5,max=5,value=1.0,step=0.2),\n    ui.input_slider(id=\"b\",label=\"b\",min=-5.0,max=5.0,value=1.0,step=0.2),\n    ui.input_slider(id=\"c\",label=\"c\",min=-5.0,max=10.0,value=5.0,step=0.02),            \n    ui.input_slider(id=\"d\",label=\"d\",min=-5.0,max=10.0,value=5.0,step=0.02),            \n    ),\n    ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        a =float(input.a())\n        b =float(input.b())\n        c =float((input.c()))\n        d =float((input.d()))\n\n        # Define discretised t domain\n        min_x=-10\n        max_x=10\n        x = np.linspace(min_x, max_x, 1000)\n        y_1 = a*np.sin(x)\n        y_2 = b*np.cos(x)\n        y_3=c*np.sin(x+d)\n\n        z=y_1+y_2\n        ax.plot(x, y_1,'--', x,y_2,'--',linewidth=1)\n        ax.plot(x,z,'-.',x,y_3,linewidth=6)\n        \n\n        min_y=-(np.abs(a)+np.abs(b)+np.abs(c))\n        max_y=-min_y\n        ax.set_ylim([min_y,max_y])\n        ax.set_xlim([min_x,max_x])\n        ax.grid(True)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 1: Sum of cosine and sine functions.\n\n\n\n\n\n\nYou may have come across compound angle formulae \\[\n\\sin(a+b)=\\sin(a)\\cos(b)+\\sin(b)\\cos(a)\n\\] and \\[\n\\cos(a+b)=\\cos(a)\\cos(b)-\\sin(a)\\sin(b).\n\\]\nIn Figure 2 you can use the unit circle to visualise why the above identities hold.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\ntitle_str=['All','Sine','Cosine']\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"Angle b\",min=0,max=1.0,value=0.5,step=0.02),\n    ui.input_slider(id=\"b\",label=\"Angle a\",min=0.0,max=1.0,value=0.56,step=0.02),\n    ui.input_select(id=\"c\",label=\"Choose compound angle\",choices=title_str,selected=title_str[0]),           \n    ),\n    ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(figsize=[20,10])\n                \n        a =float(input.a())\n        b =float(input.b())\n        c =(input.c())\n\n        cos_a=np.cos(a)\n        cos_b=np.cos(b)\n        sin_a=np.sin(a)\n        sin_b=np.sin(b)\n\n        cos_apb=np.cos(a+b)\n        sin_apb=np.sin(a+b)\n\n\n        point1=[0.0,0.0]\n        point2=[cos_a*cos_b,cos_a*sin_b]\n        point3=[cos_apb,sin_apb]\n\n        triangle=np.array([point1,point2,point3,point1],dtype=float)\n\n\n        min_point_6=np.min([0.0,cos_apb])\n\n        point4=[min_point_6,0.0]\n        point5=[cos_a*cos_b,0.0]\n        point6=[cos_a*cos_b,sin_apb]\n        point7=[min_point_6,sin_apb]\n\n        rectangle=np.array([point4,point5,point6,point7,point4],dtype=float)\n\n\n        # Define discretised t domain\n     \n        ax.plot(triangle[:,0],triangle[:,1],linewidth=1)\n        ax.plot(rectangle[:,0],rectangle[:,1],linewidth=2)\n\n        ax.text(0.2*np.cos(a/2.0),0.2*np.sin(a/2.0),'a',)\n        ax.text(0.2*np.cos(a+b/2.0),0.2*np.sin(a+b/2.0),'b')\n        ax.text((point2[0]+point3[0])/2.0,(point2[1]+point3[1])/2.0+0.05,'$\\sin(b)$')\n        ax.text(point2[0]/2.0,point2[1]/2.0+0.05,'$\\cos(b)$',rotation=np.arctan2(point2[1],point2[0])/(2.0*np.pi)*360.0)\n        ax.text(cos_apb/2.0,sin_apb/2.0+0.05,'1')\n        \n        c1='b'\n        c2='r'\n        color_map=[c1,c1,c1,c1,c1,c1]\n\n        if c=='Sine':\n            color_map=['r','k','m',c1,c1,c1]\n            ax.plot([point4[0],point7[0]],[point4[1],point7[1]],'r',linewidth=6)\n            ax.plot([point5[0],point2[0]],[point5[1],point2[1]],'m',linewidth=6)\n            ax.plot([point6[0],point2[0]],[point6[1],point2[1]],'k',linewidth=6)\n        elif c=='Cosine':\n            color_map=[c1,c1,c1,'m','r','k']\n            ax.plot([point4[0],point5[0]],[point4[1],point5[1]],'r',linewidth=6)\n            ax.plot([point7[0],point3[0]],[point7[1],point3[1]],'m',linewidth=6)\n            ax.plot([point6[0],point3[0]],[point6[1],point3[1]],'k',linewidth=6)\n\n\n\n        \n       \n        ax.text(min_point_6-0.1,sin_apb/2.0-0.2,'$\\sin(a+b)$',color=color_map[0],rotation='vertical')\n        ax.text(point2[0]+0.05,(point2[1]+point3[1])/2.0,'$\\cos(a)\\sin(b)$',color=color_map[1])\n        ax.text(point2[0]+0.05,point2[1]/2.0,'$\\sin(a)\\cos(b)$',color=color_map[2])\n        ax.text(cos_apb/2.0-0.2,sin_apb+0.05,'$\\cos(a+b)$',color=color_map[3])\n        ax.text(cos_a*cos_b*0.25,-0.2+0.05,'$\\cos(a)\\cos(b)$',color=color_map[4])\n        ax.text((point2[0]+point3[0])/2.0,sin_apb+0.1,'$\\sin(a)\\sin(b)$',color=color_map[5])\n\n        circle1=plt.Circle(( 0.0 , 0.0 ), 1.0,alpha=0.05 )\n        ax.add_patch(circle1)\n\n\n        \n        \n        \n        ax.grid(True)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n        ax.set_xlim([-1.0,1.0])\n        ax.set_ylim([0.0,1.0])\n        plt.xticks([-1.0,0.0,1.0])\n        ax.set_aspect('equal')\n\napp = App(app_ui, server)\n\n\nFigure 2: Compound angle formulae.\n\n\n\n\n\n\nDid you know that many functions, \\(f(x)\\), defined on a domain \\(x\\in[0,L]\\) can be approximated by an infinite sum of sine functions of different frequencies, i.e. \\[\nf(x)\\sim A_1\\sin(k_1x)+A_2\\sin(k_2x)+A_3\\sin(k_3x) + A_4\n\\sin(k_4x) + ...\n\\]\nFor a given function \\(f(x)\\), the coefficients \\(A_0\\), \\(A_1\\) etc. can be chosen so that the sum provides an arbitrarily good approximation to the function.\nIn Figure 3 you can explore approximation to a number of functions that you may have previously encountered.\n\nChoose the linear function f(x)=x. Is the approximation good for \\(N=5\\)? What happens to the approximation as you increase \\(N\\)? Notice that the approximation does not converge to the correct value on the boundary \\(x=L\\). This is known as the Gibbs phenomenon. It is not an error but requires a more detailed study of Fourier series to understand!\nConsider the sawtooth function. Compare the accuracy of the series aproximation at the boundary \\(x=L\\) between the functions \\(f(x)=x\\) and the sawtooth function. Note that the approximation now appears to be converging to the value of \\(f\\) on the boundary \\(x=L\\).\nConsider the exponential function. Note that many more terms are needed in the expansion to obtain a reasonable level of accuracy.\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\ntitle_str=['x','sawtooth','x^2','x^2-2x+1','exp(x)','tan(x)',]\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_select(id=\"fun\",label=\"Choose f(x)\",choices=title_str,selected=[\"x\"]),\n    ui.input_slider(id=\"L\",label=\"L (domain length)\",min=1.0,max=20.0,value=10.0,step=1.0), \n    ui.input_slider(id=\"N\",label=\"N (num. terms in series)\",min=1,max=500,value=10,step=1),          \n    ),\n    ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        fun =(input.fun())\n        N =int(input.N())\n        L =float(input.L())\n\n        # Define discretised t domain\n   \n        x = np.linspace(0.0, L, 10000)\n        if fun == 'x':\n            f=x\n        elif fun == 'x^2':\n            f=x**2\n        elif fun=='x^2-2x+1':\n            f=x**2-2*x+1\n        elif fun=='exp(x)':\n            f=np.exp(x)\n        elif fun=='tan(x)':\n            f=np.tan(x)\n        elif fun=='sawtooth':\n            f=np.mod(x*5,L)\n\n        sum=0\n        for i in range(N+1):\n            k_i=i*np.pi/L\n\n            basis_fun=np.sin(k_i*x)\n            A_i= 2.0/L*np.trapz(f*basis_fun,x)\n            term_i=A_i*np.sin(k_i*x)\n            sum+=term_i \n\n        y_2 = sum\n\n        ax.plot(x, f,'--', x,y_2,'--')\n        \n\n        #min_y=-(np.abs(a)+np.abs(b)+np.abs(c))\n        #max_y=-min_y\n\n        min_y=np.max([np.min(f),-200.0])\n        max_y=np.min([np.max(f),200.0])\n\n        ax.set_ylim([min_y,max_y])\n        #ax.set_xlim([min_x,max_x])\n        ax.grid(True)\n        ax.legend(['f(x)','Approximation'])\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 3: Approximating a function as a sum of sinusoids.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, concepts from trigonometry are studies in core module Maths 1A and Maths 1B.\nAt Level 3 in the module Differential Equations Fourier series are introduced and used to study the solution of partial differential equations.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/TrigonometricIdentities.html#wave-function-forms",
    "href": "posts/TrigonometricIdentities.html#wave-function-forms",
    "title": "Trigonometric equations and Fourier series",
    "section": "",
    "text": "You may have encountered trigonometric expressions of the form \\[\na\\sin(x)+b\\cos(x),\n\\tag{1}\\]\nand shown that they can be expressed in the wave-function form \\[\nc\\sin(x+d).\n\\tag{2}\\]\nThis idea is explored in Figure 1: - the individual terms in Equation 1 are plotted using dashed lines for given values of parameters \\(a\\) and \\(b\\).\n- the sum on the right-hand side of Equation 1 is plotted using a dot-dashed line. - Equation 2 is plotted for given values of \\(c\\) and \\(d\\).\nCan you identify values of the parameters \\(c\\) and \\(d\\) such that \\[\nc\\sin(x+d)=a\\sin(x)+b\\cos(x)\n\\] Are these values unique (i.e. is there more than one solution?)\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-5,max=5,value=1.0,step=0.2),\n    ui.input_slider(id=\"b\",label=\"b\",min=-5.0,max=5.0,value=1.0,step=0.2),\n    ui.input_slider(id=\"c\",label=\"c\",min=-5.0,max=10.0,value=5.0,step=0.02),            \n    ui.input_slider(id=\"d\",label=\"d\",min=-5.0,max=10.0,value=5.0,step=0.02),            \n    ),\n    ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        a =float(input.a())\n        b =float(input.b())\n        c =float((input.c()))\n        d =float((input.d()))\n\n        # Define discretised t domain\n        min_x=-10\n        max_x=10\n        x = np.linspace(min_x, max_x, 1000)\n        y_1 = a*np.sin(x)\n        y_2 = b*np.cos(x)\n        y_3=c*np.sin(x+d)\n\n        z=y_1+y_2\n        ax.plot(x, y_1,'--', x,y_2,'--',linewidth=1)\n        ax.plot(x,z,'-.',x,y_3,linewidth=6)\n        \n\n        min_y=-(np.abs(a)+np.abs(b)+np.abs(c))\n        max_y=-min_y\n        ax.set_ylim([min_y,max_y])\n        ax.set_xlim([min_x,max_x])\n        ax.grid(True)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 1: Sum of cosine and sine functions."
  },
  {
    "objectID": "posts/TrigonometricIdentities.html#compound-angle-identities",
    "href": "posts/TrigonometricIdentities.html#compound-angle-identities",
    "title": "Trigonometric equations and Fourier series",
    "section": "",
    "text": "You may have come across compound angle formulae \\[\n\\sin(a+b)=\\sin(a)\\cos(b)+\\sin(b)\\cos(a)\n\\] and \\[\n\\cos(a+b)=\\cos(a)\\cos(b)-\\sin(a)\\sin(b).\n\\]\nIn Figure 2 you can use the unit circle to visualise why the above identities hold.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\ntitle_str=['All','Sine','Cosine']\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"Angle b\",min=0,max=1.0,value=0.5,step=0.02),\n    ui.input_slider(id=\"b\",label=\"Angle a\",min=0.0,max=1.0,value=0.56,step=0.02),\n    ui.input_select(id=\"c\",label=\"Choose compound angle\",choices=title_str,selected=title_str[0]),           \n    ),\n    ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(figsize=[20,10])\n                \n        a =float(input.a())\n        b =float(input.b())\n        c =(input.c())\n\n        cos_a=np.cos(a)\n        cos_b=np.cos(b)\n        sin_a=np.sin(a)\n        sin_b=np.sin(b)\n\n        cos_apb=np.cos(a+b)\n        sin_apb=np.sin(a+b)\n\n\n        point1=[0.0,0.0]\n        point2=[cos_a*cos_b,cos_a*sin_b]\n        point3=[cos_apb,sin_apb]\n\n        triangle=np.array([point1,point2,point3,point1],dtype=float)\n\n\n        min_point_6=np.min([0.0,cos_apb])\n\n        point4=[min_point_6,0.0]\n        point5=[cos_a*cos_b,0.0]\n        point6=[cos_a*cos_b,sin_apb]\n        point7=[min_point_6,sin_apb]\n\n        rectangle=np.array([point4,point5,point6,point7,point4],dtype=float)\n\n\n        # Define discretised t domain\n     \n        ax.plot(triangle[:,0],triangle[:,1],linewidth=1)\n        ax.plot(rectangle[:,0],rectangle[:,1],linewidth=2)\n\n        ax.text(0.2*np.cos(a/2.0),0.2*np.sin(a/2.0),'a',)\n        ax.text(0.2*np.cos(a+b/2.0),0.2*np.sin(a+b/2.0),'b')\n        ax.text((point2[0]+point3[0])/2.0,(point2[1]+point3[1])/2.0+0.05,'$\\sin(b)$')\n        ax.text(point2[0]/2.0,point2[1]/2.0+0.05,'$\\cos(b)$',rotation=np.arctan2(point2[1],point2[0])/(2.0*np.pi)*360.0)\n        ax.text(cos_apb/2.0,sin_apb/2.0+0.05,'1')\n        \n        c1='b'\n        c2='r'\n        color_map=[c1,c1,c1,c1,c1,c1]\n\n        if c=='Sine':\n            color_map=['r','k','m',c1,c1,c1]\n            ax.plot([point4[0],point7[0]],[point4[1],point7[1]],'r',linewidth=6)\n            ax.plot([point5[0],point2[0]],[point5[1],point2[1]],'m',linewidth=6)\n            ax.plot([point6[0],point2[0]],[point6[1],point2[1]],'k',linewidth=6)\n        elif c=='Cosine':\n            color_map=[c1,c1,c1,'m','r','k']\n            ax.plot([point4[0],point5[0]],[point4[1],point5[1]],'r',linewidth=6)\n            ax.plot([point7[0],point3[0]],[point7[1],point3[1]],'m',linewidth=6)\n            ax.plot([point6[0],point3[0]],[point6[1],point3[1]],'k',linewidth=6)\n\n\n\n        \n       \n        ax.text(min_point_6-0.1,sin_apb/2.0-0.2,'$\\sin(a+b)$',color=color_map[0],rotation='vertical')\n        ax.text(point2[0]+0.05,(point2[1]+point3[1])/2.0,'$\\cos(a)\\sin(b)$',color=color_map[1])\n        ax.text(point2[0]+0.05,point2[1]/2.0,'$\\sin(a)\\cos(b)$',color=color_map[2])\n        ax.text(cos_apb/2.0-0.2,sin_apb+0.05,'$\\cos(a+b)$',color=color_map[3])\n        ax.text(cos_a*cos_b*0.25,-0.2+0.05,'$\\cos(a)\\cos(b)$',color=color_map[4])\n        ax.text((point2[0]+point3[0])/2.0,sin_apb+0.1,'$\\sin(a)\\sin(b)$',color=color_map[5])\n\n        circle1=plt.Circle(( 0.0 , 0.0 ), 1.0,alpha=0.05 )\n        ax.add_patch(circle1)\n\n\n        \n        \n        \n        ax.grid(True)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n        ax.set_xlim([-1.0,1.0])\n        ax.set_ylim([0.0,1.0])\n        plt.xticks([-1.0,0.0,1.0])\n        ax.set_aspect('equal')\n\napp = App(app_ui, server)\n\n\nFigure 2: Compound angle formulae."
  },
  {
    "objectID": "posts/TrigonometricIdentities.html#fourier-series",
    "href": "posts/TrigonometricIdentities.html#fourier-series",
    "title": "Trigonometric equations and Fourier series",
    "section": "",
    "text": "Did you know that many functions, \\(f(x)\\), defined on a domain \\(x\\in[0,L]\\) can be approximated by an infinite sum of sine functions of different frequencies, i.e. \\[\nf(x)\\sim A_1\\sin(k_1x)+A_2\\sin(k_2x)+A_3\\sin(k_3x) + A_4\n\\sin(k_4x) + ...\n\\]\nFor a given function \\(f(x)\\), the coefficients \\(A_0\\), \\(A_1\\) etc. can be chosen so that the sum provides an arbitrarily good approximation to the function.\nIn Figure 3 you can explore approximation to a number of functions that you may have previously encountered.\n\nChoose the linear function f(x)=x. Is the approximation good for \\(N=5\\)? What happens to the approximation as you increase \\(N\\)? Notice that the approximation does not converge to the correct value on the boundary \\(x=L\\). This is known as the Gibbs phenomenon. It is not an error but requires a more detailed study of Fourier series to understand!\nConsider the sawtooth function. Compare the accuracy of the series aproximation at the boundary \\(x=L\\) between the functions \\(f(x)=x\\) and the sawtooth function. Note that the approximation now appears to be converging to the value of \\(f\\) on the boundary \\(x=L\\).\nConsider the exponential function. Note that many more terms are needed in the expansion to obtain a reasonable level of accuracy.\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\ntitle_str=['x','sawtooth','x^2','x^2-2x+1','exp(x)','tan(x)',]\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_select(id=\"fun\",label=\"Choose f(x)\",choices=title_str,selected=[\"x\"]),\n    ui.input_slider(id=\"L\",label=\"L (domain length)\",min=1.0,max=20.0,value=10.0,step=1.0), \n    ui.input_slider(id=\"N\",label=\"N (num. terms in series)\",min=1,max=500,value=10,step=1),          \n    ),\n    ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        fun =(input.fun())\n        N =int(input.N())\n        L =float(input.L())\n\n        # Define discretised t domain\n   \n        x = np.linspace(0.0, L, 10000)\n        if fun == 'x':\n            f=x\n        elif fun == 'x^2':\n            f=x**2\n        elif fun=='x^2-2x+1':\n            f=x**2-2*x+1\n        elif fun=='exp(x)':\n            f=np.exp(x)\n        elif fun=='tan(x)':\n            f=np.tan(x)\n        elif fun=='sawtooth':\n            f=np.mod(x*5,L)\n\n        sum=0\n        for i in range(N+1):\n            k_i=i*np.pi/L\n\n            basis_fun=np.sin(k_i*x)\n            A_i= 2.0/L*np.trapz(f*basis_fun,x)\n            term_i=A_i*np.sin(k_i*x)\n            sum+=term_i \n\n        y_2 = sum\n\n        ax.plot(x, f,'--', x,y_2,'--')\n        \n\n        #min_y=-(np.abs(a)+np.abs(b)+np.abs(c))\n        #max_y=-min_y\n\n        min_y=np.max([np.min(f),-200.0])\n        max_y=np.min([np.max(f),200.0])\n\n        ax.set_ylim([min_y,max_y])\n        #ax.set_xlim([min_x,max_x])\n        ax.grid(True)\n        ax.legend(['f(x)','Approximation'])\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 3: Approximating a function as a sum of sinusoids.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, concepts from trigonometry are studies in core module Maths 1A and Maths 1B.\nAt Level 3 in the module Differential Equations Fourier series are introduced and used to study the solution of partial differential equations.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/MonteCarloIntegration.html",
    "href": "posts/MonteCarloIntegration.html",
    "title": "Monte Carlo Integration",
    "section": "",
    "text": "You may have previously come across definite integrals of the form\n\\[\nI=\\int_a^b f(x)\\mathrm{d}x.\n\\]\nA specific example is \\[\n\\int_0^1 x^2 \\mathrm{d}x.\n\\]\nIf you have not yet come across definite integrals that is fine. For the purposes of this page, the value of the integral is simply the area underneath the curve (see blue shaded region in Figure 1).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nTo compute the integral we can use a similar method to that used for estimating \\(\\pi\\):\n\ncircumscribe the region to be integrated within a domain of known area (e.g. see rectangle in Figure 2)\nuniformly sample points within the larger domain\ncount the fraction of points that lie in the shaded region\nthe value of the integral can be approximated by \\[\n\\hat{I} \\sim \\textrm{Area of Rectangle} * \\textrm{Fraction of sampled points in target region}\n\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nIn Figure 3 you can use a Monte Carlo method to approximate many common integrals. Table 1 provides the syntax needed for available functions.\n\n\n\nTable 1: Syntax for inputting elementary functions into the integrator in Figure 3.\n\n\n\n\n\nIntegrand\nInput text\n\n\n\n\n\\(\\sqrt{x}\\)\nsqrt(x)\n\n\n\\(\\sin{x}\\)\nsin(x)\n\n\n\\(\\cos{x}\\)\ncos(x)\n\n\n\\(\\ln{x}\\)\nlog(x)\n\n\n\\(x^2\\)\nx^2\n\n\n\\(e^x\\)\nexp(x)\n\n\n\\(\\pi\\)\npi\n\n\n\n\n\n\nIn Table 2 some examples are provided that demonstrate syntax for more complicated functions.\nIn the top plot in Figure 3 the distribution of sampled points is plotted for the selected parameter values. In the bottom plot the estimate of the integral is averaged over 100 realisations and plotted against the number of sampled points, \\(N\\).\n\n\n\nTable 2: Examples of syntax for inputting more complex functions into the integrator in Figure 3.\n\n\n\n\n\nIntegrand\nInput text\n\n\n\n\n\\(x^2+2x+1\\)\nx^2+2*x+1\n\n\n\\(e^{-\\sin^2{x}}\\)\nexp(-sin(x)*sin(x))\n\n\n\n\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"N\",label=\"N\",min=10,max=3000,value=10,step=1),\n    ui.input_slider(id=\"a\",label=\"a\",min=0.0,max=3.0,value=0.0,step=0.01),\n    ui.input_slider(id=\"b\",label=\"b\",min=1.0,max=10.0,value=1.0,step=0.01), \n    ui.input_text(id='text',label=\"Integrand as function of x\",value=\"sin(x)\")            \n     \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def function_f(x,text):\n\n        #f=np.sin(4*x)\n        f=np.sin(10*x)\n\n        f=parse_to_numpy_function(text,x)\n\n\n        return f\n\n    def parse_to_numpy_function(expression,x):\n        # Replace common mathematical operators with NumPy equivalents\n        expression = expression.replace(\"^\", \"**\")  # Replace '^' with '**'\n        expression = expression.replace(\"sin\", \"np.sin\")\n        expression = expression.replace(\"cos\", \"np.cos\")\n        expression = expression.replace(\"tan\", \"np.tan\")\n        expression = expression.replace(\"log\", \"np.log\")\n        expression = expression.replace(\"sqrt\", \"np.sqrt\")\n        expression = expression.replace(\"exp\", \"np.exp\")\n        expression = expression.replace(\"pi\", \"np.pi\")\n\n        # Create a lambda function for safe evaluation\n        #def numpy_function(x):\n        return eval(expression)\n    \n        #return expression\n\n\n    def estimate_int(a,b,N,text): \n        x = np.random.uniform(a,b,N)\n\n        f=function_f(x,text)\n        \n        max_f=np.max(f)\n        min_f=np.min(f)\n\n        y = np.random.uniform(min_f,max_f,N)\n\n        \n        num_points_inside_circle=len(y[(y&gt;0)&(y&lt;=f)])-len(y[(y&lt;0)&(y&gt;=f)])\n\n        int_est=(b-a)*(max_f-min_f)*num_points_inside_circle/N\n\n        return x,y,int_est\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(2,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        N=int(input.N())\n        a=float(input.a())\n        b=float(input.b())\n        text=input.text()\n\n        \n        \n        \n    \n        x,y,int_est=estimate_int(a,b,N,text)\n        \n        ax[0].plot(x[(y&gt;0)&(y&lt;function_f(x,text))],y[(y&gt;0)&(y&lt;function_f(x,text))],'b.')\n        ax[0].plot(x[(y&lt;0)&(y&gt;function_f(x,text))],y[(y&lt;0)&(y&gt;function_f(x,text))],'m.')\n        ax[0].plot(x[(y&gt;0)&(y&gt;function_f(x,text))],y[(y&gt;0)&(y&gt;function_f(x,text))],'k.')\n        ax[0].plot(x[(y&lt;0)&(y&lt;function_f(x,text))],y[(y&lt;0)&(y&lt;function_f(x,text))],'k.')\n        #ax[0].plot(x[(y&gt;0)&(y&gt;function_f(x))],y[(y&gt;0)&(y&gt;function_f(x))],'k.')\n\n        ax[0].set_xlabel('$x$')\n        ax[0].set_ylabel('$y$')\n\n        x_plot=np.linspace(a,b,1000,dtype=float)\n        y_plot=function_f(x_plot,text)\n        ax[0].plot(x_plot,y_plot,'r')\n        ax[0].set_title('$\\hat{I}$='+str(int_est))\n\n        \n        N_vec=np.linspace(10,3000,80,dtype=int)\n        int_est_vec=np.zeros_like(N_vec,dtype=float)\n        n_samples=200\n        for i in range(len(N_vec)):\n            int_est_i=np.zeros((n_samples,1),dtype=float)\n            for j in range(n_samples):\n                x,y,int_est=estimate_int(a,b,N_vec[i],text)\n                int_est_i[j]=int_est\n            int_est_vec[i]=np.median(int_est_i)\n\n        ax[1].plot(N_vec,int_est_vec,'.')\n        ax[1].set_xlabel('$N$')\n        ax[1].set_ylabel('$\\hat{I}$')\n\n        fig.tight_layout()\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 3\n\n\n\nExercises using the app:\n\nShow that \\[\n   \\int_0^{1}x^2 \\mathrm{d}x =\\frac{1}{3}.\n\\]\nEstimate the integral\n\\[\n\\int_0^3 \\frac{\\sin(x)\\sin(x)\\sin(x)}{1+x^2} \\texrm{d}x.\n\\]\nDemonstrate that \\[\n   \\int_0^{\\infty}e^{-x^2}\\mathrm{d}x =\\frac{\\sqrt{\\pi}}{2}\n  \\] Note that this calculation provides an alternative method to estimate \\(\\pi\\)!\nEstimate the integral \\[\n   \\int_0^{1}\\frac{x^2}{1+x^2}\\mathrm{d}x.\n  \\]\nDemonstrate that \\[\n   \\int_0^{\\pi}\\sin(x) \\mathrm{d}x\\sim 2\n  \\]\nDemonstrate that \\[\n   \\int_0^{2\\pi}\\sin(x) \\mathrm{d}x\\sim 0\n  \\] Can you spot how the symmetry results in cancellation of the positive (blue) and negative (magenta) contributions?\n\n\n\n\n\n\n\nWarning\n\n\n\n\nThe algorithm implemented in Figure 3 above will always provide a numerical estimate. However, some functions are not integrable. In this case the numerical estimate provided by the app will be completely incorrect. We must understand the limitations of algorithms before trusting their output!\nThere exist functions that are integrable but cannot be estimated using the above technique. We cannot rely solely on algorithms.\nHow do we know how accurate the integral estimate is?\nThere exist much more computationally efficient methods for estimating integrals to a given accuracy.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from integration are introduced in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nIn the modules Introduction to Programming and Computer Algebra and Dynamical systems you would be introduced to techniques that enable you to perform numerical integration.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/MonteCarloIntegration.html#integration",
    "href": "posts/MonteCarloIntegration.html#integration",
    "title": "Monte Carlo Integration",
    "section": "",
    "text": "You may have previously come across definite integrals of the form\n\\[\nI=\\int_a^b f(x)\\mathrm{d}x.\n\\]\nA specific example is \\[\n\\int_0^1 x^2 \\mathrm{d}x.\n\\]\nIf you have not yet come across definite integrals that is fine. For the purposes of this page, the value of the integral is simply the area underneath the curve (see blue shaded region in Figure 1).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nTo compute the integral we can use a similar method to that used for estimating \\(\\pi\\):\n\ncircumscribe the region to be integrated within a domain of known area (e.g. see rectangle in Figure 2)\nuniformly sample points within the larger domain\ncount the fraction of points that lie in the shaded region\nthe value of the integral can be approximated by \\[\n\\hat{I} \\sim \\textrm{Area of Rectangle} * \\textrm{Fraction of sampled points in target region}\n\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nIn Figure 3 you can use a Monte Carlo method to approximate many common integrals. Table 1 provides the syntax needed for available functions.\n\n\n\nTable 1: Syntax for inputting elementary functions into the integrator in Figure 3.\n\n\n\n\n\nIntegrand\nInput text\n\n\n\n\n\\(\\sqrt{x}\\)\nsqrt(x)\n\n\n\\(\\sin{x}\\)\nsin(x)\n\n\n\\(\\cos{x}\\)\ncos(x)\n\n\n\\(\\ln{x}\\)\nlog(x)\n\n\n\\(x^2\\)\nx^2\n\n\n\\(e^x\\)\nexp(x)\n\n\n\\(\\pi\\)\npi\n\n\n\n\n\n\nIn Table 2 some examples are provided that demonstrate syntax for more complicated functions.\nIn the top plot in Figure 3 the distribution of sampled points is plotted for the selected parameter values. In the bottom plot the estimate of the integral is averaged over 100 realisations and plotted against the number of sampled points, \\(N\\).\n\n\n\nTable 2: Examples of syntax for inputting more complex functions into the integrator in Figure 3.\n\n\n\n\n\nIntegrand\nInput text\n\n\n\n\n\\(x^2+2x+1\\)\nx^2+2*x+1\n\n\n\\(e^{-\\sin^2{x}}\\)\nexp(-sin(x)*sin(x))\n\n\n\n\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"N\",label=\"N\",min=10,max=3000,value=10,step=1),\n    ui.input_slider(id=\"a\",label=\"a\",min=0.0,max=3.0,value=0.0,step=0.01),\n    ui.input_slider(id=\"b\",label=\"b\",min=1.0,max=10.0,value=1.0,step=0.01), \n    ui.input_text(id='text',label=\"Integrand as function of x\",value=\"sin(x)\")            \n     \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def function_f(x,text):\n\n        #f=np.sin(4*x)\n        f=np.sin(10*x)\n\n        f=parse_to_numpy_function(text,x)\n\n\n        return f\n\n    def parse_to_numpy_function(expression,x):\n        # Replace common mathematical operators with NumPy equivalents\n        expression = expression.replace(\"^\", \"**\")  # Replace '^' with '**'\n        expression = expression.replace(\"sin\", \"np.sin\")\n        expression = expression.replace(\"cos\", \"np.cos\")\n        expression = expression.replace(\"tan\", \"np.tan\")\n        expression = expression.replace(\"log\", \"np.log\")\n        expression = expression.replace(\"sqrt\", \"np.sqrt\")\n        expression = expression.replace(\"exp\", \"np.exp\")\n        expression = expression.replace(\"pi\", \"np.pi\")\n\n        # Create a lambda function for safe evaluation\n        #def numpy_function(x):\n        return eval(expression)\n    \n        #return expression\n\n\n    def estimate_int(a,b,N,text): \n        x = np.random.uniform(a,b,N)\n\n        f=function_f(x,text)\n        \n        max_f=np.max(f)\n        min_f=np.min(f)\n\n        y = np.random.uniform(min_f,max_f,N)\n\n        \n        num_points_inside_circle=len(y[(y&gt;0)&(y&lt;=f)])-len(y[(y&lt;0)&(y&gt;=f)])\n\n        int_est=(b-a)*(max_f-min_f)*num_points_inside_circle/N\n\n        return x,y,int_est\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(2,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        N=int(input.N())\n        a=float(input.a())\n        b=float(input.b())\n        text=input.text()\n\n        \n        \n        \n    \n        x,y,int_est=estimate_int(a,b,N,text)\n        \n        ax[0].plot(x[(y&gt;0)&(y&lt;function_f(x,text))],y[(y&gt;0)&(y&lt;function_f(x,text))],'b.')\n        ax[0].plot(x[(y&lt;0)&(y&gt;function_f(x,text))],y[(y&lt;0)&(y&gt;function_f(x,text))],'m.')\n        ax[0].plot(x[(y&gt;0)&(y&gt;function_f(x,text))],y[(y&gt;0)&(y&gt;function_f(x,text))],'k.')\n        ax[0].plot(x[(y&lt;0)&(y&lt;function_f(x,text))],y[(y&lt;0)&(y&lt;function_f(x,text))],'k.')\n        #ax[0].plot(x[(y&gt;0)&(y&gt;function_f(x))],y[(y&gt;0)&(y&gt;function_f(x))],'k.')\n\n        ax[0].set_xlabel('$x$')\n        ax[0].set_ylabel('$y$')\n\n        x_plot=np.linspace(a,b,1000,dtype=float)\n        y_plot=function_f(x_plot,text)\n        ax[0].plot(x_plot,y_plot,'r')\n        ax[0].set_title('$\\hat{I}$='+str(int_est))\n\n        \n        N_vec=np.linspace(10,3000,80,dtype=int)\n        int_est_vec=np.zeros_like(N_vec,dtype=float)\n        n_samples=200\n        for i in range(len(N_vec)):\n            int_est_i=np.zeros((n_samples,1),dtype=float)\n            for j in range(n_samples):\n                x,y,int_est=estimate_int(a,b,N_vec[i],text)\n                int_est_i[j]=int_est\n            int_est_vec[i]=np.median(int_est_i)\n\n        ax[1].plot(N_vec,int_est_vec,'.')\n        ax[1].set_xlabel('$N$')\n        ax[1].set_ylabel('$\\hat{I}$')\n\n        fig.tight_layout()\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 3\n\n\n\nExercises using the app:\n\nShow that \\[\n   \\int_0^{1}x^2 \\mathrm{d}x =\\frac{1}{3}.\n\\]\nEstimate the integral\n\\[\n\\int_0^3 \\frac{\\sin(x)\\sin(x)\\sin(x)}{1+x^2} \\texrm{d}x.\n\\]\nDemonstrate that \\[\n   \\int_0^{\\infty}e^{-x^2}\\mathrm{d}x =\\frac{\\sqrt{\\pi}}{2}\n  \\] Note that this calculation provides an alternative method to estimate \\(\\pi\\)!\nEstimate the integral \\[\n   \\int_0^{1}\\frac{x^2}{1+x^2}\\mathrm{d}x.\n  \\]\nDemonstrate that \\[\n   \\int_0^{\\pi}\\sin(x) \\mathrm{d}x\\sim 2\n  \\]\nDemonstrate that \\[\n   \\int_0^{2\\pi}\\sin(x) \\mathrm{d}x\\sim 0\n  \\] Can you spot how the symmetry results in cancellation of the positive (blue) and negative (magenta) contributions?\n\n\n\n\n\n\n\nWarning\n\n\n\n\nThe algorithm implemented in Figure 3 above will always provide a numerical estimate. However, some functions are not integrable. In this case the numerical estimate provided by the app will be completely incorrect. We must understand the limitations of algorithms before trusting their output!\nThere exist functions that are integrable but cannot be estimated using the above technique. We cannot rely solely on algorithms.\nHow do we know how accurate the integral estimate is?\nThere exist much more computationally efficient methods for estimating integrals to a given accuracy.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from integration are introduced in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nIn the modules Introduction to Programming and Computer Algebra and Dynamical systems you would be introduced to techniques that enable you to perform numerical integration.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/QuadraticCubicRoots.html",
    "href": "posts/QuadraticCubicRoots.html",
    "title": "Roots of quadratic/cubic equations",
    "section": "",
    "text": "Roots of quadratic and cubic equations\nConsider the cubic equation \\[\nax^3+bx^2+cx+d=0, \\ \\ \\quad a,b,c, d \\in \\Re.\n\\tag{1}\\]\nA special case you may have seen before occurs when \\(a=0\\). Hence \\[\nbx^2+cx+d=0.\n\\]\nIn this case the roots of the quadratic are \\[\nx=\\frac{-c\\pm\\sqrt{c^2-4bd}}{2b}.\n\\]\nIn the app in Figure 1 you can play with the parameter \\(a\\), \\(b\\), \\(c\\) and \\(d\\) and explore how they affect the form of the cubic equation Equation 1.\n\n\n\n\n\n\nTip\n\n\n\nPlease note that the app in Figure 1 is approximately 20 MB. If it does not display on your device:\n\nwait a few moments (it is downloading the Python code that will run the app)\nrefresh your browser.\n\ntry running on a faster connection/ more powerful device.\n\nIf it still does not load, here is a screenshot.\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-5,max=5,value=1.0,step=0.1),\n    ui.input_slider(id=\"b\",label=\"b\",min=-5.0,max=5.0,value=1.0,step=0.1),\n    ui.input_slider(id=\"c\",label=\"c\",min=-5.0,max=10.0,value=5.0,step=0.1),            \n    ui.input_slider(id=\"d\",label=\"d\",min=-5.0,max=10.0,value=5.0,step=0.1),            \n    ui.input_slider(id=\"min_x\",label=\"Min x \",min=-10.0,max=10.0,value=-5.0,step=0.1),  \n    ui.input_slider(id=\"max_x\",label=\"Max x\",min=-10.0,max=10.0,value=5.0,step=0.1),\n        \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        c=float((input.c()))\n        d=float((input.d()))\n\n        min_x=float(input.min_x())\n        max_x=float(input.max_x())\n\n        \n        # Define rhs of LV ODEs\n        def rhs(x,a,b,c,d):\n          rhs=np.zeros_like(x,dtype=float)\n          rhs=a*x**3+b*x**2+c*x+d\n\n          return rhs\n\n        # Define discretised t domain\n        x = np.linspace(min_x, max_x, 1000)\n\n        # define initial conditions\n        \n        # Compute numerical solution of ODEs\n        y = rhs(x,a,b,c,d)\n\n        coeff=[a,b,c,d]\n        roots=np.roots(coeff)\n\n        roots=np.round(roots,2)\n        ax.plot(x, y,np.real(roots),np.zeros_like(np.real(roots)),'rx')\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n        y_lim_p=-15.0 #np.min([100,np.max(y)])\n        y_lim_m=15.0 #np.max([-100,np.min(y)])\n\n        ax.set_ylim([y_lim_m,y_lim_p])\n        ax.invert_yaxis()\n        ax.grid()\n\n        text_x=0.25*(min_x+max_x)\n        text_y=np.mean(y)\n        #title_Str= = ' '.join(map(str, (roots)))\n        title_Str=[(\"R\"+ str(j) +\" = \" + str(roots[j]) ) for j in range(len(roots))]\n        title_Str = str(title_Str)[1:-1]\n\n        ax.set_title(title_Str)\n        #ax.set_title([(\"R\"+ str(j) +\" = \" + str(roots[j]) ) for j in range(len(roots))])\n\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1: Plot of a cubic function. The roots of the cubic are reported in the figure title. The red crosses depict the real parts of the roots.\n\n\n\n\n\nExercises\n\nset \\(a=0\\).\n\nhow many roots are there?\nhow does the local maximum/minimum of the quadratic depend on the sign of the parameter \\(b\\)?\nwhy are there complex roots when the condition \\(c^2-4bd&lt;0\\) is satisfied?\n\nconsider the case where \\(a&gt;0\\).\n\nhow many real roots are there?\ndemonstrate that there is always a trivial root (\\(x=0\\)) in the case \\(d=0\\).\ndemonstrate that in the case \\(a=d=1\\) with \\(b=c=0\\) the cubic takes the reduced form \\[\n  x^3=-1.\n\\] Can you show that the roots are \\(-1\\), \\(\\frac{1+j\\sqrt{3}}{2}\\), \\(\\frac{1-j\\sqrt{3}}{2}\\) where \\(j=\\sqrt{-1}\\).\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, you will develop your knowledge in algebra in modules\n\nMaths 1A\nMaths 1B\nMaths 2A\nMaths 2B\n\nAt Levels 2, 3 and 4 you will learn how to use computer programming to explore and communicate mathematical concepts.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/RecurrenceRelations.html",
    "href": "posts/RecurrenceRelations.html",
    "title": "Recurrence relations and chaos",
    "section": "",
    "text": "You might have previously encountered a recurrence relation of the form\n\\[\nu_{n+1}=au_n+b\n\\tag{1}\\] where \\(a\\) and \\(b\\) are constants.\nGiven numerical values for \\(a\\) and \\(b\\) and an initial condition, \\(u_0\\), a sequence can be computed that is a solution to Equation 1. This type of task is laborious and well suited to a computer (see Figure 1).\n\n\n\n\n\n\nA typical Higher-like question\n\n\n\nThe population of Dundonian hobbits is observed to be declining by 5% per year. To increase the population, it is planned that 1000 of the species will be released at the end of May each year.\nLet \\(u_n\\) represent the population of the hobbits at the beginning of June, \\(n\\) years after the first annual reintroduction into the population.\nSuppose that \\(u_n\\) and \\(u_{n+1}\\) satisfy the recurrence relation \\[\nu_{n+1}=au_n+b,\n\\] where \\(a\\) and \\(b\\) are constants.\n\nState the values of \\(a\\) and \\(b\\).\nExplain whether or not the population of the Dundonian hobbit will stabilise in the long term.\nThe population of Dundonian hobbits at the beginning of the reintroduction programme was estimated at 5000. Explain whether or not the population will ever exceed 10000.\n\n\n\nExplore how the computed solution depend on model parameters as follows:\n\nset \\(b=0\\) by varying the parameter \\(a\\) identify solutions that:\n\ntend to zero monotonically\noscillate about 0\nblow up\n\nset b&gt;0\n\nshow that the solution converges to a non-zero value in the case where \\(0&lt;a&lt;1\\).\nshow that the solution is oscillatory for \\(-1&lt;a&lt;0\\).\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-1.0,max=3,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=15.0,value=10.0,step=0.01),             \n     \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=20.0,value=5.0,step=1.0),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n              \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        u0=float(input.u0())\n        T=int(input.T())\n       \n        # Define rhs of LV ODEs\n        def rhs_pop_model(y,t,a,b):\n          \n\n          rhs=a*y+b\n\n          return rhs\n        def DiscreteSol(rhs_pop_model,y_0,t,a,b):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n                    y[i]=rhs_pop_model(y[i-1],t[i],a,b)\n            return y\n\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(rhs_pop_model,init_cond,t,a,b)\n\n        # Plot results\n        y=sol1\n        \n        ax.plot(t,y)\n        ax.set_xlabel('$n$')\n        ax.set_ylabel('$u_n$')\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1\n\n\n\n\n\n\nThe recurrence relation explored in Figure 1 is linear (the right-hand-side is a linear function of \\(u_n\\)). When the model is generalised much richer dynamical behaviours can be observed. One famous example is the logistic map, where the governing equation can be written as \\[\nu_{n+1}=ru_n(1-u_n).\n\\tag{2}\\]\nNote that the right-hand side is now a quadratic function of \\(u_n\\).\nYou can explore the solutions to Equation 2 using Figure 2.\n\nshow that when \\(0&lt;r&lt;1\\) the solution converges monotonically to 0.0.\nshow that when \\(0&lt;r&lt;2\\) the solution converges monotonically to a non-zero value.\nshow that when \\(2&lt;r&lt;3\\) the solution is oscillatory and converges to a non-zero value.\nshow that when \\(r=3.2\\) the solution is periodic and repeats every second step\nshow that when \\(r=3.47\\) the solution is periodic and repeats every fourth step\nshow that when \\(r=3.7\\) that the solution is neither periodic nor reaches a steady value.\nuse the $r$ zoomed' and\\(u\\) zoomed’ sliders to magnify the third figure. Can you see self similarity (i.e. at fine scales the bifurcation structure looks similar to that at large scales?).\n\nThe logistic map provides one of the simplest mathematical formulations of a phenomenon known as chaos. Whilst a precise definition of chaos involves some technical concepts, chaotic systems are broadly characterised by:\n\nhaving non-periodic, non-steady solution\nsensitivity to initial conditions\nappearing to be unpredictable even through they are deterministic.\nself similarity\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"r\",label=\"r\",min=0.0,max=5.0,value=0.1,step=0.001),             \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=1.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n    ui.input_slider(id=\"r_range\",label=\"r zoomed\",min=0.0,max=4.0,value=[0.0,4.0],step=0.001),\n    ui.input_slider(id=\"u_range\",label=\"u zoomed\",min=0.0,max=1.0,value=[0.0,1.0],step=0.01),\n              \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(3,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        u0=float(input.u0())\n        T=int(input.T())\n        r_min=float(input.r_range()[0])\n        r_max=float(input.r_range()[1])\n        u_min=float(input.u_range()[0])\n        u_max=float(input.u_range()[1])\n\n\n        # Define rhs of logistic map \n        def logistic_map(y,t,r):\n          rhs=r*y*(1-y)\n          return rhs\n        \n        def DiscreteSol(rhs_pop_model,y_0,t,r):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n\n                    y[i]=rhs_pop_model(y[i-1],t[i],r)\n            return y\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(logistic_map,init_cond,t,r)\n\n        # Plot results\n        y=sol1\n        \n        ax[0].plot(t,y)\n        ax[0].set_xlabel('$n$')\n        ax[0].set_ylabel('$u_n$')\n\n        plt.grid()\n\n        # Parameters\n        n_iterations = 1000  # total iterations for each value of r\n        n_last = 100         # number of iterations to plot (for steady state)\n        r_values = np.linspace(0.0, 4.0, 10000)  # range of r values\n        u0 = 0.5  # initial population (seed)\n\n        delta=0.25\n        #r_min=r-delta\n        #r_max=r+delta\n\n        r_values2 = np.linspace(r_min, r_max, 10000)  # range of r values\n\n        # Initialize plot\n        x = np.full_like(r_values, u0)\n        x2 = np.full_like(r_values2, u0)\n\n        # Iterate and plot bifurcation diagram\n         \n        for _ in range(n_iterations):\n            x = r_values * x * (1 - x)  # logistic map function\n            x2 = r_values2 * x2 * (1 - x2)  # logistic map function\n\n            if _ &gt;= (n_iterations - n_last):  # plot only steady state\n                ax[1].plot(r_values, x, ',k', alpha=0.25)\n                ax[1].plot([r,r],[0,1],'r--')\n                ax[2].plot(r_values2, x2, ',k', alpha=0.25)\n                ax[2].plot([r,r],[0,1],'r--')\n\n            # Labels and display\n            ax[1].set_title(\"Bifurcation Diagram\")\n            ax[1].set_xlabel(\"$r$\")\n            ax[1].set_ylabel(\"$u^*$\")\n            ax[2].set_title(\"Bifurcation Diagram (zoomed in) \")\n            ax[2].set_xlabel(\"$r$\")\n            ax[2].set_ylabel(\"$u^*$\")\n            ax[2].set_xlim([r_min,r_max])\n            ax[2].set_ylim([u_min,u_max])\n\n\n\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) and algebra that are needed to study dynamical systems are introduced in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the module Discrete Maths you would be introduced to discrete dynamical systems (e.g. recurrence relations, Markov chains). In the modules Introduction to Programming and Computer Algebra and Dynamical systems you would be introduced to techniques that enable you to numerically analyse difference equations.\nAt Level 3 in the module Mathematical Biology you would consider discrete dynamical systems model applied to Biological systems.\nAt Level 4 we offer a number of honours projects that investigate chaotic systems (e.g. the Lorenz equations, the double pendulum)\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/RecurrenceRelations.html#a-linear-recurrence-relation",
    "href": "posts/RecurrenceRelations.html#a-linear-recurrence-relation",
    "title": "Recurrence relations and chaos",
    "section": "",
    "text": "You might have previously encountered a recurrence relation of the form\n\\[\nu_{n+1}=au_n+b\n\\tag{1}\\] where \\(a\\) and \\(b\\) are constants.\nGiven numerical values for \\(a\\) and \\(b\\) and an initial condition, \\(u_0\\), a sequence can be computed that is a solution to Equation 1. This type of task is laborious and well suited to a computer (see Figure 1).\n\n\n\n\n\n\nA typical Higher-like question\n\n\n\nThe population of Dundonian hobbits is observed to be declining by 5% per year. To increase the population, it is planned that 1000 of the species will be released at the end of May each year.\nLet \\(u_n\\) represent the population of the hobbits at the beginning of June, \\(n\\) years after the first annual reintroduction into the population.\nSuppose that \\(u_n\\) and \\(u_{n+1}\\) satisfy the recurrence relation \\[\nu_{n+1}=au_n+b,\n\\] where \\(a\\) and \\(b\\) are constants.\n\nState the values of \\(a\\) and \\(b\\).\nExplain whether or not the population of the Dundonian hobbit will stabilise in the long term.\nThe population of Dundonian hobbits at the beginning of the reintroduction programme was estimated at 5000. Explain whether or not the population will ever exceed 10000.\n\n\n\nExplore how the computed solution depend on model parameters as follows:\n\nset \\(b=0\\) by varying the parameter \\(a\\) identify solutions that:\n\ntend to zero monotonically\noscillate about 0\nblow up\n\nset b&gt;0\n\nshow that the solution converges to a non-zero value in the case where \\(0&lt;a&lt;1\\).\nshow that the solution is oscillatory for \\(-1&lt;a&lt;0\\).\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-1.0,max=3,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=15.0,value=10.0,step=0.01),             \n     \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=20.0,value=5.0,step=1.0),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n              \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        u0=float(input.u0())\n        T=int(input.T())\n       \n        # Define rhs of LV ODEs\n        def rhs_pop_model(y,t,a,b):\n          \n\n          rhs=a*y+b\n\n          return rhs\n        def DiscreteSol(rhs_pop_model,y_0,t,a,b):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n                    y[i]=rhs_pop_model(y[i-1],t[i],a,b)\n            return y\n\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(rhs_pop_model,init_cond,t,a,b)\n\n        # Plot results\n        y=sol1\n        \n        ax.plot(t,y)\n        ax.set_xlabel('$n$')\n        ax.set_ylabel('$u_n$')\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1"
  },
  {
    "objectID": "posts/RecurrenceRelations.html#the-logistic-map",
    "href": "posts/RecurrenceRelations.html#the-logistic-map",
    "title": "Recurrence relations and chaos",
    "section": "",
    "text": "The recurrence relation explored in Figure 1 is linear (the right-hand-side is a linear function of \\(u_n\\)). When the model is generalised much richer dynamical behaviours can be observed. One famous example is the logistic map, where the governing equation can be written as \\[\nu_{n+1}=ru_n(1-u_n).\n\\tag{2}\\]\nNote that the right-hand side is now a quadratic function of \\(u_n\\).\nYou can explore the solutions to Equation 2 using Figure 2.\n\nshow that when \\(0&lt;r&lt;1\\) the solution converges monotonically to 0.0.\nshow that when \\(0&lt;r&lt;2\\) the solution converges monotonically to a non-zero value.\nshow that when \\(2&lt;r&lt;3\\) the solution is oscillatory and converges to a non-zero value.\nshow that when \\(r=3.2\\) the solution is periodic and repeats every second step\nshow that when \\(r=3.47\\) the solution is periodic and repeats every fourth step\nshow that when \\(r=3.7\\) that the solution is neither periodic nor reaches a steady value.\nuse the $r$ zoomed' and\\(u\\) zoomed’ sliders to magnify the third figure. Can you see self similarity (i.e. at fine scales the bifurcation structure looks similar to that at large scales?).\n\nThe logistic map provides one of the simplest mathematical formulations of a phenomenon known as chaos. Whilst a precise definition of chaos involves some technical concepts, chaotic systems are broadly characterised by:\n\nhaving non-periodic, non-steady solution\nsensitivity to initial conditions\nappearing to be unpredictable even through they are deterministic.\nself similarity\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"r\",label=\"r\",min=0.0,max=5.0,value=0.1,step=0.001),             \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=1.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n    ui.input_slider(id=\"r_range\",label=\"r zoomed\",min=0.0,max=4.0,value=[0.0,4.0],step=0.001),\n    ui.input_slider(id=\"u_range\",label=\"u zoomed\",min=0.0,max=1.0,value=[0.0,1.0],step=0.01),\n              \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(3,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        u0=float(input.u0())\n        T=int(input.T())\n        r_min=float(input.r_range()[0])\n        r_max=float(input.r_range()[1])\n        u_min=float(input.u_range()[0])\n        u_max=float(input.u_range()[1])\n\n\n        # Define rhs of logistic map \n        def logistic_map(y,t,r):\n          rhs=r*y*(1-y)\n          return rhs\n        \n        def DiscreteSol(rhs_pop_model,y_0,t,r):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n\n                    y[i]=rhs_pop_model(y[i-1],t[i],r)\n            return y\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(logistic_map,init_cond,t,r)\n\n        # Plot results\n        y=sol1\n        \n        ax[0].plot(t,y)\n        ax[0].set_xlabel('$n$')\n        ax[0].set_ylabel('$u_n$')\n\n        plt.grid()\n\n        # Parameters\n        n_iterations = 1000  # total iterations for each value of r\n        n_last = 100         # number of iterations to plot (for steady state)\n        r_values = np.linspace(0.0, 4.0, 10000)  # range of r values\n        u0 = 0.5  # initial population (seed)\n\n        delta=0.25\n        #r_min=r-delta\n        #r_max=r+delta\n\n        r_values2 = np.linspace(r_min, r_max, 10000)  # range of r values\n\n        # Initialize plot\n        x = np.full_like(r_values, u0)\n        x2 = np.full_like(r_values2, u0)\n\n        # Iterate and plot bifurcation diagram\n         \n        for _ in range(n_iterations):\n            x = r_values * x * (1 - x)  # logistic map function\n            x2 = r_values2 * x2 * (1 - x2)  # logistic map function\n\n            if _ &gt;= (n_iterations - n_last):  # plot only steady state\n                ax[1].plot(r_values, x, ',k', alpha=0.25)\n                ax[1].plot([r,r],[0,1],'r--')\n                ax[2].plot(r_values2, x2, ',k', alpha=0.25)\n                ax[2].plot([r,r],[0,1],'r--')\n\n            # Labels and display\n            ax[1].set_title(\"Bifurcation Diagram\")\n            ax[1].set_xlabel(\"$r$\")\n            ax[1].set_ylabel(\"$u^*$\")\n            ax[2].set_title(\"Bifurcation Diagram (zoomed in) \")\n            ax[2].set_xlabel(\"$r$\")\n            ax[2].set_ylabel(\"$u^*$\")\n            ax[2].set_xlim([r_min,r_max])\n            ax[2].set_ylim([u_min,u_max])\n\n\n\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) and algebra that are needed to study dynamical systems are introduced in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the module Discrete Maths you would be introduced to discrete dynamical systems (e.g. recurrence relations, Markov chains). In the modules Introduction to Programming and Computer Algebra and Dynamical systems you would be introduced to techniques that enable you to numerically analyse difference equations.\nAt Level 3 in the module Mathematical Biology you would consider discrete dynamical systems model applied to Biological systems.\nAt Level 4 we offer a number of honours projects that investigate chaotic systems (e.g. the Lorenz equations, the double pendulum)\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/EstimatingPi.html",
    "href": "posts/EstimatingPi.html",
    "title": "Estimating pi",
    "section": "",
    "text": "Consider a circle of radius \\(R\\) centred at the origin.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nThe equation of the circle is given by \\[\nx^2+y^2=R^2.\n\\tag{1}\\]\nThe area of the circle is given by the familiar formula\n\\[\n\\pi R^2.\n\\]\nThe smallest square within which the circle can be inscribed will have side length \\(2R\\).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nHence the ratio of the area of the circle to that of the square is\n\\[\n\\frac{\\pi R^2}{4 R^2}=\\frac{\\pi}{4}.\n\\]\n\n\n\nWe can use the above result to estimate \\(\\pi\\) by randomly sampling points that sit inside the square. The probability of a randomly sampled point falling inside the inscribed circle in Figure 2 is equal to the ratio of the areas, i.e. \\[\n\\frac{\\pi}{4}.\n\\]\nWe can use a random number generator to uniformly sample \\(N_s\\) points within the square, i.e.  \\[\nx_i \\in U_{0,2R}, \\quad y_i \\in U_{0,2R}, \\quad i=1,..,N.\n\\] Here \\(U\\) represents a uniform distribution and \\(N\\) is the number of sampled points.\nWe can then count the number of randomly sampled points, \\(N_c\\), that sit inside the circle, i.e. with coordinates that satisfy the inequality \\[\nx_i^2+y_i^2&lt; R^2.\n\\]\nWe can then estimate \\(\\pi\\) using the formula \\[\n\\hat{\\pi}\\sim 4\\frac{N_c}{N_s}.\n\\]\nIn Figure 3 we use an app to explore the approximation of \\(\\pi\\). Here you can explore how the estimate for \\(\\pi\\) depends on the number of samples and consider circles of different radii.\nIn the top plot the distribution of sampled points is plotted for a given realisation with the parameter values as you have chosen. In the bottom plot the estimate of \\(\\pi\\) is averaged over 100 realisations and plotted against the number of sampled points, \\(N\\).\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"N\",label=\"N\",min=10,max=3000,value=10,step=1),\n    ui.input_slider(id=\"R\",label=\"R\",min=2.0,max=15.0,value=10.0,step=1),\n    ui.input_slider(id=\"L\",label=\"L\",min=15.0,max=30.0,value=20.0,step=1),             \n     \n              \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def estimate_pi(N,R,L): \n        x = np.random.uniform(0,L,N)\n        y = np.random.uniform(0,L,N)\n\n        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n        num_points_inside_circle=len(radius[radius&lt;=R])\n\n        pi_est=(L/R)**2*(num_points_inside_circle/N)\n\n        return x,y,pi_est\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(2,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        N=int(input.N())\n        R=float(input.R())\n        L=float(input.L())\n        \n    \n        x,y,pi_est=estimate_pi(N,R,L)\n\n        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n        \n        ax[0].plot(x[radius&lt;R],y[radius&lt;R],'b.')\n        ax[0].plot(x[radius&gt;R],y[radius&gt;R],'k.')\n\n        ax[0].set_xlabel('$x$')\n        ax[0].set_ylabel('$y$')\n\n        theta=np.linspace(0,2*np.pi,1000)\n        ax[0].plot(R*np.cos(theta)+L/2.0,R*np.sin(theta)+L/2.0,'r')\n        ax[0].set_title('$\\hat{\\pi}$='+str(pi_est))\n\n        \n        N_vec=np.linspace(10,3000,80,dtype=int)\n        pi_est_vec=np.zeros_like(N_vec,dtype=float)\n        n_samples=100\n        for i in range(len(N_vec)):\n            pi_est_i=np.zeros((n_samples,1),dtype=float)\n            for j in range(n_samples):\n                x,y,pi_est=estimate_pi(N_vec[i],R,L)\n                pi_est_i[j]=pi_est\n            pi_est_vec[i]=np.mean(pi_est_i)\n\n        ax[1].plot(N_vec,pi_est_vec,'.',N_vec,np.pi*np.ones_like(N_vec))\n        ax[1].set_xlabel('$N$')\n        ax[1].set_ylabel('$\\hat{\\pi}$')\n        #plt.Circle([0.0, 0.0 ],R,fill = False,axis=ax)\n        #ax.Circle((0.0, 0.0 ),R,fill = False )\n\n\n        fig.tight_layout()\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 3"
  },
  {
    "objectID": "posts/EstimatingPi.html#a-circle",
    "href": "posts/EstimatingPi.html#a-circle",
    "title": "Estimating pi",
    "section": "",
    "text": "Consider a circle of radius \\(R\\) centred at the origin.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nThe equation of the circle is given by \\[\nx^2+y^2=R^2.\n\\tag{1}\\]\nThe area of the circle is given by the familiar formula\n\\[\n\\pi R^2.\n\\]\nThe smallest square within which the circle can be inscribed will have side length \\(2R\\).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nHence the ratio of the area of the circle to that of the square is\n\\[\n\\frac{\\pi R^2}{4 R^2}=\\frac{\\pi}{4}.\n\\]"
  },
  {
    "objectID": "posts/EstimatingPi.html#estimating-pi-1",
    "href": "posts/EstimatingPi.html#estimating-pi-1",
    "title": "Estimating pi",
    "section": "",
    "text": "We can use the above result to estimate \\(\\pi\\) by randomly sampling points that sit inside the square. The probability of a randomly sampled point falling inside the inscribed circle in Figure 2 is equal to the ratio of the areas, i.e. \\[\n\\frac{\\pi}{4}.\n\\]\nWe can use a random number generator to uniformly sample \\(N_s\\) points within the square, i.e.  \\[\nx_i \\in U_{0,2R}, \\quad y_i \\in U_{0,2R}, \\quad i=1,..,N.\n\\] Here \\(U\\) represents a uniform distribution and \\(N\\) is the number of sampled points.\nWe can then count the number of randomly sampled points, \\(N_c\\), that sit inside the circle, i.e. with coordinates that satisfy the inequality \\[\nx_i^2+y_i^2&lt; R^2.\n\\]\nWe can then estimate \\(\\pi\\) using the formula \\[\n\\hat{\\pi}\\sim 4\\frac{N_c}{N_s}.\n\\]\nIn Figure 3 we use an app to explore the approximation of \\(\\pi\\). Here you can explore how the estimate for \\(\\pi\\) depends on the number of samples and consider circles of different radii.\nIn the top plot the distribution of sampled points is plotted for a given realisation with the parameter values as you have chosen. In the bottom plot the estimate of \\(\\pi\\) is averaged over 100 realisations and plotted against the number of sampled points, \\(N\\).\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"N\",label=\"N\",min=10,max=3000,value=10,step=1),\n    ui.input_slider(id=\"R\",label=\"R\",min=2.0,max=15.0,value=10.0,step=1),\n    ui.input_slider(id=\"L\",label=\"L\",min=15.0,max=30.0,value=20.0,step=1),             \n     \n              \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def estimate_pi(N,R,L): \n        x = np.random.uniform(0,L,N)\n        y = np.random.uniform(0,L,N)\n\n        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n        num_points_inside_circle=len(radius[radius&lt;=R])\n\n        pi_est=(L/R)**2*(num_points_inside_circle/N)\n\n        return x,y,pi_est\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(2,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        N=int(input.N())\n        R=float(input.R())\n        L=float(input.L())\n        \n    \n        x,y,pi_est=estimate_pi(N,R,L)\n\n        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n        \n        ax[0].plot(x[radius&lt;R],y[radius&lt;R],'b.')\n        ax[0].plot(x[radius&gt;R],y[radius&gt;R],'k.')\n\n        ax[0].set_xlabel('$x$')\n        ax[0].set_ylabel('$y$')\n\n        theta=np.linspace(0,2*np.pi,1000)\n        ax[0].plot(R*np.cos(theta)+L/2.0,R*np.sin(theta)+L/2.0,'r')\n        ax[0].set_title('$\\hat{\\pi}$='+str(pi_est))\n\n        \n        N_vec=np.linspace(10,3000,80,dtype=int)\n        pi_est_vec=np.zeros_like(N_vec,dtype=float)\n        n_samples=100\n        for i in range(len(N_vec)):\n            pi_est_i=np.zeros((n_samples,1),dtype=float)\n            for j in range(n_samples):\n                x,y,pi_est=estimate_pi(N_vec[i],R,L)\n                pi_est_i[j]=pi_est\n            pi_est_vec[i]=np.mean(pi_est_i)\n\n        ax[1].plot(N_vec,pi_est_vec,'.',N_vec,np.pi*np.ones_like(N_vec))\n        ax[1].set_xlabel('$N$')\n        ax[1].set_ylabel('$\\hat{\\pi}$')\n        #plt.Circle([0.0, 0.0 ],R,fill = False,axis=ax)\n        #ax.Circle((0.0, 0.0 ),R,fill = False )\n\n\n        fig.tight_layout()\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 3"
  },
  {
    "objectID": "posts/AffineTransformation.html",
    "href": "posts/AffineTransformation.html",
    "title": "Affine transformations in the plane",
    "section": "",
    "text": "An affine transformation is a geometric transformation that preserves lines and parallelism, but not necessarily Euclidean distances and angles. Examples of affine transformations include:\n\ntranslations\nshears\nrotations\nScalings\n\nIn the app in Figure 1 you can explore transformation of a set of points.\n\nAre straight lines preserved for all transformations?\nFor which transformations are the angles between neighbouring points preserved?\ndoes an inverse transformation exist (i.e. an additional transformation that maps the black square back on to the red one?)\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 600\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport skimage as ski\nimport pyodide\nfrom skimage.transform import SimilarityTransform\nfrom skimage.transform import warp\nfrom skimage.transform import PiecewiseAffineTransform\nfrom skimage.transform import AffineTransform\nfrom skimage.io import imread\nimport io\nfrom pathlib import Path\nfrom skimage.transform import resize, rescale\n\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"Rotation\",label=\"Rotation\",min=-2.0*np.pi,max=2.0*np.pi,value=0.0,step=np.pi/20.0),\n    ui.input_slider(id=\"Scale\",label=\"Scale\",min=0.1,max=3.0,value=1.0,step=0.1),\n    ui.input_slider(id=\"Shear\",label=\"Shear\",min=-3.0,max=3.0,value=0.0,step=0.1),\n    ui.input_slider(id=\"translate_x\",label=\"translate_x\",min=-3.0,max=3.0,value=1.0,step=0.1),\n    ui.input_slider(id=\"translate_y\",label=\"translate_y\",min=-3.0,max=3.0,value=1.0,step=0.1)),\n    ui.panel_main(ui.output_plot(\"plot\")),\n    ),\n)\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    \n    @render.plot\n    def plot():\n        # Calculate the translation required to move all points into positive coordinates\n\n        translation_vec=[input.translate_x(),input.translate_y()]\n        scale_param=input.Scale()\n        shear_param=input.Shear()\n        rotation_param=input.Rotation()\n        tform_shift = AffineTransform(translation=translation_vec,scale=scale_param,shear=shear_param,rotation=rotation_param)\n        homog_trans_matrix=tform_shift.params\n\n\n        old_coordinates=[[0,0,1.0],[0,1,1.0],[0,2,1.0],[0,3,1.0],[0,4,1.0],\n        [4.0,0,1.0],[4.0,1,1.0],[4.0,2,1.0],[4.0,3,1.0],[4.0,4,1.0],\n        [1.0,0.0,1.0],[2.0,0.0,1.0],[3.0,0.0,1.0],\n        [1.0,4.0,1.0],[2.0,4.0,1.0],[3.0,4.0,1.0]]\n        old_coordinates=np.array(old_coordinates)\n\n        new_coordinates=old_coordinates.copy()\n\n        for i in range(old_coordinates.shape[0]):\n\n            homog_vec=np.array(old_coordinates[i,:]).copy()\n            new_coordinates[i,:]=homog_trans_matrix@homog_vec\n\n\n\n        fig,ax=plt.subplots()\n        ax.plot()\n        ax.set_xticks(np.arange(-10,10))\n        ax.set_yticks(np.arange(-10,10))\n        ax.plot(old_coordinates[:,0],old_coordinates[:,1],'r*')\n        ax.plot(new_coordinates[:,0],new_coordinates[:,1],'k*')\n\n        ax.grid(True)\n        plt.axis('equal')\n        ax.set_xlim([-10,10])\n        ax.set_ylim([-10,10])\n        ax.legend(['Original','Transformed'])\n        plt.show()\n\napp = App(app_ui, server)\n\n\n\n\nFigure 1\n\n\n\nAt Dundee, concepts from geometry are studied in core modules Maths 1A and Maths 1B.\nAt Level 3 in the module Differential Geometry students study generalisations of 2D mappings to arbitrarily curved spaces.\nYou can find out more about these modules here. :::"
  },
  {
    "objectID": "posts/SecondOrderODEs.html",
    "href": "posts/SecondOrderODEs.html",
    "title": "Second order ODEs",
    "section": "",
    "text": "Ordinary differential equations\nWe can use calculus to study how quantities change in time. In the examples below we consider a second order linear ordinary differential equation (ODE) with constant coefficients.\n\n\nBackground\nYou might have previously encountered differentiation. Suppose that \\(y\\) is some function of \\(x\\).\nConsider the first order ODE\n\\[\n\\frac{dy}{dx}=1.\n\\]\nUpon integration\n\\[\ny(x)=x+C,\n\\] where \\(C\\) is an integration constant.\nWhat if \\[\n\\frac{dy}{dx}=x\n\\]\nCan you integrate this ODE?\nThe above examples are first order ODEs because the highest order derivative is one. In a second order ODE the highest derivative is two. For example \\[\n\\frac{d^2y}{dx^2}=-y\n\\tag{1}\\]\nThe solution to this ODE is\n\\[\ny(x)=A\\sin x\n+ B \\cos x\\] where \\(A\\) and \\(B\\) are integration constants. Note that you can confirm this claim by twice differentiating the solution and substituting in Equation 1.\n\n\n\n\n\n\nNewton’s Second Law\n\n\n\nSecond order ODEs arise in many different situations in applied mathematics. One of the most notable is in models of Newton’s Second Law \\[\n\\mathbf{F}=m\\mathbf{a},\n\\] where \\(\\mathbf{a}\\) represents the acceleration of a particle, \\(\\mathbf{F}\\) the resultant force acting on it and \\(m\\) the constant particle mass.\nThe acceleration can be written as the second order derivative of the particle position with respect to time, i.e. \\[\n\\mathbf{a}=\\frac{d^2\\mathbf{r}}{dt^2}.\n\\]\nIn physical situations the force term will be composed of terms that are relevant in a given situation.\nSuppose a particle is subjected to a damping force and a spring-like force centred at the origin. We might write \\[\n\\mathbf{F} = -\\eta \\frac{d \\mathbf{r}}{dt}-k\\mathbf{r}\n\\] where \\(\\eta\\) is a constant damping coefficient and \\(k\\) is a spring constant.\nHence we would obtain the second order ODE \\[\nm\\frac{d^2\\mathbf{r}}{dt^2}= -\\eta \\frac{d \\mathbf{r}}{dt}-k\\mathbf{r}.\n\\]\nUpon solving this equation we can describe the particle’s position.\n\n\nLet’s consider a scalar second order ODE with constant coefficients. Let \\(t\\) represent time and \\(y=y(t)\\). Suppose that\n\\[\na\\frac{d^2 y}{dt^2}+b\\frac{dy}{dt}+cy=0,\n\\tag{2}\\] where \\(a\\), \\(b\\) and \\(c\\) are constants.\nConsider the initial conditions\n\\[\ny(t=0)=y_0 \\quad \\quad \\frac{dy}{dt}\\bigg|_{{t=0}}=d.\n\\tag{3}\\]\nThe app in Figure 1 allows you to explore the solution of the model (Equation 2 and Equation 3).\nCan you identify the following three behaviours by adjusting model parameters:\n\nperiodic oscillations\ndamped oscillations\nexponentially decaying but non-oscillatory solutions\n\nCan you\n\ndescribe model behaviour as \\(a\\rightarrow 0\\).\nexplore model behaviour as \\(c\\rightarrow 0\\).\ndescribe how the oscillation period depends on model parameters.\n\nNote that it is possible to solve Equation 2 and Equation 3 by seeking a solution of the form \\[\ny=e^{\\lambda t}.\n\\] This is left as an exercise.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=0.01,max=3,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=15.0,value=10.0,step=0.1),             \n    ui.input_slider(id=\"c\",label=\"c\",min=0.0,max=30.0,value=5.0,step=1.0),   \n    ui.input_slider(id=\"y0\",label=\"y(t=0)\",min=0.0,max=20.0,value=5.0,step=1.0),\n    ui.input_slider(id=\"y0p\",label=\"dy/dt(t=0)\",min=0.0,max=20.0,value=1,step=1.0),\n    ui.input_slider(id=\"T\",label=\"Simulation time\",min=0.0,max=60.0,value=20.0,step=0.5),\n              \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        c=float(input.c())\n        y_0=float(input.y0())\n        y_0_p=float(input.y0p())\n        T=float(input.T())\n        \n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(y,t,a,b,c):\n          rhs=np.zeros_like(y,dtype=float)\n\n          z=y[1]\n\n          #ay'' + by'+cy=0\n          # y'=z\n          # z'=y''=-(by'+cy)/a\n\n\n          dy_dt=y[1]\n          dz_dt=-(b*z+c*y[0])/a\n\n          rhs[0]=dy_dt\n          rhs[1]=dz_dt\n\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[y_0,y_0_p]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_pop_model, init_cond,t,args=(a,b,c))\n\n        # Plot results\n        y=sol1[:,0]\n        yp=sol1[:,1]\n        \n        \n        ax.plot(t, y)\n        ax.set_xlabel('$t$')\n        ax.set_ylabel('$y(t)$')\n\n        plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) are studied in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the modules Computer algebra and dynamical systems and Introduction to Programming you would be introduced to techniques that are used to compute numerical solutions to differential equations.\nAt Level 3 in the module Differential Equations you would extend your knowledge of differential equations to include concepts such as Fourier Series and Partial Differential Equations. In the modules Mathematical Biology I and Mathematical Biology II you would also learn how to formulate and study mathematical models of biological systems.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/GraduateEmployment.html",
    "href": "posts/GraduateEmployment.html",
    "title": "Graduate employment",
    "section": "",
    "text": "A mathematics degree will enable you to become a logical numerate problem solver. Over the course of your degree you will develop"
  },
  {
    "objectID": "posts/GraduateEmployment.html#career-earnings",
    "href": "posts/GraduateEmployment.html#career-earnings",
    "title": "Graduate employment",
    "section": "Career earnings",
    "text": "Career earnings\nMathematics degrees are associated with higher career earnings compared with many other disciplines. In the table below median salaries are compared across different disciplines. In this dataset mathematical sciences degrees have the fourth highest median salary.\n\n\n\n\n\nData provided by HESA (2020/2021)"
  },
  {
    "objectID": "posts/GraduateEmployment.html#where-our-graduates-get-employed",
    "href": "posts/GraduateEmployment.html#where-our-graduates-get-employed",
    "title": "Graduate employment",
    "section": "Where our graduates get employed?",
    "text": "Where our graduates get employed?\n\nData analyst\nActuary\nAccountant\nPhD\nData scientist\nTransport engineer\nManagement consultant\nTeacher\nOperations analyst\nFinancial engineer\nOperations research\nTax consultant\nEnergy risk analyst\nInsurance underwriter\nSoftware engineer\nCredit risk analyst\nHedge fund analyst\n\nYou can find lots of interesting information about mathematics careers here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome to the Dundee mathematics pages. Are you enjoying mathematics at school and considering studying mathematics at University?\nA mathematics degree enables you to become a logical numerate problem solver. Picking up from the mathematics that you have learned at school, you would:\n\ndevelop knowledge of core principles of mathematics\nlearn about exciting new areas of mathematics\nlearn how to apply mathematics in real-world contexts\n\nMathematics graduates have excellent career prospects. They tend to work across the economy (e.g. in finance, defence, computing, engineering, education, data science etc.).\nThe posts below have been developed in parallel with events that have been run by Dundee mathematics staff. The main aim is explore mathematical threads that you may have come across during school.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMonte Carlo Integration\n\n\n\n\n\n\nintegration\n\n\ngeometry\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRoots of quadratic/cubic equations\n\n\n\n\n\n\nPolynomials\n\n\nAlgebra\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrigonometric equations and Fourier series\n\n\n\n\n\n\nTrigonometry\n\n\nGeometry\n\n\nFourier\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRecurrence relations and chaos\n\n\n\n\n\n\nRecurrence relations\n\n\nDiscrete maths\n\n\nChaos\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nD’Arcy Thompson and 2D mappings\n\n\n\n\n\n\nGeometry\n\n\nGrowth and form\n\n\nMappings\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEstimating pi\n\n\n\n\n\n\nintegration\n\n\ngeometry\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to population dynamics\n\n\n\n\n\n\nPopulation dynamics\n\n\nCalculus\n\n\nDifferential Equations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAffine transformations in the plane\n\n\n\n\n\n\nGeometry\n\n\nGrowth and form\n\n\nMappings\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModelling the spread of infectious disease\n\n\n\n\n\n\nInfectious diseases\n\n\nPopulation dynamics\n\n\nCalculus\n\n\nDifferential Equations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSecond order ODEs\n\n\n\n\n\n\nDifferential Equations\n\n\nCalculus\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntersecting lines and linear algebra\n\n\n\n\n\n\nGeometry\n\n\nAlgebra\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduate employment\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "These pages are hosted by Mathematics staff at the University of Dundee. They are intended to support ongoing student recruitment and outreach activities."
  }
]