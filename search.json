[
  {
    "objectID": "WorkSheetPrintOut.html",
    "href": "WorkSheetPrintOut.html",
    "title": "Pop. dynamics worksheet",
    "section": "",
    "text": "The aim of this demonstration is to show how we can use ideas from calculus to study dynamical systems.\n\nIt is not intended that you work through all the questions in the available time.\nYou are encouraged to use your phone to explore the linked apps"
  },
  {
    "objectID": "WorkSheetPrintOut.html#formulating-a-model-of-population-dynamics",
    "href": "WorkSheetPrintOut.html#formulating-a-model-of-population-dynamics",
    "title": "Pop. dynamics worksheet",
    "section": "3.1 Formulating a model of population dynamics",
    "text": "3.1 Formulating a model of population dynamics\nLet’s consider a model for the number of people in a room at a given time. Let \\(t\\) represent time and \\(N(t)\\) represent the number of people in the room at time \\(t\\).\nSuppose that there are initially no people in the room, but people enter at a constant rate, \\(k\\).\nWe could formulate a model of population dynamics given by\n\\[\n\\frac{dN}{dt}=k, \\quad N(0)=0.\n\\tag{1}\\]\n\n\n\n\n\n\nQuestion\n\n\n\n\nCan you integrate Equation 1 (Hint: it is mathematically equivalent to the ODE introduced in Section 2)?\n\n\n\n\n\n\n\n\n\n\nCan you use the solution of the model to determine the amount of time taken for the number of people in the room to reach some capacity, \\(N_C\\).\n\n\n\n\n\n\n\n\nCan you use the app (see Figure 1) to identify what the entry rate, \\(k\\), needs to be such that the room reaches capacity of 40 people after 20 minutes?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: https://dundeemath.github.io/Admissions/posts/PopulationDynamicsIntro.html."
  },
  {
    "objectID": "WorkSheetPrintOut.html#what-if-people-enter-the-room-at-a-constant-rate-but-also-leave-the-room-at-random",
    "href": "WorkSheetPrintOut.html#what-if-people-enter-the-room-at-a-constant-rate-but-also-leave-the-room-at-random",
    "title": "Pop. dynamics worksheet",
    "section": "3.2 What if people enter the room at a constant rate but also leave the room at random?",
    "text": "3.2 What if people enter the room at a constant rate but also leave the room at random?\nTaking the previous model as a starting point, we now assume that people can also leave the room at a rate proportional to the number of people in the room\nThe model equation is now given by\n\\[\n\\frac{dN}{dt}=k - dN, \\quad N(0)=0.\n\\tag{2}\\]\n\n\n\n\n\n\nQuestion\n\n\n\nIt is possible to integrate Equation 2 and show that the solution is \\[\nN(t)=\\frac{k}{d}(1-e^{-dt})\n\\tag{3}\\]\nCan you do this? (hint: try using an integrating factor)?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nCan you use the model solution (Equation 3) to determine the amount of time taken for the number of people in the room to reach capacity, \\(N_C\\). Does a solution always exist?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nCan you use the app or the solution (Equation 3) to identify the entry rate needs to be such that the room reaches capacity of 40 people after 20 minutes given \\(d=0.1\\)?"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#why-maths",
    "href": "Slides/TasterDayMay2024.html#why-maths",
    "title": "Taster Day 2024",
    "section": "Why Maths?",
    "text": "Why Maths?"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#maths-careers",
    "href": "Slides/TasterDayMay2024.html#maths-careers",
    "title": "Taster Day 2024",
    "section": "Maths careers",
    "text": "Maths careers"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#recent-gradautes",
    "href": "Slides/TasterDayMay2024.html#recent-gradautes",
    "title": "Taster Day 2024",
    "section": "Recent gradautes",
    "text": "Recent gradautes\nOur recent graduates have gone on to work as:\n\naccountants\ntrade analysts\ntransport planners\nactuaries\nengineers\nteachers\nsoftware developers\ndata analysts\nand many others"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#mathematics-degrees-at-dundee",
    "href": "Slides/TasterDayMay2024.html#mathematics-degrees-at-dundee",
    "title": "Taster Day 2024",
    "section": "Mathematics degrees at Dundee",
    "text": "Mathematics degrees at Dundee\n\nSingle honours Mathematics degrees\nBSc Mathematics/MMath\nJoint degrees (e.g.)\n\nBSc Mathematical Biology\nBSc Maths and Economics\nBSc Maths and Physics\nBSc Maths and Accountancy"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#what-you-will-learn",
    "href": "Slides/TasterDayMay2024.html#what-you-will-learn",
    "title": "Taster Day 2024",
    "section": "What you will learn?",
    "text": "What you will learn?\n\nCore mathematical skills (e.g. calculus, integration, algebra)\nFoundations of mathematics\nApplication of mathematics to real world problems"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#how-you-will-learn",
    "href": "Slides/TasterDayMay2024.html#how-you-will-learn",
    "title": "Taster Day 2024",
    "section": "How you will learn?",
    "text": "How you will learn?\n\nTwo teaching semesters in the academic year\n3 or 4 modules in each semester\nIn each module (some combination of):\n\nlectures\ntutorials\nworkshops\ncomputer classes"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#final-year-project",
    "href": "Slides/TasterDayMay2024.html#final-year-project",
    "title": "Taster Day 2024",
    "section": "Final year project",
    "text": "Final year project\n\ndevelop independent problem solving skills\nwork on an exciting mathematical topic\ndevelop programming skills\ndevelop presentation skills\nTopics include:\n\nThe $25,000,000,000 eigenvector\nConformal mappings in the art of M.C. Escher\nThe Mathematics of monopoly\nHow Sat Navs work"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#skills-developed-throughout-your-degree",
    "href": "Slides/TasterDayMay2024.html#skills-developed-throughout-your-degree",
    "title": "Taster Day 2024",
    "section": "Skills developed throughout your degree",
    "text": "Skills developed throughout your degree\n\nYou will become a logical numerate problem solver\nMathematical skills\nPure mathematics\nApplied mathematics\nPresentation skills\nComputer programming skills"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#design-constraints",
    "href": "Slides/TasterDayMay2024.html#design-constraints",
    "title": "Taster Day 2024",
    "section": "Design constraints",
    "text": "Design constraints\nWe want to identify some interesting problem (s) that:\n\nconnect from high school syllabus to University level mathematics\nhave an element of visualisation\nhave some interesting mathematics\nare interactive\nare accessible"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#lets-look-at-some-working-examples",
    "href": "Slides/TasterDayMay2024.html#lets-look-at-some-working-examples",
    "title": "Taster Day 2024",
    "section": "Let’s look at some working examples",
    "text": "Let’s look at some working examples\nhttps://dundeemath.github.io/Admissions/\n\nExplore apps"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#possible-topics",
    "href": "Slides/TasterDayMay2024.html#possible-topics",
    "title": "Taster Day 2024",
    "section": "Possible topics",
    "text": "Possible topics\n\nGraphing functions and their derivatives\nRecursion relations\nTrigonometric identities\nDifferential equations\nStatistical tests\nComplex numbers\nWhat would you like to work on?"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#what-we-need-to-do-today",
    "href": "Slides/TasterDayMay2024.html#what-we-need-to-do-today",
    "title": "Taster Day 2024",
    "section": "What we need to do today",
    "text": "What we need to do today\n\nfocus on some ideas for a new app\nwrite some prototype code\ndecide how to make it interactive\nwrite some text to explain the ideas in the app\nbuild the app"
  },
  {
    "objectID": "Slides/TasterDayMay2024.html#section",
    "href": "Slides/TasterDayMay2024.html#section",
    "title": "Taster Day 2024",
    "section": "",
    "text": "## Prototype code that plots a trigonometric function and its derivative\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndx=0.01\nx = np.arange(0, 20, dx)\ny = np.sin(x)\n\ndy_dx=np.cos(x)\n\nfig, ax = plt.subplots(1,2)\nax[0].plot(x, y)\nax[0].set_xlabel('x')\nax[0].set_ylabel('y(x)')\n\nax[1].plot(x, dy_dx)\nax[1].set_xlabel('x')\nax[1].set_ylabel('dy/dx')\n\nax[0].grid(True)\nax[1].grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\nMathematics, University of Dundee"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#recurrence-relations---example",
    "href": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#recurrence-relations---example",
    "title": "From linear recurrence relations to chaos",
    "section": "Recurrence relations - example",
    "text": "Recurrence relations - example\nThe value of an endowment policy increases at the rate of 5 % per annum. The initial value is £7000. How much is it worth after two years?\n\n\\[\nu_0=7000\n\\]\n. . . \\[\nu_1=1.05 \\times 7000= 7350\n\\]\n. . . \\[\nu_2 =1.05 u_1 = 1.05 \\times  7350 =   7717\n\\]"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#simulating-the-accumulation",
    "href": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#simulating-the-accumulation",
    "title": "From linear recurrence relations to chaos",
    "section": "Simulating the accumulation",
    "text": "Simulating the accumulation\nhttps://dundeemath.github.io/Admissions/posts/RecurrenceRelations.html\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"a\",label=\"Interest rate (%)\",min=1.0,max=5.0,value=1.05,step=0.001),\n            \n     \n    ui.input_slider(id=\"u0\",label=\"Initial amount (£)\",min=2500.0,max=10000.0,value=3000.0,step=500),\n    ui.input_slider(id=\"T\",label=\"Number of years\",min=0.0,max=60.0,value=3.0,step=1.0),\n    ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=0.0\n        u0=float(input.u0())\n        T=int(input.T())\n       \n        # Define rhs of LV ODEs\n        def rhs_pop_model(y,t,a,b):\n          \n\n          rhs=a*y+b\n\n          return rhs\n        def DiscreteSol(rhs_pop_model,y_0,t,a,b):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n                    y[i]=rhs_pop_model(y[i-1],t[i],a,b)\n            return y\n\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(rhs_pop_model,init_cond,t,a,b)\n\n        # Plot results\n        y=sol1\n        \n        ax.plot(t,y)\n        ax.set_xlabel('$n$')\n        ax.set_ylabel('$u_n$')\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#general-form-for-a-recurrence-relation",
    "href": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#general-form-for-a-recurrence-relation",
    "title": "From linear recurrence relations to chaos",
    "section": "General form for a recurrence relation",
    "text": "General form for a recurrence relation\n\\[u_{n+1}=r u_n+b\\]\n\nConvergence\nThe solutions converges if \\(|r|&lt;1\\).\n\n\nA limit\nAs \\(n\\rightarrow \\infty\\), \\(u_n\\rightarrow \\frac{b}{1-r}\\).\nThe limiting value is an example of a fixed point."
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#simulate-the-linear-recurrence-relation",
    "href": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#simulate-the-linear-recurrence-relation",
    "title": "From linear recurrence relations to chaos",
    "section": "Simulate the linear recurrence relation",
    "text": "Simulate the linear recurrence relation\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"a\",label=\"r\",min=-1.0,max=3,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=15.0,value=10.0,step=0.01),             \n     \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=20.0,value=5.0,step=1.0),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n              \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        u0=float(input.u0())\n        T=int(input.T())\n       \n        # Define rhs of LV ODEs\n        def rhs_pop_model(y,t,a,b):\n          \n\n          rhs=a*y+b\n\n          return rhs\n        def DiscreteSol(rhs_pop_model,y_0,t,a,b):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n                    y[i]=rhs_pop_model(y[i-1],t[i],a,b)\n            return y\n\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(rhs_pop_model,init_cond,t,a,b)\n\n        # Plot results\n        y=sol1\n        \n        ax.plot(t,y)\n        ax.set_xlabel('$n$')\n        ax.set_ylabel('$u_n$')\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#summarising-the-results-in-a-bifurcation-diagram",
    "href": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#summarising-the-results-in-a-bifurcation-diagram",
    "title": "From linear recurrence relations to chaos",
    "section": "Summarising the results in a bifurcation diagram",
    "text": "Summarising the results in a bifurcation diagram"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#now-with-a-bifurcation-diagram",
    "href": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#now-with-a-bifurcation-diagram",
    "title": "From linear recurrence relations to chaos",
    "section": "Now with a bifurcation diagram",
    "text": "Now with a bifurcation diagram\n\\[u_{n+1}=ru_n+b \\]\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"r\",label=\"r\",min=0.0,max=5.0,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=5.0,value=0.1,step=0.001),             \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=1.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n    ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(2,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        b=float(input.b())\n\n        u0=float(input.u0())\n        T=int(input.T())\n        \n\n        # Define rhs of logistic map \n        def lin_map(y,t,r,b):\n          rhs=r*y+b\n          return rhs\n        \n        def DiscreteSol(rhs_pop_model,y_0,t,r,b):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n\n                    y[i]=rhs_pop_model(y[i-1],t[i],r,b)\n            return y\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(lin_map,init_cond,t,r,b)\n\n        # Plot results\n        y=sol1\n        \n        ax[0].plot(t,y)\n        ax[0].set_xlabel('$n$')\n        ax[0].set_ylabel('$u_n$')\n        ax[0].set_title('Simulation')\n\n        r_vec_1=np.linspace(0,0.99,100)\n        r_vec_2=np.linspace(1.01,5.0,100)\n\n        ax[1].plot(r_vec_1,b/(1-r_vec_1))\n        ax[1].plot(r_vec_2,b/(1-r_vec_2\n        ))\n        max_x_st=5.0\n        ax[1].plot([r,r],[-max_x_st,max_x_st],'r--')\n        ax[1].set_ylim([-max_x_st,max_x_st])\n        ax[1].set_xlabel('$r$')\n        ax[1].set_ylabel('$u^*$')\n\n        ax[1].set_title('Bifurcation diagram')\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 3"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#a-nonlinear-recurrence-relation",
    "href": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#a-nonlinear-recurrence-relation",
    "title": "From linear recurrence relations to chaos",
    "section": "A nonlinear recurrence relation",
    "text": "A nonlinear recurrence relation\n\\[\nu_{n+1}=ru_n(1-u_n)\n\\]\n. . . Rearranging \\[\nu_{n+1}=ru_n - ru_n^2\n\\]\n\nQuestion: how do solutions of this nonlinear system behave?"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#solving-numerically",
    "href": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#solving-numerically",
    "title": "From linear recurrence relations to chaos",
    "section": "Solving numerically",
    "text": "Solving numerically\n\\[\nu_{n+1}=ru_n(1-u_n)\n\\]\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"r\",label=\"r\",min=0.0,max=5.0,value=0.1,step=0.001),             \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=1.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n    \n              \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        u0=float(input.u0())\n        T=int(input.T())\n        \n\n        # Define rhs of logistic map \n        def logistic_map(y,t,r):\n          rhs=r*y*(1-y)\n          return rhs\n        \n        def DiscreteSol(rhs_pop_model,y_0,t,r):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n\n                    y[i]=rhs_pop_model(y[i-1],t[i],r)\n            return y\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(logistic_map,init_cond,t,r)\n\n        # Plot results\n        y=sol1\n        \n        ax.plot(t,y)\n        ax.set_xlabel('$n$')\n        ax.set_ylabel('$u_n$')\n\n        plt.grid()\n\n        \n        \n\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 4"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#now-with-a-bifurcation-diagram-1",
    "href": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#now-with-a-bifurcation-diagram-1",
    "title": "From linear recurrence relations to chaos",
    "section": "Now with a bifurcation diagram",
    "text": "Now with a bifurcation diagram\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"r\",label=\"r\",min=0.0,max=5.0,value=0.1,step=0.001),             \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=1.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n    ui.input_slider(id=\"r_range\",label=\"r zoomed\",min=0.0,max=4.0,value=[0.0,4.0],step=0.001),\n    ui.input_slider(id=\"u_range\",label=\"u zoomed\",min=0.0,max=1.0,value=[0.0,1.0],step=0.01),\n              \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(3,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        u0=float(input.u0())\n        T=int(input.T())\n        r_min=float(input.r_range()[0])\n        r_max=float(input.r_range()[1])\n        u_min=float(input.u_range()[0])\n        u_max=float(input.u_range()[1])\n\n\n        # Define rhs of logistic map \n        def logistic_map(y,t,r):\n          rhs=r*y*(1-y)\n          return rhs\n        \n        def DiscreteSol(rhs_pop_model,y_0,t,r):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n\n                    y[i]=rhs_pop_model(y[i-1],t[i],r)\n            return y\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(logistic_map,init_cond,t,r)\n\n        # Plot results\n        y=sol1\n        \n        ax[0].plot(t,y)\n        ax[0].set_xlabel('$n$')\n        ax[0].set_ylabel('$u_n$')\n\n        plt.grid()\n\n        # Parameters\n        n_iterations = 1000  # total iterations for each value of r\n        n_last = 100         # number of iterations to plot (for steady state)\n        r_values = np.linspace(0.0, 4.0, 10000)  # range of r values\n        u0 = 0.5  # initial population (seed)\n\n        delta=0.25\n        #r_min=r-delta\n        #r_max=r+delta\n\n        r_values2 = np.linspace(r_min, r_max, 10000)  # range of r values\n\n        # Initialize plot\n        x = np.full_like(r_values, u0)\n        x2 = np.full_like(r_values2, u0)\n\n        # Iterate and plot bifurcation diagram\n         \n        for _ in range(n_iterations):\n            x = r_values * x * (1 - x)  # logistic map function\n            x2 = r_values2 * x2 * (1 - x2)  # logistic map function\n\n            if _ &gt;= (n_iterations - n_last):  # plot only steady state\n                ax[1].plot(r_values, x, ',k', alpha=0.25)\n                ax[1].plot([r,r],[0,1],'r--')\n                ax[2].plot(r_values2, x2, ',k', alpha=0.25)\n                ax[2].plot([r,r],[0,1],'r--')\n\n            # Labels and display\n            ax[1].set_title(\"Bifurcation Diagram\")\n            ax[1].set_xlabel(\"$r$\")\n            ax[1].set_ylabel(\"$u^*$\")\n            ax[2].set_title(\"Bifurcation Diagram (zoomed in) \")\n            ax[2].set_xlabel(\"$r$\")\n            ax[2].set_ylabel(\"$u^*$\")\n            ax[2].set_xlim([r_min,r_max])\n            ax[2].set_ylim([u_min,u_max])\n\n\n\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 5"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#mathematics-degrees",
    "href": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#mathematics-degrees",
    "title": "From linear recurrence relations to chaos",
    "section": "Mathematics degrees",
    "text": "Mathematics degrees\n\nBecome a logical numerate problem solver\nLearn about exciting new areas of mathematics\nLearn how to apply mathematics to real world problems\nDevelop computer programming skills\nDevelop communication skills"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#logical-numerate-problem-solvers-are-valued",
    "href": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#logical-numerate-problem-solvers-are-valued",
    "title": "From linear recurrence relations to chaos",
    "section": "Logical numerate problem solvers are valued",
    "text": "Logical numerate problem solvers are valued"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#mathematics-degrees-1",
    "href": "Slides/ApplicantVisitOnlineMarch2025/LogisticMapPres.html#mathematics-degrees-1",
    "title": "From linear recurrence relations to chaos",
    "section": "Mathematics degrees",
    "text": "Mathematics degrees\n\nSingle honours Mathematics degrees\nJoint Honours (e.g. with Accountancy, Economics, Physics, Life Sciences, Psychology)\nFlexibility in structure of degree pathways"
  },
  {
    "objectID": "Slides/STEMExpo2025/Worksheet.html",
    "href": "Slides/STEMExpo2025/Worksheet.html",
    "title": "STEM Expo 2025",
    "section": "",
    "text": "This worksheet is accompanied by web apps that can be found here (https://dundeemath.github.io/Admissions/)."
  },
  {
    "objectID": "Slides/STEMExpo2025/Worksheet.html#estimating-pi",
    "href": "Slides/STEMExpo2025/Worksheet.html#estimating-pi",
    "title": "STEM Expo 2025",
    "section": "1 Estimating \\(\\pi\\)",
    "text": "1 Estimating \\(\\pi\\)\nConsider Figure 1. The ratio of the area of the circle to that of the circumscribed square is\n\\[\n\\frac{\\textrm{Area circle}}{\\textrm{Area square}}=\\frac{\\pi}{4}.\n\\]\nSuppose we uniformly sample points from within the square. The probability of a point landing in the circle is proportional to the relative area of the circle, i.e. \\[\n\\frac{\\pi}{4}.\n\\]\nHence we can estimate \\(\\pi\\) by counting the number of uniformly sampled points that fall within the circle.\nTo sample the points:\n\nHold a small number of rice grains above the circle in Figure 1 and drop onto the page. Vary dropping height to ensure the rice grains land approximately uniformly in the square.\n\nDrop rice grains on to the square.\nCount the total number of rice grains that fall inside the square, \\(N_S\\), and the circle, \\(N_C\\).\nInput the data into Table 1 and compute the quantity \\[\n\\hat{\\pi}=4\\frac{N_C}{N_S}.\n\\]\nRepeat Steps (i)-(iii).\n\nCompute the mean of the samples.\nExplore computationally using the ‘Estimating \\(\\pi\\)’ app.\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n\n\nTable 1: A table to record counts.\n\n\n\n\n\nIteration\n\\(N_S\\)\n\\(N_C\\)\n\\(\\hat{\\pi}=4N_C/N_S\\)\n\n\n\n\n1\n\n\n\n\n\n2\n\n\n\n\n\n3\n\n\n\n\n\n4\n\n\n\n\n\n5\n\n\n\n\n\n6\n\n\n\n\n\n—\n———\n—–\n——\n\n\nMean\nN/A\nN/A"
  },
  {
    "objectID": "Slides/STEMExpo2025/Worksheet.html#estimating-an-integral",
    "href": "Slides/STEMExpo2025/Worksheet.html#estimating-an-integral",
    "title": "STEM Expo 2025",
    "section": "2 Estimating an integral",
    "text": "2 Estimating an integral\nConsider Figure 2. Here we have plotted the function \\[\ny=x^2, \\quad x \\in [0,1].\n\\]\nThe shaded ‘area under the curve’ can be represented by the integral \\[\nI=\\int_0^1 x^2 \\textrm{d}x.\n\\]\nTo estimate the integral we again uniformly sample points from within the circumscribed square. By counting how many points fall inside the shaded region we can estimate the integral to be \\[\n\\hat{I}=\\textrm{Area square} \\times \\textrm{Frac points in shaded region} = 1\\times \\frac{N_R}{N_S}\n\\]\n\nHold a small number of rice grains above the square in Figure 2 drop onto the page.\nCount the total number of rice grains that fall inside the square, \\(N_S\\), and the shaded region, \\(N_R\\).\nInput data into Table 2 and compute the quantity \\[\n\\frac{N_R}{N_S}.\n\\]\nRepeat Steps 1-3.\nCompute the mean of the samples.\nExplore computationally using the ‘Monte Carlo integration’ app.\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\nTable 2: A table to record counts.\n\n\n\n\n\nIteration\n\\(N_S\\)\n\\(N_R\\)\n\\(\\hat{I}=N_R/N_S\\)\n\n\n\n\n1\n\n\n\n\n\n2\n\n\n\n\n\n3\n\n\n\n\n\n4\n\n\n\n\n\n5\n\n\n\n\n\n6\n\n\n\n\n\n—\n———\n—–\n——\n\n\nMean\nN/A\nN/A"
  },
  {
    "objectID": "Slides/STEMDayDecember2024/Worksheet.html",
    "href": "Slides/STEMDayDecember2024/Worksheet.html",
    "title": "STEM Day December 2024",
    "section": "",
    "text": "This worksheet is accompanied by web apps that can be found here (https://dundeemath.github.io/Admissions/)."
  },
  {
    "objectID": "Slides/STEMDayDecember2024/Worksheet.html#estimating-pi",
    "href": "Slides/STEMDayDecember2024/Worksheet.html#estimating-pi",
    "title": "STEM Day December 2024",
    "section": "1 Estimating \\(\\pi\\)",
    "text": "1 Estimating \\(\\pi\\)\nConsider Figure 1. The ratio of the area of the circle to that of the circumscribed square is\n\\[\n\\frac{\\textrm{Area circle}}{\\textrm{Area square}}=\\frac{\\pi}{4}.\n\\]\nSuppose we uniformly sample points from within the square. The probability of a point landing in the circle is proportional to the relative area of the circle, i.e. \\[\n\\frac{\\pi}{4}.\n\\]\nHence we can estimate \\(\\pi\\) by counting the number of uniformly sampled points that fall within the circle.\nTo sample the points:\n\nHold a small number of rice grains above the circle in Figure 1 and drop onto the page. Vary dropping height to ensure the rice grains land approximately uniformly in the square.\n\nDrop rice grains on to the square.\nCount the total number of rice grains that fall inside the square, \\(N_S\\), and the circle, \\(N_C\\).\nInput the data into Table 1 and compute the quantity \\[\n\\hat{\\pi}=4\\frac{N_C}{N_S}.\n\\]\nRepeat Steps (i)-(iii).\n\nCompute the mean of the samples.\nExplore computationally using the ‘Estimating \\(\\pi\\)’ app.\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n\n\nTable 1: A table to record counts.\n\n\n\n\n\nIteration\n\\(N_S\\)\n\\(N_C\\)\n\\(\\hat{\\pi}=4N_C/N_S\\)\n\n\n\n\n1\n\n\n\n\n\n2\n\n\n\n\n\n3\n\n\n\n\n\n4\n\n\n\n\n\n5\n\n\n\n\n\n6\n\n\n\n\n\n—\n———\n—–\n——\n\n\nMean\nN/A\nN/A"
  },
  {
    "objectID": "Slides/STEMDayDecember2024/Worksheet.html#estimating-an-integral",
    "href": "Slides/STEMDayDecember2024/Worksheet.html#estimating-an-integral",
    "title": "STEM Day December 2024",
    "section": "2 Estimating an integral",
    "text": "2 Estimating an integral\nConsider Figure 2. Here we have plotted the function \\[\ny=x^2, \\quad x \\in [0,1].\n\\]\nThe shaded ‘area under the curve’ can be represented by the integral \\[\nI=\\int_0^1 x^2 \\textrm{d}x.\n\\]\nTo estimate the integral we again uniformly sample points from within the circumscribed square. By counting how many points fall inside the shaded region we can estimate the integral to be \\[\n\\hat{I}=\\textrm{Area square} \\times \\textrm{Frac points in shaded region} = 1\\times \\frac{N_R}{N_S}\n\\]\n\nHold a small number of rice grains above the square in Figure 2 drop onto the page.\nCount the total number of rice grains that fall inside the square, \\(N_S\\), and the shaded region, \\(N_R\\).\nInput data into Table 2 and compute the quantity \\[\n\\frac{N_R}{N_S}.\n\\]\nRepeat Steps 1-3.\nCompute the mean of the samples.\nExplore computationally using the ‘Monte Carlo integration’ app.\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\n\n\n\nTable 2: A table to record counts.\n\n\n\n\n\nIteration\n\\(N_S\\)\n\\(N_R\\)\n\\(\\hat{I}=N_R/N_S\\)\n\n\n\n\n1\n\n\n\n\n\n2\n\n\n\n\n\n3\n\n\n\n\n\n4\n\n\n\n\n\n5\n\n\n\n\n\n6\n\n\n\n\n\n—\n———\n—–\n——\n\n\nMean\nN/A\nN/A"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome to the Dundee mathematics pages. Are you enjoying mathematics at school and considering studying mathematics at University?\nA mathematics degree enables you to become a logical numerate problem solver. Picking up from the mathematics that you have learned at school, you would:\n\ndevelop knowledge of core principles of mathematics\nlearn about exciting new areas of mathematics\nlearn how to apply mathematics in real-world contexts\n\nMathematics graduates have excellent career prospects. They tend to work across the economy (e.g. in finance, defence, computing, engineering, education, data science etc.).\nThe posts below have been developed in parallel with events that have been run by Dundee mathematics staff. The main aim is explore mathematical threads that you may have come across during school.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModelling drug delivery\n\n\n\n\n\n\nCalculus\n\n\nDifferential Equations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMonte Carlo Integration\n\n\n\n\n\n\nintegration\n\n\ngeometry\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRoots of quadratic/cubic equations\n\n\n\n\n\n\nPolynomials\n\n\nAlgebra\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCryptography\n\n\n\n\n\n\ncryptography\n\n\nnumber theory\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrigonometric equations and Fourier series\n\n\n\n\n\n\nTrigonometry\n\n\nGeometry\n\n\nFourier\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRecurrence relations and chaos\n\n\n\n\n\n\nRecurrence relations\n\n\nDiscrete maths\n\n\nChaos\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nD’Arcy Thompson and 2D mappings\n\n\n\n\n\n\nGeometry\n\n\nGrowth and form\n\n\nMappings\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEstimating pi\n\n\n\n\n\n\nintegration\n\n\ngeometry\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to population dynamics\n\n\n\n\n\n\nPopulation dynamics\n\n\nCalculus\n\n\nDifferential Equations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAffine transformations in the plane\n\n\n\n\n\n\nGeometry\n\n\nGrowth and form\n\n\nMappings\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModelling the spread of infectious disease\n\n\n\n\n\n\nInfectious diseases\n\n\nPopulation dynamics\n\n\nCalculus\n\n\nDifferential Equations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSecond order ODEs\n\n\n\n\n\n\nDifferential Equations\n\n\nCalculus\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntersecting lines and linear algebra\n\n\n\n\n\n\nGeometry\n\n\nAlgebra\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraduate employment\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/GraduateEmployment.html",
    "href": "posts/GraduateEmployment.html",
    "title": "Graduate employment",
    "section": "",
    "text": "A mathematics degree will enable you to become a logical numerate problem solver. Over the course of your degree you will develop"
  },
  {
    "objectID": "posts/GraduateEmployment.html#career-earnings",
    "href": "posts/GraduateEmployment.html#career-earnings",
    "title": "Graduate employment",
    "section": "Career earnings",
    "text": "Career earnings\nMathematics degrees are associated with higher career earnings compared with many other disciplines. In the table below median salaries are compared across different disciplines. In this dataset mathematical sciences degrees have the fourth highest median salary.\n\n\n\n\n\nData provided by HESA (2020/2021)"
  },
  {
    "objectID": "posts/GraduateEmployment.html#where-our-graduates-get-employed",
    "href": "posts/GraduateEmployment.html#where-our-graduates-get-employed",
    "title": "Graduate employment",
    "section": "Where our graduates get employed?",
    "text": "Where our graduates get employed?\n\nData analyst\nActuary\nAccountant\nPhD\nData scientist\nTransport engineer\nManagement consultant\nTeacher\nOperations analyst\nFinancial engineer\nOperations research\nTax consultant\nEnergy risk analyst\nInsurance underwriter\nSoftware engineer\nCredit risk analyst\nHedge fund analyst\n\nYou can find lots of interesting information about mathematics careers here."
  },
  {
    "objectID": "posts/SecondOrderODEs.html",
    "href": "posts/SecondOrderODEs.html",
    "title": "Second order ODEs",
    "section": "",
    "text": "Ordinary differential equations\nWe can use calculus to study how quantities change in time. In the examples below we consider a second order linear ordinary differential equation (ODE) with constant coefficients.\n\n\nBackground\nYou might have previously encountered differentiation. Suppose that \\(y\\) is some function of \\(x\\).\nConsider the first order ODE\n\\[\n\\frac{dy}{dx}=1.\n\\]\nUpon integration\n\\[\ny(x)=x+C,\n\\] where \\(C\\) is an integration constant.\nWhat if \\[\n\\frac{dy}{dx}=x\n\\]\nCan you integrate this ODE?\nThe above examples are first order ODEs because the highest order derivative is one. In a second order ODE the highest derivative is two. For example \\[\n\\frac{d^2y}{dx^2}=-y\n\\tag{1}\\]\nThe solution to this ODE is\n\\[\ny(x)=A\\sin x\n+ B \\cos x\\] where \\(A\\) and \\(B\\) are integration constants. Note that you can confirm this claim by twice differentiating the solution and substituting in Equation 1.\n\n\n\n\n\n\nNewton’s Second Law\n\n\n\nSecond order ODEs arise in many different situations in applied mathematics. One of the most notable is in models of Newton’s Second Law \\[\n\\mathbf{F}=m\\mathbf{a},\n\\] where \\(\\mathbf{a}\\) represents the acceleration of a particle, \\(\\mathbf{F}\\) the resultant force acting on it and \\(m\\) the constant particle mass.\nThe acceleration can be written as the second order derivative of the particle position with respect to time, i.e. \\[\n\\mathbf{a}=\\frac{d^2\\mathbf{r}}{dt^2}.\n\\]\nIn physical situations the force term will be composed of terms that are relevant in a given situation.\nSuppose a particle is subjected to a damping force and a spring-like force centred at the origin. We might write \\[\n\\mathbf{F} = -\\eta \\frac{d \\mathbf{r}}{dt}-k\\mathbf{r}\n\\] where \\(\\eta\\) is a constant damping coefficient and \\(k\\) is a spring constant.\nHence we would obtain the second order ODE \\[\nm\\frac{d^2\\mathbf{r}}{dt^2}= -\\eta \\frac{d \\mathbf{r}}{dt}-k\\mathbf{r}.\n\\]\nUpon solving this equation we can describe the particle’s position.\n\n\nLet’s consider a scalar second order ODE with constant coefficients. Let \\(t\\) represent time and \\(y=y(t)\\). Suppose that\n\\[\na\\frac{d^2 y}{dt^2}+b\\frac{dy}{dt}+cy=0,\n\\tag{2}\\] where \\(a\\), \\(b\\) and \\(c\\) are constants.\nConsider the initial conditions\n\\[\ny(t=0)=y_0 \\quad \\quad \\frac{dy}{dt}\\bigg|_{{t=0}}=d.\n\\tag{3}\\]\nThe app in Figure 1 allows you to explore the solution of the model (Equation 2 and Equation 3).\nCan you identify the following three behaviours by adjusting model parameters:\n\nperiodic oscillations\ndamped oscillations\nexponentially decaying but non-oscillatory solutions\n\nCan you\n\ndescribe model behaviour as \\(a\\rightarrow 0\\).\nexplore model behaviour as \\(c\\rightarrow 0\\).\ndescribe how the oscillation period depends on model parameters.\n\nNote that it is possible to solve Equation 2 and Equation 3 by seeking a solution of the form \\[\ny=e^{\\lambda t}.\n\\] This is left as an exercise.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=0.01,max=3,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=15.0,value=10.0,step=0.1),             \n    ui.input_slider(id=\"c\",label=\"c\",min=0.0,max=30.0,value=5.0,step=1.0),   \n    ui.input_slider(id=\"y0\",label=\"y(t=0)\",min=0.0,max=20.0,value=5.0,step=1.0),\n    ui.input_slider(id=\"y0p\",label=\"dy/dt(t=0)\",min=0.0,max=20.0,value=1,step=1.0),\n    ui.input_slider(id=\"T\",label=\"Simulation time\",min=0.0,max=60.0,value=20.0,step=0.5),\n              \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        c=float(input.c())\n        y_0=float(input.y0())\n        y_0_p=float(input.y0p())\n        T=float(input.T())\n        \n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(y,t,a,b,c):\n          rhs=np.zeros_like(y,dtype=float)\n\n          z=y[1]\n\n          #ay'' + by'+cy=0\n          # y'=z\n          # z'=y''=-(by'+cy)/a\n\n\n          dy_dt=y[1]\n          dz_dt=-(b*z+c*y[0])/a\n\n          rhs[0]=dy_dt\n          rhs[1]=dz_dt\n\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[y_0,y_0_p]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_pop_model, init_cond,t,args=(a,b,c))\n\n        # Plot results\n        y=sol1[:,0]\n        yp=sol1[:,1]\n        \n        \n        ax.plot(t, y)\n        ax.set_xlabel('$t$')\n        ax.set_ylabel('$y(t)$')\n\n        plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) are studied in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the modules Computer algebra and dynamical systems and Introduction to Programming you would be introduced to techniques that are used to compute numerical solutions to differential equations.\nAt Level 3 in the module Differential Equations you would extend your knowledge of differential equations to include concepts such as Fourier Series and Partial Differential Equations. In the modules Mathematical Biology I and Mathematical Biology II you would also learn how to formulate and study mathematical models of biological systems.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/AffineTransformation.html",
    "href": "posts/AffineTransformation.html",
    "title": "Affine transformations in the plane",
    "section": "",
    "text": "An affine transformation is a geometric transformation that preserves lines and parallelism, but not necessarily Euclidean distances and angles. Examples of affine transformations include:\n\ntranslations\nshears\nrotations\nScalings\n\nIn the app in Figure 1 you can explore transformation of a set of points.\n\nAre straight lines preserved for all transformations?\nFor which transformations are the angles between neighbouring points preserved?\ndoes an inverse transformation exist (i.e. an additional transformation that maps the black square back on to the red one?)\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 600\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport skimage as ski\nimport pyodide\nfrom skimage.transform import SimilarityTransform\nfrom skimage.transform import warp\nfrom skimage.transform import PiecewiseAffineTransform\nfrom skimage.transform import AffineTransform\nfrom skimage.io import imread\nimport io\nfrom pathlib import Path\nfrom skimage.transform import resize, rescale\n\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"Rotation\",label=\"Rotation\",min=-2.0*np.pi,max=2.0*np.pi,value=0.0,step=np.pi/20.0),\n    ui.input_slider(id=\"Scale\",label=\"Scale\",min=0.1,max=3.0,value=1.0,step=0.1),\n    ui.input_slider(id=\"Shear\",label=\"Shear\",min=-3.0,max=3.0,value=0.0,step=0.1),\n    ui.input_slider(id=\"translate_x\",label=\"translate_x\",min=-3.0,max=3.0,value=1.0,step=0.1),\n    ui.input_slider(id=\"translate_y\",label=\"translate_y\",min=-3.0,max=3.0,value=1.0,step=0.1)),\n    ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    \n    @render.plot\n    def plot():\n        # Calculate the translation required to move all points into positive coordinates\n\n        translation_vec=[input.translate_x(),input.translate_y()]\n        scale_param=input.Scale()\n        shear_param=input.Shear()\n        rotation_param=input.Rotation()\n        tform_shift = AffineTransform(translation=translation_vec,scale=scale_param,shear=shear_param,rotation=rotation_param)\n        homog_trans_matrix=tform_shift.params\n\n\n        old_coordinates=[[0,0,1.0],[0,1,1.0],[0,2,1.0],[0,3,1.0],[0,4,1.0],\n        [4.0,0,1.0],[4.0,1,1.0],[4.0,2,1.0],[4.0,3,1.0],[4.0,4,1.0],\n        [1.0,0.0,1.0],[2.0,0.0,1.0],[3.0,0.0,1.0],\n        [1.0,4.0,1.0],[2.0,4.0,1.0],[3.0,4.0,1.0]]\n        old_coordinates=np.array(old_coordinates)\n\n        new_coordinates=old_coordinates.copy()\n\n        for i in range(old_coordinates.shape[0]):\n\n            homog_vec=np.array(old_coordinates[i,:]).copy()\n            new_coordinates[i,:]=homog_trans_matrix@homog_vec\n\n\n\n        fig,ax=plt.subplots()\n        ax.plot()\n        ax.set_xticks(np.arange(-10,10))\n        ax.set_yticks(np.arange(-10,10))\n        ax.plot(old_coordinates[:,0],old_coordinates[:,1],'r*')\n        ax.plot(new_coordinates[:,0],new_coordinates[:,1],'k*')\n\n        ax.grid(True)\n        plt.axis('equal')\n        ax.set_xlim([-10,10])\n        ax.set_ylim([-10,10])\n        ax.legend(['Original','Transformed'])\n        plt.show()\n\napp = App(app_ui, server)\n\n\n\n\nFigure 1\n\n\n\nAt Dundee, concepts from geometry are studied in core modules Maths 1A and Maths 1B.\nAt Level 3 in the module Differential Geometry students study generalisations of 2D mappings to arbitrarily curved spaces.\nYou can find out more about these modules here. :::"
  },
  {
    "objectID": "posts/EstimatingPi.html",
    "href": "posts/EstimatingPi.html",
    "title": "Estimating pi",
    "section": "",
    "text": "Consider a circle of radius \\(R\\) centred at the origin.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nThe equation of the circle is given by \\[\nx^2+y^2=R^2.\n\\tag{1}\\]\nThe area of the circle is given by the familiar formula\n\\[\n\\pi R^2.\n\\]\nThe smallest square within which the circle can be inscribed will have side length \\(2R\\).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nHence the ratio of the area of the circle to that of the square is\n\\[\n\\frac{\\pi R^2}{4 R^2}=\\frac{\\pi}{4}.\n\\]\n\n\n\nWe can use the above result to estimate \\(\\pi\\) by randomly sampling points that sit inside the square. The probability of a randomly sampled point falling inside the inscribed circle in Figure 2 is equal to the ratio of the areas, i.e. \\[\n\\frac{\\pi}{4}.\n\\]\nWe can use a random number generator to uniformly sample \\(N_s\\) points within the square, i.e.  \\[\nx_i \\in U_{0,2R}, \\quad y_i \\in U_{0,2R}, \\quad i=1,..,N.\n\\] Here \\(U\\) represents a uniform distribution and \\(N\\) is the number of sampled points.\nWe can then count the number of randomly sampled points, \\(N_c\\), that sit inside the circle, i.e. with coordinates that satisfy the inequality \\[\nx_i^2+y_i^2&lt; R^2.\n\\]\nWe can then estimate \\(\\pi\\) using the formula \\[\n\\hat{\\pi}\\sim 4\\frac{N_c}{N_s}.\n\\]\nIn Figure 3 we use an app to explore the approximation of \\(\\pi\\). Here you can explore how the estimate for \\(\\pi\\) depends on the number of samples and consider circles of different radii.\nIn the top plot the distribution of sampled points is plotted for a given realisation with the parameter values as you have chosen. In the bottom plot the estimate of \\(\\pi\\) is averaged over 100 realisations and plotted against the number of sampled points, \\(N\\).\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"N\",label=\"Num points per experiment\",min=10,max=3000,value=10,step=1),\n    ui.input_slider(id=\"R\",label=\"Radius\",min=2.0,max=15.0,value=10.0,step=1),\n    ui.input_slider(id=\"L\",label=\"Square side length\",min=15.0,max=30.0,value=20.0,step=1),  \n    ui.input_slider(id=\"N_Exp\",label=\"Num experiments\",min=1,max=300,value=1,step=1),           \n     \n              \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def estimate_pi(N,R,L): \n        x = np.random.uniform(0,L,N)\n        y = np.random.uniform(0,L,N)\n\n        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n        num_points_inside_circle=len(radius[radius&lt;=R])\n\n        pi_est=(L/R)**2*(num_points_inside_circle/N)\n\n        return x,y,pi_est\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(2,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        N=int(input.N())\n        R=float(input.R())\n        L=float(input.L())\n        n_samples=int(input.N_Exp())\n        \n    \n        x,y,pi_est=estimate_pi(N,R,L)\n\n        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n        \n        ax[0].plot(x[radius&lt;R],y[radius&lt;R],'b.')\n        ax[0].plot(x[radius&gt;R],y[radius&gt;R],'k.')\n\n        ax[0].set_xlabel('$x$')\n        ax[0].set_ylabel('$y$')\n\n        theta=np.linspace(0,2*np.pi,1000)\n        ax[0].plot(R*np.cos(theta)+L/2.0,R*np.sin(theta)+L/2.0,'r')\n        ax[0].set_title('$\\hat{\\pi}$='+str(pi_est))\n\n        \n        N_vec=np.linspace(10,3000,80,dtype=int)\n        pi_est_vec=np.zeros_like(N_vec,dtype=float)\n        for i in range(len(N_vec)):\n            pi_est_i=np.zeros((n_samples,1),dtype=float)\n            for j in range(n_samples):\n                x,y,pi_est=estimate_pi(N_vec[i],R,L)\n                pi_est_i[j]=pi_est\n            pi_est_vec[i]=np.mean(pi_est_i)\n\n        ax[1].plot(N_vec,pi_est_vec,'.',N_vec,np.pi*np.ones_like(N_vec))\n        ax[1].set_xlabel('$N$')\n        ax[1].set_ylabel('$\\hat{\\pi}$')\n        #plt.Circle([0.0, 0.0 ],R,fill = False,axis=ax)\n        #ax.Circle((0.0, 0.0 ),R,fill = False )\n\n\n        fig.tight_layout()\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 3"
  },
  {
    "objectID": "posts/EstimatingPi.html#a-circle",
    "href": "posts/EstimatingPi.html#a-circle",
    "title": "Estimating pi",
    "section": "",
    "text": "Consider a circle of radius \\(R\\) centred at the origin.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nThe equation of the circle is given by \\[\nx^2+y^2=R^2.\n\\tag{1}\\]\nThe area of the circle is given by the familiar formula\n\\[\n\\pi R^2.\n\\]\nThe smallest square within which the circle can be inscribed will have side length \\(2R\\).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nHence the ratio of the area of the circle to that of the square is\n\\[\n\\frac{\\pi R^2}{4 R^2}=\\frac{\\pi}{4}.\n\\]"
  },
  {
    "objectID": "posts/EstimatingPi.html#estimating-pi-1",
    "href": "posts/EstimatingPi.html#estimating-pi-1",
    "title": "Estimating pi",
    "section": "",
    "text": "We can use the above result to estimate \\(\\pi\\) by randomly sampling points that sit inside the square. The probability of a randomly sampled point falling inside the inscribed circle in Figure 2 is equal to the ratio of the areas, i.e. \\[\n\\frac{\\pi}{4}.\n\\]\nWe can use a random number generator to uniformly sample \\(N_s\\) points within the square, i.e.  \\[\nx_i \\in U_{0,2R}, \\quad y_i \\in U_{0,2R}, \\quad i=1,..,N.\n\\] Here \\(U\\) represents a uniform distribution and \\(N\\) is the number of sampled points.\nWe can then count the number of randomly sampled points, \\(N_c\\), that sit inside the circle, i.e. with coordinates that satisfy the inequality \\[\nx_i^2+y_i^2&lt; R^2.\n\\]\nWe can then estimate \\(\\pi\\) using the formula \\[\n\\hat{\\pi}\\sim 4\\frac{N_c}{N_s}.\n\\]\nIn Figure 3 we use an app to explore the approximation of \\(\\pi\\). Here you can explore how the estimate for \\(\\pi\\) depends on the number of samples and consider circles of different radii.\nIn the top plot the distribution of sampled points is plotted for a given realisation with the parameter values as you have chosen. In the bottom plot the estimate of \\(\\pi\\) is averaged over 100 realisations and plotted against the number of sampled points, \\(N\\).\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"N\",label=\"Num points per experiment\",min=10,max=3000,value=10,step=1),\n    ui.input_slider(id=\"R\",label=\"Radius\",min=2.0,max=15.0,value=10.0,step=1),\n    ui.input_slider(id=\"L\",label=\"Square side length\",min=15.0,max=30.0,value=20.0,step=1),  \n    ui.input_slider(id=\"N_Exp\",label=\"Num experiments\",min=1,max=300,value=1,step=1),           \n     \n              \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def estimate_pi(N,R,L): \n        x = np.random.uniform(0,L,N)\n        y = np.random.uniform(0,L,N)\n\n        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n        num_points_inside_circle=len(radius[radius&lt;=R])\n\n        pi_est=(L/R)**2*(num_points_inside_circle/N)\n\n        return x,y,pi_est\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(2,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        N=int(input.N())\n        R=float(input.R())\n        L=float(input.L())\n        n_samples=int(input.N_Exp())\n        \n    \n        x,y,pi_est=estimate_pi(N,R,L)\n\n        radius=((x-L/2)**2+(y-L/2)**2)**(0.5)\n        \n        ax[0].plot(x[radius&lt;R],y[radius&lt;R],'b.')\n        ax[0].plot(x[radius&gt;R],y[radius&gt;R],'k.')\n\n        ax[0].set_xlabel('$x$')\n        ax[0].set_ylabel('$y$')\n\n        theta=np.linspace(0,2*np.pi,1000)\n        ax[0].plot(R*np.cos(theta)+L/2.0,R*np.sin(theta)+L/2.0,'r')\n        ax[0].set_title('$\\hat{\\pi}$='+str(pi_est))\n\n        \n        N_vec=np.linspace(10,3000,80,dtype=int)\n        pi_est_vec=np.zeros_like(N_vec,dtype=float)\n        for i in range(len(N_vec)):\n            pi_est_i=np.zeros((n_samples,1),dtype=float)\n            for j in range(n_samples):\n                x,y,pi_est=estimate_pi(N_vec[i],R,L)\n                pi_est_i[j]=pi_est\n            pi_est_vec[i]=np.mean(pi_est_i)\n\n        ax[1].plot(N_vec,pi_est_vec,'.',N_vec,np.pi*np.ones_like(N_vec))\n        ax[1].set_xlabel('$N$')\n        ax[1].set_ylabel('$\\hat{\\pi}$')\n        #plt.Circle([0.0, 0.0 ],R,fill = False,axis=ax)\n        #ax.Circle((0.0, 0.0 ),R,fill = False )\n\n\n        fig.tight_layout()\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 3"
  },
  {
    "objectID": "posts/RecurrenceRelations.html",
    "href": "posts/RecurrenceRelations.html",
    "title": "Recurrence relations and chaos",
    "section": "",
    "text": "You might have previously encountered a recurrence relation of the form\n\\[\nu_{n+1}=au_n+b\n\\tag{1}\\] where \\(a\\) and \\(b\\) are constants.\nGiven numerical values for \\(a\\) and \\(b\\) and an initial condition, \\(u_0\\), a sequence can be computed that is a solution to Equation 1. This type of task is laborious and well suited to a computer (see Figure 1).\n\n\n\n\n\n\nA typical Higher-like question\n\n\n\nThe population of Dundonian hobbits is observed to be declining by 5% per year. To increase the population, it is planned that 1000 of the species will be released at the end of May each year.\nLet \\(u_n\\) represent the population of the hobbits at the beginning of June, \\(n\\) years after the first annual reintroduction into the population.\nSuppose that \\(u_n\\) and \\(u_{n+1}\\) satisfy the recurrence relation \\[\nu_{n+1}=au_n+b,\n\\] where \\(a\\) and \\(b\\) are constants.\n\nState the values of \\(a\\) and \\(b\\).\nExplain whether or not the population of the Dundonian hobbit will stabilise in the long term.\nThe population of Dundonian hobbits at the beginning of the reintroduction programme was estimated at 5000. Explain whether or not the population will ever exceed 10000.\n\n\n\nExplore how the computed solution depend on model parameters as follows:\n\nset \\(b=0\\) by varying the parameter \\(a\\) identify solutions that:\n\ntend to zero monotonically\noscillate about 0\nblow up\n\nset b&gt;0\n\nshow that the solution converges to a non-zero value in the case where \\(0&lt;a&lt;1\\).\nshow that the solution is oscillatory for \\(-1&lt;a&lt;0\\).\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-1.0,max=3,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=15.0,value=10.0,step=0.01),             \n     \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=20.0,value=5.0,step=1.0),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n              \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        u0=float(input.u0())\n        T=int(input.T())\n       \n        # Define rhs of LV ODEs\n        def rhs_pop_model(y,t,a,b):\n          \n\n          rhs=a*y+b\n\n          return rhs\n        def DiscreteSol(rhs_pop_model,y_0,t,a,b):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n                    y[i]=rhs_pop_model(y[i-1],t[i],a,b)\n            return y\n\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(rhs_pop_model,init_cond,t,a,b)\n\n        # Plot results\n        y=sol1\n        \n        ax.plot(t,y)\n        ax.set_xlabel('$n$')\n        ax.set_ylabel('$u_n$')\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1\n\n\n\n\n\n\nThe recurrence relation explored in Figure 1 is linear (the right-hand-side is a linear function of \\(u_n\\)). When the model is generalised much richer dynamical behaviours can be observed. One famous example is the logistic map, where the governing equation can be written as \\[\nu_{n+1}=ru_n(1-u_n).\n\\tag{2}\\]\nNote that the right-hand side is now a quadratic function of \\(u_n\\).\nYou can explore the solutions to Equation 2 using Figure 2.\n\nshow that when \\(0&lt;r&lt;1\\) the solution converges monotonically to 0.0.\nshow that when \\(0&lt;r&lt;2\\) the solution converges monotonically to a non-zero value.\nshow that when \\(2&lt;r&lt;3\\) the solution is oscillatory and converges to a non-zero value.\nshow that when \\(r=3.2\\) the solution is periodic and repeats every second step\nshow that when \\(r=3.47\\) the solution is periodic and repeats every fourth step\nshow that when \\(r=3.7\\) that the solution is neither periodic nor reaches a steady value.\nuse the \\(r \\  \\textrm{zoomed}\\) and \\(u \\ \\textrm{zoomed}\\) sliders to magnify the third figure. Can you see self similarity (i.e. at fine scales the bifurcation structure looks similar to that at large scales?).\n\nThe logistic map provides one of the simplest mathematical formulations of a phenomenon known as chaos. Whilst a precise definition of chaos involves some technical concepts, chaotic systems are broadly characterised by:\n\nhaving non-periodic, non-steady solution\nsensitivity to initial conditions\nappearing to be unpredictable even through they are deterministic.\nself similarity\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"r\",label=\"r\",min=0.0,max=5.0,value=0.1,step=0.001),             \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=1.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n    ui.input_slider(id=\"r_range\",label=\"r zoomed\",min=0.0,max=4.0,value=[0.0,4.0],step=0.001),\n    ui.input_slider(id=\"u_range\",label=\"u zoomed\",min=0.0,max=1.0,value=[0.0,1.0],step=0.01),\n              \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(3,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        u0=float(input.u0())\n        T=int(input.T())\n        r_min=float(input.r_range()[0])\n        r_max=float(input.r_range()[1])\n        u_min=float(input.u_range()[0])\n        u_max=float(input.u_range()[1])\n\n\n        # Define rhs of logistic map \n        def logistic_map(y,t,r):\n          rhs=r*y*(1-y)\n          return rhs\n        \n        def DiscreteSol(rhs_pop_model,y_0,t,r):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n\n                    y[i]=rhs_pop_model(y[i-1],t[i],r)\n            return y\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(logistic_map,init_cond,t,r)\n\n        # Plot results\n        y=sol1\n        \n        ax[0].plot(t,y)\n        ax[0].set_xlabel('$n$')\n        ax[0].set_ylabel('$u_n$')\n\n        plt.grid()\n\n        # Parameters\n        n_iterations = 1000  # total iterations for each value of r\n        n_last = 100         # number of iterations to plot (for steady state)\n        r_values = np.linspace(0.0, 4.0, 10000)  # range of r values\n        u0 = 0.5  # initial population (seed)\n\n        delta=0.25\n        #r_min=r-delta\n        #r_max=r+delta\n\n        r_values2 = np.linspace(r_min, r_max, 10000)  # range of r values\n\n        # Initialize plot\n        x = np.full_like(r_values, u0)\n        x2 = np.full_like(r_values2, u0)\n\n        # Iterate and plot bifurcation diagram\n         \n        for _ in range(n_iterations):\n            x = r_values * x * (1 - x)  # logistic map function\n            x2 = r_values2 * x2 * (1 - x2)  # logistic map function\n\n            if _ &gt;= (n_iterations - n_last):  # plot only steady state\n                ax[1].plot(r_values, x, ',k', alpha=0.25)\n                ax[1].plot([r,r],[0,1],'r--')\n                ax[2].plot(r_values2, x2, ',k', alpha=0.25)\n                ax[2].plot([r,r],[0,1],'r--')\n\n            # Labels and display\n            ax[1].set_title(\"Bifurcation Diagram\")\n            ax[1].set_xlabel(\"$r$\")\n            ax[1].set_ylabel(\"$u^*$\")\n            ax[2].set_title(\"Bifurcation Diagram (zoomed in) \")\n            ax[2].set_xlabel(\"$r$\")\n            ax[2].set_ylabel(\"$u^*$\")\n            ax[2].set_xlim([r_min,r_max])\n            ax[2].set_ylim([u_min,u_max])\n\n\n\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) and algebra that are needed to study dynamical systems are introduced in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the module Discrete Maths you would be introduced to discrete dynamical systems (e.g. recurrence relations, Markov chains). In the modules Introduction to Programming and Computer Algebra and Dynamical systems you would be introduced to techniques that enable you to numerically analyse difference equations.\nAt Level 3 in the module Mathematical Biology you would consider discrete dynamical systems model applied to Biological systems.\nAt Level 4 we offer a number of honours projects that investigate chaotic systems (e.g. the Lorenz equations, the double pendulum)\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/RecurrenceRelations.html#a-linear-recurrence-relation",
    "href": "posts/RecurrenceRelations.html#a-linear-recurrence-relation",
    "title": "Recurrence relations and chaos",
    "section": "",
    "text": "You might have previously encountered a recurrence relation of the form\n\\[\nu_{n+1}=au_n+b\n\\tag{1}\\] where \\(a\\) and \\(b\\) are constants.\nGiven numerical values for \\(a\\) and \\(b\\) and an initial condition, \\(u_0\\), a sequence can be computed that is a solution to Equation 1. This type of task is laborious and well suited to a computer (see Figure 1).\n\n\n\n\n\n\nA typical Higher-like question\n\n\n\nThe population of Dundonian hobbits is observed to be declining by 5% per year. To increase the population, it is planned that 1000 of the species will be released at the end of May each year.\nLet \\(u_n\\) represent the population of the hobbits at the beginning of June, \\(n\\) years after the first annual reintroduction into the population.\nSuppose that \\(u_n\\) and \\(u_{n+1}\\) satisfy the recurrence relation \\[\nu_{n+1}=au_n+b,\n\\] where \\(a\\) and \\(b\\) are constants.\n\nState the values of \\(a\\) and \\(b\\).\nExplain whether or not the population of the Dundonian hobbit will stabilise in the long term.\nThe population of Dundonian hobbits at the beginning of the reintroduction programme was estimated at 5000. Explain whether or not the population will ever exceed 10000.\n\n\n\nExplore how the computed solution depend on model parameters as follows:\n\nset \\(b=0\\) by varying the parameter \\(a\\) identify solutions that:\n\ntend to zero monotonically\noscillate about 0\nblow up\n\nset b&gt;0\n\nshow that the solution converges to a non-zero value in the case where \\(0&lt;a&lt;1\\).\nshow that the solution is oscillatory for \\(-1&lt;a&lt;0\\).\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-1.0,max=3,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=15.0,value=10.0,step=0.01),             \n     \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=20.0,value=5.0,step=1.0),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n              \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        u0=float(input.u0())\n        T=int(input.T())\n       \n        # Define rhs of LV ODEs\n        def rhs_pop_model(y,t,a,b):\n          \n\n          rhs=a*y+b\n\n          return rhs\n        def DiscreteSol(rhs_pop_model,y_0,t,a,b):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n                    y[i]=rhs_pop_model(y[i-1],t[i],a,b)\n            return y\n\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(rhs_pop_model,init_cond,t,a,b)\n\n        # Plot results\n        y=sol1\n        \n        ax.plot(t,y)\n        ax.set_xlabel('$n$')\n        ax.set_ylabel('$u_n$')\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1"
  },
  {
    "objectID": "posts/RecurrenceRelations.html#the-logistic-map",
    "href": "posts/RecurrenceRelations.html#the-logistic-map",
    "title": "Recurrence relations and chaos",
    "section": "",
    "text": "The recurrence relation explored in Figure 1 is linear (the right-hand-side is a linear function of \\(u_n\\)). When the model is generalised much richer dynamical behaviours can be observed. One famous example is the logistic map, where the governing equation can be written as \\[\nu_{n+1}=ru_n(1-u_n).\n\\tag{2}\\]\nNote that the right-hand side is now a quadratic function of \\(u_n\\).\nYou can explore the solutions to Equation 2 using Figure 2.\n\nshow that when \\(0&lt;r&lt;1\\) the solution converges monotonically to 0.0.\nshow that when \\(0&lt;r&lt;2\\) the solution converges monotonically to a non-zero value.\nshow that when \\(2&lt;r&lt;3\\) the solution is oscillatory and converges to a non-zero value.\nshow that when \\(r=3.2\\) the solution is periodic and repeats every second step\nshow that when \\(r=3.47\\) the solution is periodic and repeats every fourth step\nshow that when \\(r=3.7\\) that the solution is neither periodic nor reaches a steady value.\nuse the \\(r \\  \\textrm{zoomed}\\) and \\(u \\ \\textrm{zoomed}\\) sliders to magnify the third figure. Can you see self similarity (i.e. at fine scales the bifurcation structure looks similar to that at large scales?).\n\nThe logistic map provides one of the simplest mathematical formulations of a phenomenon known as chaos. Whilst a precise definition of chaos involves some technical concepts, chaotic systems are broadly characterised by:\n\nhaving non-periodic, non-steady solution\nsensitivity to initial conditions\nappearing to be unpredictable even through they are deterministic.\nself similarity\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"r\",label=\"r\",min=0.0,max=5.0,value=0.1,step=0.001),             \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=1.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n    ui.input_slider(id=\"r_range\",label=\"r zoomed\",min=0.0,max=4.0,value=[0.0,4.0],step=0.001),\n    ui.input_slider(id=\"u_range\",label=\"u zoomed\",min=0.0,max=1.0,value=[0.0,1.0],step=0.01),\n              \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(3,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        u0=float(input.u0())\n        T=int(input.T())\n        r_min=float(input.r_range()[0])\n        r_max=float(input.r_range()[1])\n        u_min=float(input.u_range()[0])\n        u_max=float(input.u_range()[1])\n\n\n        # Define rhs of logistic map \n        def logistic_map(y,t,r):\n          rhs=r*y*(1-y)\n          return rhs\n        \n        def DiscreteSol(rhs_pop_model,y_0,t,r):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n\n                    y[i]=rhs_pop_model(y[i-1],t[i],r)\n            return y\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(logistic_map,init_cond,t,r)\n\n        # Plot results\n        y=sol1\n        \n        ax[0].plot(t,y)\n        ax[0].set_xlabel('$n$')\n        ax[0].set_ylabel('$u_n$')\n\n        plt.grid()\n\n        # Parameters\n        n_iterations = 1000  # total iterations for each value of r\n        n_last = 100         # number of iterations to plot (for steady state)\n        r_values = np.linspace(0.0, 4.0, 10000)  # range of r values\n        u0 = 0.5  # initial population (seed)\n\n        delta=0.25\n        #r_min=r-delta\n        #r_max=r+delta\n\n        r_values2 = np.linspace(r_min, r_max, 10000)  # range of r values\n\n        # Initialize plot\n        x = np.full_like(r_values, u0)\n        x2 = np.full_like(r_values2, u0)\n\n        # Iterate and plot bifurcation diagram\n         \n        for _ in range(n_iterations):\n            x = r_values * x * (1 - x)  # logistic map function\n            x2 = r_values2 * x2 * (1 - x2)  # logistic map function\n\n            if _ &gt;= (n_iterations - n_last):  # plot only steady state\n                ax[1].plot(r_values, x, ',k', alpha=0.25)\n                ax[1].plot([r,r],[0,1],'r--')\n                ax[2].plot(r_values2, x2, ',k', alpha=0.25)\n                ax[2].plot([r,r],[0,1],'r--')\n\n            # Labels and display\n            ax[1].set_title(\"Bifurcation Diagram\")\n            ax[1].set_xlabel(\"$r$\")\n            ax[1].set_ylabel(\"$u^*$\")\n            ax[2].set_title(\"Bifurcation Diagram (zoomed in) \")\n            ax[2].set_xlabel(\"$r$\")\n            ax[2].set_ylabel(\"$u^*$\")\n            ax[2].set_xlim([r_min,r_max])\n            ax[2].set_ylim([u_min,u_max])\n\n\n\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) and algebra that are needed to study dynamical systems are introduced in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the module Discrete Maths you would be introduced to discrete dynamical systems (e.g. recurrence relations, Markov chains). In the modules Introduction to Programming and Computer Algebra and Dynamical systems you would be introduced to techniques that enable you to numerically analyse difference equations.\nAt Level 3 in the module Mathematical Biology you would consider discrete dynamical systems model applied to Biological systems.\nAt Level 4 we offer a number of honours projects that investigate chaotic systems (e.g. the Lorenz equations, the double pendulum)\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/Cryptography.html",
    "href": "posts/Cryptography.html",
    "title": "Cryptography",
    "section": "",
    "text": "Cryptography is the practice and study of techniques for securing communication and information against unauthorized access, modification, or forgery. It is used to protect sensitive data by transforming it into a format that is difficult for unintended recipients to understand or manipulate. This transformation often relies on mathematical algorithms and cryptographic keys."
  },
  {
    "objectID": "posts/Cryptography.html#cryptography",
    "href": "posts/Cryptography.html#cryptography",
    "title": "Cryptography",
    "section": "",
    "text": "Cryptography is the practice and study of techniques for securing communication and information against unauthorized access, modification, or forgery. It is used to protect sensitive data by transforming it into a format that is difficult for unintended recipients to understand or manipulate. This transformation often relies on mathematical algorithms and cryptographic keys."
  },
  {
    "objectID": "posts/Cryptography.html#decrypting-an-encrypted-message",
    "href": "posts/Cryptography.html#decrypting-an-encrypted-message",
    "title": "Cryptography",
    "section": "Decrypting an encrypted message",
    "text": "Decrypting an encrypted message\nSuppose you happen upon the encrypted message:\n9995fc19ee935e80d28b19db3709a9ce414ec1bd29cd006115114fbd6bd2f6e5cb84aec0d6468233e1\nIf you paste the message into Figure 1, you can decrypt it if you can guess the shared secret used to encrypt the original message (Hint: use the slider to try different values of the shared secret … it is smaller than 100 for this example).\nNote it may take a few moments for the code needed to run the app below to get installed via your web browser. It is advised to do this on a computer rather than a phone as it requires an approx. 20 MB download.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 200\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nimport base64\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"shared_secret\",label=\"Shared secret\",min=10,max=3000,value=31,step=1),\n    ui.input_text(id='text',label=\"Message to decrypt\",value=\"8968d20bbc5b\"),\n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n\n    \n    def decrypt_message(key, iv, ciphertext):\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        decryptor = cipher.decryptor()\n        plaintext = decryptor.update(ciphertext) + decryptor.finalize()\n        return plaintext\n\n\n\n    @render.table\n    def result():\n        # list of strings\n        shared_secret=int(input.shared_secret())\n        encrypted_text=str(input.text())\n\n        encrypted_text=bytes.fromhex(encrypted_text)\n\n\n\n\n        #text=text.encode(encoding=\"utf-8\")\n        #encrypted_text = encrypted_text.encode('ISO-8859-1')\n\n        shared_secret_bytes=shared_secret.to_bytes(16,'big')\n        derived_key = HKDF(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=None,\n            info=b\"diffie-hellman-key-exchange\",\n        ).derive(shared_secret_bytes)\n        \n        \n        iv=5\n        iv=iv.to_bytes(16, 'big')\n                \n        decrypted_message = decrypt_message(derived_key, iv, encrypted_text)\n\n       \n        data_dict = {\n            'Decrypted Message':[decrypted_message]\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\napp = App(app_ui, server)\n\n\nFigure 1\n\n\n\nThe encryption in Figure 1 is happening via algorithms (hash functions) that take an input and produce a fixed-size string of characters, which is unique to the input data. In Figure 2 you can encrypt a message using a hash-function. The shared secret is the number that is required to encrypt the message. You can decrypt your own message using Figure 1.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 200\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"shared_secret\",label=\"shared secret\",min=10,max=3000,value=23,step=1),\n    ui.input_text(id='text',label=\"Message to encrypt\",value=\"Yarrrr\"),\n         \n     \n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def encrypt_message(key, plaintext):\n        iv=5\n        iv=iv.to_bytes(16, 'big')\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        encryptor = cipher.encryptor()\n        ciphertext = encryptor.update(plaintext) + encryptor.finalize()\n        return iv,ciphertext\n    \n\n\n\n    @render.table\n    def result():\n        # list of strings\n        shared_secret=int(input.shared_secret())\n        text=input.text()\n        # Step 1: Generate Diffie-Hellman Parameters and Keys\n       \n\n        #shared_secret=int(np.mod(g**(a*b),p))\n        shared_secret_bytes=shared_secret.to_bytes(16,'big')\n        #shared_secret=g**(a*b)\n        derived_key = HKDF(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=None,\n            info=b\"diffie-hellman-key-exchange\",\n        ).derive(shared_secret_bytes)\n        \n        # Step 4: Encrypt a Message Using AES\n        message = text.encode(encoding=\"utf-8\")\n        iv, ciphertext = encrypt_message(derived_key, message)\n\n         # Decrypt the message\n        data_dict = {\n            'Encrypted Message':[ciphertext.hex()],\n            'Encrypted Message':[ciphertext.hex()],\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\n   \napp = App(app_ui, server)\n\n\nFigure 2\n\n\n\nThe problem with the above encryption is that two parties must somehow safely share a secret in order that they can encrypt/decrypt messages. This is where the interesting mathematics happens!\n\nGenerating a shared secret\nThe Diffie-Hellman algorithm is used for two parties (Alice and Bob) to safely share a secret.\nSome publicly shared information is firstly agreed between the two parties: a prime number, \\(p\\), and a generator \\(g&lt;p\\). We need to use Number Theory and Group Theory to identify safe values for \\(g\\) and \\(p\\). But not today!\nAlice and Bob then both generate their own private keys: \\(x\\) and \\(y\\). These numbers are not publicly shared.\nAlice uses her private key and the shared information to compute her public key\n\\[\nX=g^x \\pmod p.\n\\]\n\n\n\n\n\n\nModular arithmetic\n\n\n\nThe Diffie Helmann algorithm uses modular arithmetic. Writing \\[\nX=g^x \\pmod p,\n\\] the number \\(X\\) is the remainder when the number \\(g^x\\) is divided by \\(p\\). For example, if \\(g=2\\), \\(x=3\\) and \\(p=5\\) then\n\\[\ng^x=2^3=8.\n\\]\nThe remainder when divided by 5 is 3. Hence for this example \\[\ng^x \\pmod p= 2^3 \\pmod 5 = 3.\n\\]\n\n\nSimilarly, Bob uses his private key to compute \\[\nY=g^y \\pmod p.\n\\]\nAlice and Bob now exchange their public keys \\(X\\) and \\(Y\\). Alice uses Bob’s public key to compute\n\\[\nY^x \\pmod p\n\\]\nSimilarly, Bob uses Alice’s public key to compute \\[\nX^y \\pmod p.\n\\]\nBecause of the commutativity of multiplication of exponents \\[\ns=Y^x\\pmod p = g^{xy}\\pmod p = X^y\\pmod p\n\\]\nHence Alice and Bob both have a shared secret. They can use this shared secret to encrypt/decrypt messages using hash functions.\nYou can explore the generation of a shared secret in Figure 3.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 450\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"p\",label=\"p\",min=10,max=3000,value=23,step=1),\n    ui.input_slider(id=\"g\",label=\"g (generator)\",min=0,max=15.0,value=5,step=1),\n    ui.input_slider(id=\"a\",label=\"Private key Bob\",min=1,max=10,value=2,step=1),\n    ui.input_slider(id=\"b\",label=\"Private key Alice\",min=1,max=10,value=3,step=1), \n    \n         \n     \n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n        \n\n\n\n    @render.table\n    def result():\n        # list of strings\n        p=int(input.p())\n        g=int(input.g())\n        a=int(input.a())\n        b=int(input.b())\n        # Step 1: Generate Diffie-Hellman Parameters and \n\n\n        alice_public_key=int(np.mod(g**(a),p))\n        bob_public_key=int(np.mod(g**(b),p))\n\n        shared_secret=int(np.mod(g**(a*b),p))\n        \n     \n        data_dict = {\n            'p': [p],\n            'g': [g],\n            'Alice public key': [alice_public_key],\n            'Bob public key': [bob_public_key],\n            'Shared secret': [shared_secret],\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\n         \n\n\napp = App(app_ui, server)\n\n\nFigure 3\n\n\n\n\n\nThe discrete logarithm problem\nFor security of the Diffie Hellman algorithm it is required that the shared secret cannot be easily deduced from the publicly available information. If, for example, an outsider were to identify Alice’s private key, \\(x\\), then they could easily compute the shared secret\n\\[\nY^x \\pmod p\n\\] and therefore decrypt the message.\nConsider the publicly available information: \\(p\\), \\(g\\) and the public key \\(X\\) and \\(Y\\). To obtain the shared secret a hacker could try to solve the following problem\n\\[\ng^x \\pmod p = X,\n\\]\nwhere \\(x\\) is Alice’s private key. This is known as the discrete logarithm problem . In Figure 4 you can explore how an observer could identify Alice’s private key, \\(x\\) (where the marker sits on the horizontal line). The key point from the figure is that it is difficult to guess what the value of the variable on the \\(x\\) axis will give rise to a desired value on the \\(y\\) axis.\nIt can be proven (mathematically) that when \\(p\\) and \\(g\\) are chosen appropriately that there are not efficient methods to solve this problem. Hence the Diffie-Hellman is secure given appropriate choices for \\(p\\) and \\(g\\).\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"p\",label=\"p (prime number)\",min=5,max=300,value=23,step=1),\n    ui.input_slider(id=\"g\",label=\"g (generator)\",min=0,max=30,value=5,step=1),\n    ui.input_slider(id=\"s\",label=\"Public key\",min=1,max=100,value=5,step=1),      \n            ),\n\n        \n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    \n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        p=int(input.p())\n        g=int(input.g())\n        s=int(input.s())\n        \n    \n    \n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$f$')\n\n       \n        a_vec=np.linspace(0,p-1,p,dtype=int)\n        \n        function_mod=(g**a_vec)%p\n        ax.plot(a_vec,function_mod,'x',a_vec,np.ones_like(a_vec)*s,'r--')\n\n        fig.tight_layout()\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 4"
  },
  {
    "objectID": "posts/Cryptography.html#encryption-with-diffie-helmann",
    "href": "posts/Cryptography.html#encryption-with-diffie-helmann",
    "title": "Cryptography",
    "section": "Encryption with Diffie-Helmann",
    "text": "Encryption with Diffie-Helmann\nIn Figure 5 you can explore the encryption of a message using the Diffie-Helmann algorithm.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"p\",label=\"p (prime number)\",min=10,max=3000,value=23,step=1),\n    ui.input_slider(id=\"g\",label=\"g (generator)\",min=0,max=15.0,value=5,step=1),\n    ui.input_slider(id=\"a\",label=\"Private key Bob\",min=1,max=10,value=2,step=1),\n    ui.input_slider(id=\"b\",label=\"Private key Alice\",min=1,max=10,value=3,step=1), \n    ui.input_text(id='text',label=\"Message to encrypt\",value=\"sin(x)\"),\n         \n     \n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def encrypt_message(key, plaintext):\n        iv=5\n        iv=iv.to_bytes(16, 'big')\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        encryptor = cipher.encryptor()\n        ciphertext = encryptor.update(plaintext) + encryptor.finalize()\n        return iv,ciphertext\n    \n    def decrypt_message(key, iv, ciphertext):\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        decryptor = cipher.decryptor()\n        plaintext = decryptor.update(ciphertext) + decryptor.finalize()\n        return plaintext\n\n\n\n    @render.table\n    def result():\n        # list of strings\n        p=int(input.p())\n        g=int(input.g())\n        a=int(input.a())\n        text=input.text()\n        b=int(input.b())\n        # Step 1: Generate Diffie-Hellman Parameters and Keys\n        parameters = dh.generate_parameters(generator=2, key_size=512)\n\n        # Generate private/public key pairs for two parties\n        private_key_a = parameters.generate_private_key()\n        private_key_b = parameters.generate_private_key()\n\n        # Generate public keys\n        public_key_a = private_key_a.public_key()\n        public_key_b = private_key_b.public_key()\n\n        # Step 2: Derive Shared Secret\n        shared_key_a = private_key_a.exchange(public_key_b)\n        shared_key_b = private_key_b.exchange(public_key_a)\n\n        # Validate shared keys are identical\n        assert shared_key_a == shared_key_b, \"Shared keys are not equal!\"\n\n        shared_secret=int(np.mod(g**(a*b),p))\n        shared_secret_bytes=shared_secret.to_bytes(16,'big')\n        #shared_secret=g**(a*b)\n        derived_key = HKDF(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=None,\n            info=b\"diffie-hellman-key-exchange\",\n        ).derive(shared_secret_bytes)\n        \n        # Step 4: Encrypt a Message Using AES\n        message = text.encode(encoding=\"utf-8\")\n        iv, ciphertext = encrypt_message(derived_key, message)\n        print(\"Ciphertext:\", ciphertext.hex())\n\n        # Decrypt the message\n        decrypted_message = decrypt_message(derived_key, iv, ciphertext)\n        data_dict = {\n            'p': [p],\n            'g': [g],\n            'Message': [text],\n            'Shared secret Alice': [shared_secret],\n            'Encrypted Message':[ciphertext.hex()],\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\n   \napp = App(app_ui, server)\n\n\nFigure 5"
  },
  {
    "objectID": "posts/Cryptography.html#decrypting-a-message",
    "href": "posts/Cryptography.html#decrypting-a-message",
    "title": "Cryptography",
    "section": "Decrypting a message",
    "text": "Decrypting a message\nLet’s consider another description task, now using the full Diffie-Helmann.\nSuppose that we want to decrypt the message\nf04ed308495b04694943d414e0444151fe141d05581b3eb2a4f168\nSuppose that we know that it has been encrypted using Diffie Helman algorithm. The encryptors have been a little slap dash and used the following values for publicly available information:\np=31 q=23\nCan you use Figure 6 to decrypt the message using the available information?\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nimport base64\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"p\",label=\"p\",min=10,max=3000,value=23,step=1),\n    ui.input_slider(id=\"g\",label=\"g (generator)\",min=0,max=33,value=5,step=1),\n    ui.input_slider(id=\"a\",label=\"Private key Bob\",min=1,max=10,value=2,step=1),\n    ui.input_slider(id=\"b\",label=\"Private key Sue\",min=1,max=10,value=3,step=1),\n \n    ui.input_text(id='text',label=\"Message to decrypt\",value=\"8968d20bbc5b\"),\n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n\n    \n    def decrypt_message(key, iv, ciphertext):\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        decryptor = cipher.decryptor()\n        plaintext = decryptor.update(ciphertext) + decryptor.finalize()\n        return plaintext\n\n\n    @render.table\n    def result():\n        # list of strings\n        p=int(input.p())\n        g=int(input.g())\n        a=int(input.a())\n        encrypted_text=str(input.text())\n        b=int(input.b())\n\n        encrypted_text=bytes.fromhex(encrypted_text)\n\n        #text=text.encode(encoding=\"utf-8\")\n        #encrypted_text = encrypted_text.encode('ISO-8859-1')\n\n        shared_secret=int(np.mod(g**(a*b),p))\n        shared_secret_bytes=shared_secret.to_bytes(16,'big')\n        derived_key = HKDF(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=None,\n            info=b\"diffie-hellman-key-exchange\",\n        ).derive(shared_secret_bytes)\n        \n        #bytes_data = bytes.fromhex(text)\n        # Encode the bytes into a Base64 string\n        #encrypted_text = base64.b64encode(text.encode())#.decode('utf-8')\n        iv=5\n        iv=iv.to_bytes(16, 'big')\n                \n        decrypted_message = decrypt_message(derived_key, iv, encrypted_text)\n\n       \n        data_dict = {\n            'Decrypted Message':[decrypted_message]\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\n         \n\n\napp = App(app_ui, server)\n\n\nFigure 6\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from number theory are introduced in the module Topics in Pure Mathematics\nIn the modules Introduction to Programming and Computer Algebra and Dynamical systems you would be introduced to programming techniques that enable you to explore encryption algorithms.\nAt Level 4 we offer honours projects that consider different aspects of cryptography and group theory.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/MonteCarloIntegration.html",
    "href": "posts/MonteCarloIntegration.html",
    "title": "Monte Carlo Integration",
    "section": "",
    "text": "You may have previously come across definite integrals of the form\n\\[\nI=\\int_a^b f(x)\\mathrm{d}x.\n\\]\nA specific example is \\[\n\\int_0^1 x^2 \\mathrm{d}x.\n\\]\nIf you have not yet come across definite integrals that is fine. For the purposes of this page, the value of the integral is simply the area underneath the curve (see blue shaded region in Figure 1).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nTo compute the integral we can use a similar method to that used for estimating \\(\\pi\\):\n\ncircumscribe the region to be integrated within a domain of known area (e.g. see rectangle in Figure 2)\nuniformly sample points within the larger domain\ncount the fraction of points that lie in the shaded region\nthe value of the integral can be approximated by \\[\n\\hat{I} \\sim \\textrm{Area of Rectangle} * \\textrm{Fraction of sampled points in target region}\n\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nIn Figure 3 you can use a Monte Carlo method to approximate many common integrals. Table 1 provides the syntax needed for available functions.\n\n\n\nTable 1: Syntax for inputting elementary functions into the integrator in Figure 3.\n\n\n\n\n\nIntegrand\nInput text\n\n\n\n\n\\(\\sqrt{x}\\)\nsqrt(x)\n\n\n\\(\\sin{x}\\)\nsin(x)\n\n\n\\(\\cos{x}\\)\ncos(x)\n\n\n\\(\\ln{x}\\)\nlog(x)\n\n\n\\(x^2\\)\nx^2\n\n\n\\(e^x\\)\nexp(x)\n\n\n\\(\\pi\\)\npi\n\n\n\n\n\n\nIn Table 2 some examples are provided that demonstrate syntax for more complicated functions.\nIn the top plot in Figure 3 the distribution of sampled points is plotted for the selected parameter values. In the bottom plot the estimate of the integral is averaged over 100 realisations and plotted against the number of sampled points, \\(N\\).\n\n\n\nTable 2: Examples of syntax for inputting more complex functions into the integrator in Figure 3.\n\n\n\n\n\nIntegrand\nInput text\n\n\n\n\n\\(x^2+2x+1\\)\nx^2+2*x+1\n\n\n\\(e^{-\\sin^2{x}}\\)\nexp(-sin(x)*sin(x))\n\n\n\n\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"N\",label=\"Num. points per experiment\",min=10,max=3000,value=10,step=1),\n    ui.input_slider(id=\"a\",label=\"a (left limit)\",min=0.0,max=3.0,value=0.0,step=0.01),\n    ui.input_slider(id=\"b\",label=\"b (right limit)\",min=1.0,max=10.0,value=1.0,step=0.01), \n    ui.input_text(id='text',label=\"Integrand as function of x\",value=\"sin(x)\"),\n    ui.input_slider(id=\"n_samples\",label=\"Num experiments\",min=1,max=300,value=1,step=1),        \n     \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def function_f(x,text):\n\n        #f=np.sin(4*x)\n        f=np.sin(10*x)\n\n        f=parse_to_numpy_function(text,x)\n\n\n        return f\n\n    def parse_to_numpy_function(expression,x):\n        # Replace common mathematical operators with NumPy equivalents\n        expression = expression.replace(\"^\", \"**\")  # Replace '^' with '**'\n        expression = expression.replace(\"sin\", \"np.sin\")\n        expression = expression.replace(\"cos\", \"np.cos\")\n        expression = expression.replace(\"tan\", \"np.tan\")\n        expression = expression.replace(\"log\", \"np.log\")\n        expression = expression.replace(\"sqrt\", \"np.sqrt\")\n        expression = expression.replace(\"exp\", \"np.exp\")\n        expression = expression.replace(\"pi\", \"np.pi\")\n\n        # Create a lambda function for safe evaluation\n        #def numpy_function(x):\n        return eval(expression)\n    \n        #return expression\n\n\n    def estimate_int(a,b,N,text): \n        x = np.random.uniform(a,b,N)\n\n        f=function_f(x,text)\n        \n        max_f=np.max(f)\n        min_f=np.min(f)\n\n        y = np.random.uniform(min_f,max_f,N)\n\n        \n        num_points_inside_circle=len(y[(y&gt;0)&(y&lt;=f)])-len(y[(y&lt;0)&(y&gt;=f)])\n\n        int_est=(b-a)*(max_f-min_f)*num_points_inside_circle/N\n\n        return x,y,int_est\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(2,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        N=int(input.N())\n        a=float(input.a())\n        b=float(input.b())\n        text=input.text()\n        n_samples=input.n_samples()\n\n        \n        \n        \n    \n        x,y,int_est=estimate_int(a,b,N,text)\n        \n        ax[0].plot(x[(y&gt;0)&(y&lt;function_f(x,text))],y[(y&gt;0)&(y&lt;function_f(x,text))],'b.')\n        ax[0].plot(x[(y&lt;0)&(y&gt;function_f(x,text))],y[(y&lt;0)&(y&gt;function_f(x,text))],'m.')\n        ax[0].plot(x[(y&gt;0)&(y&gt;function_f(x,text))],y[(y&gt;0)&(y&gt;function_f(x,text))],'k.')\n        ax[0].plot(x[(y&lt;0)&(y&lt;function_f(x,text))],y[(y&lt;0)&(y&lt;function_f(x,text))],'k.')\n        #ax[0].plot(x[(y&gt;0)&(y&gt;function_f(x))],y[(y&gt;0)&(y&gt;function_f(x))],'k.')\n\n        ax[0].set_xlabel('$x$')\n        ax[0].set_ylabel('$y$')\n\n        x_plot=np.linspace(a,b,1000,dtype=float)\n        y_plot=function_f(x_plot,text)\n        ax[0].plot(x_plot,y_plot,'r')\n        ax[0].set_title('$\\hat{I}$='+str(int_est))\n\n        \n        N_vec=np.linspace(10,3000,80,dtype=int)\n        int_est_vec=np.zeros_like(N_vec,dtype=float)\n        for i in range(len(N_vec)):\n            int_est_i=np.zeros((n_samples,1),dtype=float)\n            for j in range(n_samples):\n                x,y,int_est=estimate_int(a,b,N_vec[i],text)\n                int_est_i[j]=int_est\n            int_est_vec[i]=np.median(int_est_i)\n\n        ax[1].plot(N_vec,int_est_vec,'.')\n        ax[1].set_xlabel('$N$')\n        ax[1].set_ylabel('$\\hat{I}$')\n\n        fig.tight_layout()\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 3\n\n\n\nExercises using the app:\n\nShow that \\[\n   \\int_0^{1}x^2 \\mathrm{d}x =\\frac{1}{3}.\n\\]\nEstimate the integral\n\\[\n\\int_0^3 \\frac{\\sin(x)\\sin(x)\\sin(x)}{1+x^2} \\textrm{d}x.\n\\]\nDemonstrate that \\[\n   \\int_0^{\\infty}e^{-x^2}\\mathrm{d}x =\\frac{\\sqrt{\\pi}}{2}\n  \\] Note that this calculation provides an alternative method to estimate \\(\\pi\\)!\nEstimate the integral \\[\n   \\int_0^{1}\\frac{x^2}{1+x^2}\\mathrm{d}x.\n  \\]\nDemonstrate that \\[\n   \\int_0^{\\pi}\\sin(x) \\mathrm{d}x\\sim 2\n  \\]\nDemonstrate that \\[\n   \\int_0^{2\\pi}\\sin(x) \\mathrm{d}x\\sim 0\n  \\] Can you spot how the symmetry results in cancellation of the positive (blue) and negative (magenta) contributions?\n\n\n\n\n\n\n\nUsing algorithms\n\n\n\n\nThe algorithm implemented in Figure 3 above will always provide a numerical estimate. However, some functions are not integrable. In such cases the numerical estimate provided by the app will be completely incorrect. We must understand the limitations of algorithms before trusting their output!\nThere exist functions that are integrable but cannot be estimated using the above technique. We cannot rely solely on algorithms.\nHow do we know how accurate the integral estimate is?\nThere exist much more computationally efficient methods for estimating integrals to a given accuracy.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from integration are introduced in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nIn the modules Introduction to Programming and Computer Algebra and Dynamical systems you would be introduced to techniques that enable you to perform numerical integration.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/MonteCarloIntegration.html#integration",
    "href": "posts/MonteCarloIntegration.html#integration",
    "title": "Monte Carlo Integration",
    "section": "",
    "text": "You may have previously come across definite integrals of the form\n\\[\nI=\\int_a^b f(x)\\mathrm{d}x.\n\\]\nA specific example is \\[\n\\int_0^1 x^2 \\mathrm{d}x.\n\\]\nIf you have not yet come across definite integrals that is fine. For the purposes of this page, the value of the integral is simply the area underneath the curve (see blue shaded region in Figure 1).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\nTo compute the integral we can use a similar method to that used for estimating \\(\\pi\\):\n\ncircumscribe the region to be integrated within a domain of known area (e.g. see rectangle in Figure 2)\nuniformly sample points within the larger domain\ncount the fraction of points that lie in the shaded region\nthe value of the integral can be approximated by \\[\n\\hat{I} \\sim \\textrm{Area of Rectangle} * \\textrm{Fraction of sampled points in target region}\n\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\nIn Figure 3 you can use a Monte Carlo method to approximate many common integrals. Table 1 provides the syntax needed for available functions.\n\n\n\nTable 1: Syntax for inputting elementary functions into the integrator in Figure 3.\n\n\n\n\n\nIntegrand\nInput text\n\n\n\n\n\\(\\sqrt{x}\\)\nsqrt(x)\n\n\n\\(\\sin{x}\\)\nsin(x)\n\n\n\\(\\cos{x}\\)\ncos(x)\n\n\n\\(\\ln{x}\\)\nlog(x)\n\n\n\\(x^2\\)\nx^2\n\n\n\\(e^x\\)\nexp(x)\n\n\n\\(\\pi\\)\npi\n\n\n\n\n\n\nIn Table 2 some examples are provided that demonstrate syntax for more complicated functions.\nIn the top plot in Figure 3 the distribution of sampled points is plotted for the selected parameter values. In the bottom plot the estimate of the integral is averaged over 100 realisations and plotted against the number of sampled points, \\(N\\).\n\n\n\nTable 2: Examples of syntax for inputting more complex functions into the integrator in Figure 3.\n\n\n\n\n\nIntegrand\nInput text\n\n\n\n\n\\(x^2+2x+1\\)\nx^2+2*x+1\n\n\n\\(e^{-\\sin^2{x}}\\)\nexp(-sin(x)*sin(x))\n\n\n\n\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"N\",label=\"Num. points per experiment\",min=10,max=3000,value=10,step=1),\n    ui.input_slider(id=\"a\",label=\"a (left limit)\",min=0.0,max=3.0,value=0.0,step=0.01),\n    ui.input_slider(id=\"b\",label=\"b (right limit)\",min=1.0,max=10.0,value=1.0,step=0.01), \n    ui.input_text(id='text',label=\"Integrand as function of x\",value=\"sin(x)\"),\n    ui.input_slider(id=\"n_samples\",label=\"Num experiments\",min=1,max=300,value=1,step=1),        \n     \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def function_f(x,text):\n\n        #f=np.sin(4*x)\n        f=np.sin(10*x)\n\n        f=parse_to_numpy_function(text,x)\n\n\n        return f\n\n    def parse_to_numpy_function(expression,x):\n        # Replace common mathematical operators with NumPy equivalents\n        expression = expression.replace(\"^\", \"**\")  # Replace '^' with '**'\n        expression = expression.replace(\"sin\", \"np.sin\")\n        expression = expression.replace(\"cos\", \"np.cos\")\n        expression = expression.replace(\"tan\", \"np.tan\")\n        expression = expression.replace(\"log\", \"np.log\")\n        expression = expression.replace(\"sqrt\", \"np.sqrt\")\n        expression = expression.replace(\"exp\", \"np.exp\")\n        expression = expression.replace(\"pi\", \"np.pi\")\n\n        # Create a lambda function for safe evaluation\n        #def numpy_function(x):\n        return eval(expression)\n    \n        #return expression\n\n\n    def estimate_int(a,b,N,text): \n        x = np.random.uniform(a,b,N)\n\n        f=function_f(x,text)\n        \n        max_f=np.max(f)\n        min_f=np.min(f)\n\n        y = np.random.uniform(min_f,max_f,N)\n\n        \n        num_points_inside_circle=len(y[(y&gt;0)&(y&lt;=f)])-len(y[(y&lt;0)&(y&gt;=f)])\n\n        int_est=(b-a)*(max_f-min_f)*num_points_inside_circle/N\n\n        return x,y,int_est\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(2,1)\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        N=int(input.N())\n        a=float(input.a())\n        b=float(input.b())\n        text=input.text()\n        n_samples=input.n_samples()\n\n        \n        \n        \n    \n        x,y,int_est=estimate_int(a,b,N,text)\n        \n        ax[0].plot(x[(y&gt;0)&(y&lt;function_f(x,text))],y[(y&gt;0)&(y&lt;function_f(x,text))],'b.')\n        ax[0].plot(x[(y&lt;0)&(y&gt;function_f(x,text))],y[(y&lt;0)&(y&gt;function_f(x,text))],'m.')\n        ax[0].plot(x[(y&gt;0)&(y&gt;function_f(x,text))],y[(y&gt;0)&(y&gt;function_f(x,text))],'k.')\n        ax[0].plot(x[(y&lt;0)&(y&lt;function_f(x,text))],y[(y&lt;0)&(y&lt;function_f(x,text))],'k.')\n        #ax[0].plot(x[(y&gt;0)&(y&gt;function_f(x))],y[(y&gt;0)&(y&gt;function_f(x))],'k.')\n\n        ax[0].set_xlabel('$x$')\n        ax[0].set_ylabel('$y$')\n\n        x_plot=np.linspace(a,b,1000,dtype=float)\n        y_plot=function_f(x_plot,text)\n        ax[0].plot(x_plot,y_plot,'r')\n        ax[0].set_title('$\\hat{I}$='+str(int_est))\n\n        \n        N_vec=np.linspace(10,3000,80,dtype=int)\n        int_est_vec=np.zeros_like(N_vec,dtype=float)\n        for i in range(len(N_vec)):\n            int_est_i=np.zeros((n_samples,1),dtype=float)\n            for j in range(n_samples):\n                x,y,int_est=estimate_int(a,b,N_vec[i],text)\n                int_est_i[j]=int_est\n            int_est_vec[i]=np.median(int_est_i)\n\n        ax[1].plot(N_vec,int_est_vec,'.')\n        ax[1].set_xlabel('$N$')\n        ax[1].set_ylabel('$\\hat{I}$')\n\n        fig.tight_layout()\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 3\n\n\n\nExercises using the app:\n\nShow that \\[\n   \\int_0^{1}x^2 \\mathrm{d}x =\\frac{1}{3}.\n\\]\nEstimate the integral\n\\[\n\\int_0^3 \\frac{\\sin(x)\\sin(x)\\sin(x)}{1+x^2} \\textrm{d}x.\n\\]\nDemonstrate that \\[\n   \\int_0^{\\infty}e^{-x^2}\\mathrm{d}x =\\frac{\\sqrt{\\pi}}{2}\n  \\] Note that this calculation provides an alternative method to estimate \\(\\pi\\)!\nEstimate the integral \\[\n   \\int_0^{1}\\frac{x^2}{1+x^2}\\mathrm{d}x.\n  \\]\nDemonstrate that \\[\n   \\int_0^{\\pi}\\sin(x) \\mathrm{d}x\\sim 2\n  \\]\nDemonstrate that \\[\n   \\int_0^{2\\pi}\\sin(x) \\mathrm{d}x\\sim 0\n  \\] Can you spot how the symmetry results in cancellation of the positive (blue) and negative (magenta) contributions?\n\n\n\n\n\n\n\nUsing algorithms\n\n\n\n\nThe algorithm implemented in Figure 3 above will always provide a numerical estimate. However, some functions are not integrable. In such cases the numerical estimate provided by the app will be completely incorrect. We must understand the limitations of algorithms before trusting their output!\nThere exist functions that are integrable but cannot be estimated using the above technique. We cannot rely solely on algorithms.\nHow do we know how accurate the integral estimate is?\nThere exist much more computationally efficient methods for estimating integrals to a given accuracy.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from integration are introduced in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nIn the modules Introduction to Programming and Computer Algebra and Dynamical systems you would be introduced to techniques that enable you to perform numerical integration.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/DrugDelivery.html",
    "href": "posts/DrugDelivery.html",
    "title": "Modelling drug delivery",
    "section": "",
    "text": "We can use calculus to study how to optimise drug delivery.\nSuppose you are working as part of a team who are designing clinical trials for a drug. It is proposed that patients will orally ingest the drug at a number of times every day. The delivery protocol needs to be optimised so that the drug concentration is as smooth as possible whilst maintaining the total dose constant.\nA first proposal is that the patient will take the drug 12 units of the drug once per day.\n\n\nLet \\(t\\) represent time and \\(C(t)\\) represent the drug concentration in the blood stream.\nSuppose that the drug has a half-life of 6 hours and that at some set of times, \\(\\{t_i\\}\\), a concentration of drug \\(c_i\\) is delivered to a patient.\nConsider the model \\[\n\\frac{dC}{dt}=-kC+\\sum_i c_i \\delta(t_i), \\quad N(0)=0.\n\\]\nThe first term describes the linear degradation of the drug. The second term represent instantaneous delivery of drug at a prescribed set of times.\nIn Figure 1 you can explore the effect of different treatment protocols.\nThe AUC refers to the area under the curve. This is a metric used to calculate the total dosage delivered to the patient. It is just the integral\n\\[\nAUC=\\int_0^T C(t)dt.\n\\]\n\\(C_{max}\\) refers to the maximum concentration experienced by the patient.\nIn a real world setting constraints might be placed on AUC and \\(C_{max}\\) (e.g. we can play around with the timing of delivery but the max concentration must never exceed some critical value).\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nfrom scipy.integrate import simpson\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"k\",label=\"Drug half life (h)\",min=1,max=12,value=6,step=1),\n    ui.input_slider(id=\"t1\",label=\"First time (h)\",min=0.0,max=10.0,value=7.0,step=1.0),\n    ui.input_slider(id=\"t2\",label=\"Second time (h)\",min=10.0,max=18.0,value=12.0,step=1.0),\n    ui.input_slider(id=\"t3\",label=\"Third time (h)\",min=17.0,max=22.0,value=18.0,step=1.0),\n    ui.input_slider(id=\"c1\",label=\"First conc.\",min=0.0,max=12.0,value=4.0,step=1.0),\n    ui.input_slider(id=\"c2\",label=\"Second conc.\",min=0.0,max=12.0,value=4.0,step=1.0),\n    ui.input_slider(id=\"c3\",label=\"Third conc.\",min=0.0,max=12.0,value=4.0,step=1.0),\n    \n                 \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        drug_half_life=float(input.k())\n        t1=float(input.t1())\n        t2=float(input.t2())\n        t3=float(input.t3())\n        c1=float(input.c1())\n        c2=float(input.c2())\n        c3=float(input.c3())\n\n        k=np.log(2)/drug_half_life\n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(x,t,k,r):\n          rhs=np.zeros_like(x,dtype=float)\n          N=x[0]\n          dN_dt=-k*N\n          rhs[0]=dN_dt\n          return rhs\n\n        #c1_default=12\n        #c2_default=0.0\n        #c3_default=0.0\n\n        T_final=96\n        num_days=int(T_final/24)\n\n        #drug_conc_default_day=[c1_default,c2_default,c3_default,0]\n        drug_conc_day=[c1,c2,c3,0]\n        t_sort_day=[0.0,t1,t2,t3]\n\n        #drug_conc_default=[]\n        drug_conc=[]\n        t_sort=[]\n        Cmax=0.0\n        for i in range(num_days):\n            #drug_conc_default=drug_conc_default+drug_conc_default_day\n            drug_conc=drug_conc+drug_conc_day\n\n            t_sort_day_i = [x + i*24.0 for x in t_sort_day]\n\n\n            t_sort=t_sort+t_sort_day_i\n        \n        t_sort.append(T_final)        #t_sort=[0.0,t1,t2,t3,24.0,t1+24.0,t2+24.0,t3+24,48.0]\n        N_0=0.0\n        AUC=0.0\n\n        for i in range(len(t_sort)-1):\n        # Define discretised t domain\n            t = np.linspace(t_sort[i], t_sort[i+1], 1000)\n            print(t)\n\n            # define initial conditions\n            init_cond=[N_0]\n        \n            # Compute numerical solution of ODEs\n            sol1 = odeint(rhs_pop_model, init_cond,t,args=(k,1))\n\n            # Plot results\n            N=sol1[:,0]\n\n            N_0=N[-1]\n            N_0=N_0+drug_conc[i]\n            ax.plot(t, N,'b')\n            AUC=AUC+simpson(N, x=t)\n            Cmax=np.max([Cmax,np.max(N)])\n\n        \n        '''N_0=0.0\n        AUC_t=0.0\n        cmax_t=0.0\n        for i in range(len(t_sort)-1):\n        # Define discretised t domain\n            t = np.linspace(t_sort[i], t_sort[i+1], 1000)\n\n            # define initial conditions\n            init_cond=[N_0]\n        \n            # Compute numerical solution of ODEs\n            sol1 = odeint(rhs_pop_model, init_cond,t,args=(k,1))\n\n            # Plot results\n            N=sol1[:,0]\n\n            N_0=N[-1]\n            N_0=N_0+drug_conc_default[i]\n        \n        \n            ax[1].plot(t, N,'r')\n            AUC_t=AUC_t+simpson(N, x=t)\n            cmax_t=np.max([cmax_t,np.max(N)])\n        '''\n\n        #ax[1].set_xlabel('$t$ (h)')\n        ax.set_xlabel('$t$ (h)')\n\n        ax.set_title('AUC = ' + str(int(AUC)) +', Cmax = ' + str(int(Cmax)))\n        #ax[1].set_title('AUC = ' + str(int(AUC_t)) + ', Cmax = ' + str(int(cmax_t)))\n\n        #ax.set_ylim([0,max_inf*1.4])\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1\n\n\n\n\n\n\nHere is a modelling challenge?\nYou work for a drug company who are designing a new drug. The drug has to be administered twice a day, at 12 hour intervals, and the administered drug concentration is fixed at a value of 4 (for reasons outside your control).\nCan you use Figure 2 to answer the following questions:\n\nWhat must the half-life of the drug be such that the concentration does not fall below a critical level 2?\nHow rigid does the patient need to stick the 12 hour intervals?\nWhat happens to the AUC as the half-life of the drug increases?\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nfrom scipy.integrate import simpson\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"k\",label=\"Drug half life (h)\",min=1,max=12,value=6,step=1),\n    ui.input_slider(id=\"t1\",label=\"First time (h)\",min=0.0,max=10.0,value=7.0,step=1.0),\n    ui.input_slider(id=\"t2\",label=\"Second time (h)\",min=10.0,max=18.0,value=12.0,step=1.0),\n                 \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        drug_half_life=float(input.k())\n        t1=float(input.t1())\n        t2=float(input.t2())\n        c1=4.0 \n        c2=4.0 \n\n        k=np.log(2)/drug_half_life\n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(x,t,k,r):\n          rhs=np.zeros_like(x,dtype=float)\n          N=x[0]\n          dN_dt=-k*N\n          rhs[0]=dN_dt\n          return rhs\n\n        #c1_default=12\n        #c2_default=0.0\n        #c3_default=0.0\n\n        T_final=96\n        num_days=int(T_final/24)\n\n        #drug_conc_default_day=[c1_default,c2_default,c3_default,0]\n        drug_conc_day=[c1,c2,0]\n        t_sort_day=[0.0,t1,t2]\n\n        #drug_conc_default=[]\n        drug_conc=[]\n        t_sort=[]\n        Cmax=0.0\n        for i in range(num_days):\n            #drug_conc_default=drug_conc_default+drug_conc_default_day\n            drug_conc=drug_conc+drug_conc_day\n\n            t_sort_day_i = [x + i*24.0 for x in t_sort_day]\n\n\n            t_sort=t_sort+t_sort_day_i\n        \n        t_sort.append(T_final)        #t_sort=[0.0,t1,t2,t3,24.0,t1+24.0,t2+24.0,t3+24,48.0]\n        N_0=0.0\n        AUC=0.0\n\n        for i in range(len(t_sort)-1):\n        # Define discretised t domain\n            t = np.linspace(t_sort[i], t_sort[i+1], 1000)\n            print(t)\n\n            # define initial conditions\n            init_cond=[N_0]\n        \n            # Compute numerical solution of ODEs\n            sol1 = odeint(rhs_pop_model, init_cond,t,args=(k,1))\n\n            # Plot results\n            N=sol1[:,0]\n\n            N_0=N[-1]\n            N_0=N_0+drug_conc[i]\n            ax.plot(t, N,'b')\n            AUC=AUC+simpson(N, x=t)\n            Cmax=np.max([Cmax,np.max(N)])\n\n        \n        \n        #ax[1].set_xlabel('$t$ (h)')\n        ax.set_xlabel('$t$ (h)')\n\n        ax.set_title('AUC = ' + str(int(AUC)) +', Cmax = ' + str(int(Cmax)))\n        #ax[1].set_title('AUC = ' + str(int(AUC_t)) + ', Cmax = ' + str(int(cmax_t)))\n\n        #ax.set_ylim([0,max_inf*1.4])\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) are studied in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the modules Computer algebra and dynamical systems and Introduction to Programming you would be introduced to techniques that are used to compute numerical solutions to differential equations.\nAt Level 3 in the module Mathematical Biology you would learn how to formulate and study mathematical models of biological systems.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/DrugDelivery.html#model-development",
    "href": "posts/DrugDelivery.html#model-development",
    "title": "Modelling drug delivery",
    "section": "",
    "text": "Let \\(t\\) represent time and \\(C(t)\\) represent the drug concentration in the blood stream.\nSuppose that the drug has a half-life of 6 hours and that at some set of times, \\(\\{t_i\\}\\), a concentration of drug \\(c_i\\) is delivered to a patient.\nConsider the model \\[\n\\frac{dC}{dt}=-kC+\\sum_i c_i \\delta(t_i), \\quad N(0)=0.\n\\]\nThe first term describes the linear degradation of the drug. The second term represent instantaneous delivery of drug at a prescribed set of times.\nIn Figure 1 you can explore the effect of different treatment protocols.\nThe AUC refers to the area under the curve. This is a metric used to calculate the total dosage delivered to the patient. It is just the integral\n\\[\nAUC=\\int_0^T C(t)dt.\n\\]\n\\(C_{max}\\) refers to the maximum concentration experienced by the patient.\nIn a real world setting constraints might be placed on AUC and \\(C_{max}\\) (e.g. we can play around with the timing of delivery but the max concentration must never exceed some critical value).\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nfrom scipy.integrate import simpson\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"k\",label=\"Drug half life (h)\",min=1,max=12,value=6,step=1),\n    ui.input_slider(id=\"t1\",label=\"First time (h)\",min=0.0,max=10.0,value=7.0,step=1.0),\n    ui.input_slider(id=\"t2\",label=\"Second time (h)\",min=10.0,max=18.0,value=12.0,step=1.0),\n    ui.input_slider(id=\"t3\",label=\"Third time (h)\",min=17.0,max=22.0,value=18.0,step=1.0),\n    ui.input_slider(id=\"c1\",label=\"First conc.\",min=0.0,max=12.0,value=4.0,step=1.0),\n    ui.input_slider(id=\"c2\",label=\"Second conc.\",min=0.0,max=12.0,value=4.0,step=1.0),\n    ui.input_slider(id=\"c3\",label=\"Third conc.\",min=0.0,max=12.0,value=4.0,step=1.0),\n    \n                 \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        drug_half_life=float(input.k())\n        t1=float(input.t1())\n        t2=float(input.t2())\n        t3=float(input.t3())\n        c1=float(input.c1())\n        c2=float(input.c2())\n        c3=float(input.c3())\n\n        k=np.log(2)/drug_half_life\n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(x,t,k,r):\n          rhs=np.zeros_like(x,dtype=float)\n          N=x[0]\n          dN_dt=-k*N\n          rhs[0]=dN_dt\n          return rhs\n\n        #c1_default=12\n        #c2_default=0.0\n        #c3_default=0.0\n\n        T_final=96\n        num_days=int(T_final/24)\n\n        #drug_conc_default_day=[c1_default,c2_default,c3_default,0]\n        drug_conc_day=[c1,c2,c3,0]\n        t_sort_day=[0.0,t1,t2,t3]\n\n        #drug_conc_default=[]\n        drug_conc=[]\n        t_sort=[]\n        Cmax=0.0\n        for i in range(num_days):\n            #drug_conc_default=drug_conc_default+drug_conc_default_day\n            drug_conc=drug_conc+drug_conc_day\n\n            t_sort_day_i = [x + i*24.0 for x in t_sort_day]\n\n\n            t_sort=t_sort+t_sort_day_i\n        \n        t_sort.append(T_final)        #t_sort=[0.0,t1,t2,t3,24.0,t1+24.0,t2+24.0,t3+24,48.0]\n        N_0=0.0\n        AUC=0.0\n\n        for i in range(len(t_sort)-1):\n        # Define discretised t domain\n            t = np.linspace(t_sort[i], t_sort[i+1], 1000)\n            print(t)\n\n            # define initial conditions\n            init_cond=[N_0]\n        \n            # Compute numerical solution of ODEs\n            sol1 = odeint(rhs_pop_model, init_cond,t,args=(k,1))\n\n            # Plot results\n            N=sol1[:,0]\n\n            N_0=N[-1]\n            N_0=N_0+drug_conc[i]\n            ax.plot(t, N,'b')\n            AUC=AUC+simpson(N, x=t)\n            Cmax=np.max([Cmax,np.max(N)])\n\n        \n        '''N_0=0.0\n        AUC_t=0.0\n        cmax_t=0.0\n        for i in range(len(t_sort)-1):\n        # Define discretised t domain\n            t = np.linspace(t_sort[i], t_sort[i+1], 1000)\n\n            # define initial conditions\n            init_cond=[N_0]\n        \n            # Compute numerical solution of ODEs\n            sol1 = odeint(rhs_pop_model, init_cond,t,args=(k,1))\n\n            # Plot results\n            N=sol1[:,0]\n\n            N_0=N[-1]\n            N_0=N_0+drug_conc_default[i]\n        \n        \n            ax[1].plot(t, N,'r')\n            AUC_t=AUC_t+simpson(N, x=t)\n            cmax_t=np.max([cmax_t,np.max(N)])\n        '''\n\n        #ax[1].set_xlabel('$t$ (h)')\n        ax.set_xlabel('$t$ (h)')\n\n        ax.set_title('AUC = ' + str(int(AUC)) +', Cmax = ' + str(int(Cmax)))\n        #ax[1].set_title('AUC = ' + str(int(AUC_t)) + ', Cmax = ' + str(int(cmax_t)))\n\n        #ax.set_ylim([0,max_inf*1.4])\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1"
  },
  {
    "objectID": "posts/DrugDelivery.html#a-specific-modelling-problem",
    "href": "posts/DrugDelivery.html#a-specific-modelling-problem",
    "title": "Modelling drug delivery",
    "section": "",
    "text": "Here is a modelling challenge?\nYou work for a drug company who are designing a new drug. The drug has to be administered twice a day, at 12 hour intervals, and the administered drug concentration is fixed at a value of 4 (for reasons outside your control).\nCan you use Figure 2 to answer the following questions:\n\nWhat must the half-life of the drug be such that the concentration does not fall below a critical level 2?\nHow rigid does the patient need to stick the 12 hour intervals?\nWhat happens to the AUC as the half-life of the drug increases?\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nfrom scipy.integrate import simpson\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"k\",label=\"Drug half life (h)\",min=1,max=12,value=6,step=1),\n    ui.input_slider(id=\"t1\",label=\"First time (h)\",min=0.0,max=10.0,value=7.0,step=1.0),\n    ui.input_slider(id=\"t2\",label=\"Second time (h)\",min=10.0,max=18.0,value=12.0,step=1.0),\n                 \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        drug_half_life=float(input.k())\n        t1=float(input.t1())\n        t2=float(input.t2())\n        c1=4.0 \n        c2=4.0 \n\n        k=np.log(2)/drug_half_life\n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(x,t,k,r):\n          rhs=np.zeros_like(x,dtype=float)\n          N=x[0]\n          dN_dt=-k*N\n          rhs[0]=dN_dt\n          return rhs\n\n        #c1_default=12\n        #c2_default=0.0\n        #c3_default=0.0\n\n        T_final=96\n        num_days=int(T_final/24)\n\n        #drug_conc_default_day=[c1_default,c2_default,c3_default,0]\n        drug_conc_day=[c1,c2,0]\n        t_sort_day=[0.0,t1,t2]\n\n        #drug_conc_default=[]\n        drug_conc=[]\n        t_sort=[]\n        Cmax=0.0\n        for i in range(num_days):\n            #drug_conc_default=drug_conc_default+drug_conc_default_day\n            drug_conc=drug_conc+drug_conc_day\n\n            t_sort_day_i = [x + i*24.0 for x in t_sort_day]\n\n\n            t_sort=t_sort+t_sort_day_i\n        \n        t_sort.append(T_final)        #t_sort=[0.0,t1,t2,t3,24.0,t1+24.0,t2+24.0,t3+24,48.0]\n        N_0=0.0\n        AUC=0.0\n\n        for i in range(len(t_sort)-1):\n        # Define discretised t domain\n            t = np.linspace(t_sort[i], t_sort[i+1], 1000)\n            print(t)\n\n            # define initial conditions\n            init_cond=[N_0]\n        \n            # Compute numerical solution of ODEs\n            sol1 = odeint(rhs_pop_model, init_cond,t,args=(k,1))\n\n            # Plot results\n            N=sol1[:,0]\n\n            N_0=N[-1]\n            N_0=N_0+drug_conc[i]\n            ax.plot(t, N,'b')\n            AUC=AUC+simpson(N, x=t)\n            Cmax=np.max([Cmax,np.max(N)])\n\n        \n        \n        #ax[1].set_xlabel('$t$ (h)')\n        ax.set_xlabel('$t$ (h)')\n\n        ax.set_title('AUC = ' + str(int(AUC)) +', Cmax = ' + str(int(Cmax)))\n        #ax[1].set_title('AUC = ' + str(int(AUC_t)) + ', Cmax = ' + str(int(cmax_t)))\n\n        #ax.set_ylim([0,max_inf*1.4])\n\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) are studied in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the modules Computer algebra and dynamical systems and Introduction to Programming you would be introduced to techniques that are used to compute numerical solutions to differential equations.\nAt Level 3 in the module Mathematical Biology you would learn how to formulate and study mathematical models of biological systems.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/QuadraticCubicRoots.html",
    "href": "posts/QuadraticCubicRoots.html",
    "title": "Roots of quadratic/cubic equations",
    "section": "",
    "text": "Roots of quadratic and cubic equations\nConsider the cubic equation \\[\nax^3+bx^2+cx+d=0, \\ \\ \\quad a,b,c, d \\in \\Re.\n\\tag{1}\\]\nA special case you may have seen before occurs when \\(a=0\\). Hence \\[\nbx^2+cx+d=0.\n\\]\nIn this case the roots of the quadratic are \\[\nx=\\frac{-c\\pm\\sqrt{c^2-4bd}}{2b}.\n\\]\nIn the app in Figure 1 you can play with the parameter \\(a\\), \\(b\\), \\(c\\) and \\(d\\) and explore how they affect the form of the cubic equation Equation 1.\n\n\n\n\n\n\nTip\n\n\n\nPlease note that the app in Figure 1 is approximately 20 MB. If it does not display on your device:\n\nwait a few moments (it is downloading the Python code that will run the app)\nrefresh your browser.\n\ntry running on a faster connection/ more powerful device.\n\nIf it still does not load, here is a screenshot.\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-5,max=5,value=1.0,step=0.1),\n    ui.input_slider(id=\"b\",label=\"b\",min=-5.0,max=5.0,value=1.0,step=0.1),\n    ui.input_slider(id=\"c\",label=\"c\",min=-5.0,max=10.0,value=5.0,step=0.1),            \n    ui.input_slider(id=\"d\",label=\"d\",min=-5.0,max=10.0,value=5.0,step=0.1),            \n    ui.input_slider(id=\"min_x\",label=\"Min x \",min=-10.0,max=10.0,value=-5.0,step=0.1),  \n    ui.input_slider(id=\"max_x\",label=\"Max x\",min=-10.0,max=10.0,value=5.0,step=0.1),\n        \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        c=float((input.c()))\n        d=float((input.d()))\n\n        min_x=float(input.min_x())\n        max_x=float(input.max_x())\n\n        \n        # Define rhs of LV ODEs\n        def rhs(x,a,b,c,d):\n          rhs=np.zeros_like(x,dtype=float)\n          rhs=a*x**3+b*x**2+c*x+d\n\n          return rhs\n\n        # Define discretised t domain\n        x = np.linspace(min_x, max_x, 1000)\n\n        # define initial conditions\n        \n        # Compute numerical solution of ODEs\n        y = rhs(x,a,b,c,d)\n\n        coeff=[a,b,c,d]\n        roots=np.roots(coeff)\n\n        roots=np.round(roots,2)\n        ax.plot(x, y,np.real(roots),np.zeros_like(np.real(roots)),'rx')\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n        y_lim_p=-15.0 #np.min([100,np.max(y)])\n        y_lim_m=15.0 #np.max([-100,np.min(y)])\n\n        ax.set_ylim([y_lim_m,y_lim_p])\n        ax.invert_yaxis()\n        ax.grid()\n\n        text_x=0.25*(min_x+max_x)\n        text_y=np.mean(y)\n        #title_Str= = ' '.join(map(str, (roots)))\n        title_Str=[(\"R\"+ str(j) +\" = \" + str(roots[j]) ) for j in range(len(roots))]\n        title_Str = str(title_Str)[1:-1]\n\n        ax.set_title(title_Str)\n        #ax.set_title([(\"R\"+ str(j) +\" = \" + str(roots[j]) ) for j in range(len(roots))])\n\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1: Plot of a cubic function. The roots of the cubic are reported in the figure title. The red crosses depict the real parts of the roots.\n\n\n\n\n\nExercises\n\nset \\(a=0\\).\n\nhow many roots are there?\nhow does the local maximum/minimum of the quadratic depend on the sign of the parameter \\(b\\)?\nwhy are there complex roots when the condition \\(c^2-4bd&lt;0\\) is satisfied?\n\nconsider the case where \\(a&gt;0\\).\n\nhow many real roots are there?\ndemonstrate that there is always a trivial root (\\(x=0\\)) in the case \\(d=0\\).\ndemonstrate that in the case \\(a=d=1\\) with \\(b=c=0\\) the cubic takes the reduced form \\[\n  x^3=-1.\n\\] Can you show that the roots are \\(-1\\), \\(\\frac{1+j\\sqrt{3}}{2}\\), \\(\\frac{1-j\\sqrt{3}}{2}\\) where \\(j=\\sqrt{-1}\\).\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, you will develop your knowledge in algebra in modules\n\nMaths 1A\nMaths 1B\nMaths 2A\nMaths 2B\n\nAt Levels 2, 3 and 4 you will learn how to use computer programming to explore and communicate mathematical concepts.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/TrigonometricIdentities.html",
    "href": "posts/TrigonometricIdentities.html",
    "title": "Trigonometric equations and Fourier series",
    "section": "",
    "text": "Trigonometric functions appear throughout mathematics (e.g. geometry, calculus, differential equations, signal analysis). Here we explore some properties of trigonometric functions with which you might be familiar. Then we take a leap into demonstrating how arbitrary functions can be approximated using sums of trigonometric functions.\n\n\nYou may have encountered trigonometric expressions of the form \\[\na\\sin(x)+b\\cos(x),\n\\tag{1}\\]\nand shown that they can be expressed in the wave-function form \\[\nc\\sin(x+d).\n\\tag{2}\\]\nThis idea is explored in Figure 1: - the individual terms in Equation 1 are plotted using dashed lines for given values of parameters \\(a\\) and \\(b\\).\n- the sum on the right-hand side of Equation 1 is plotted using a dot-dashed line. - Equation 2 is plotted for given values of \\(c\\) and \\(d\\).\nCan you identify values of the parameters \\(c\\) and \\(d\\) such that \\[\nc\\sin(x+d)=a\\sin(x)+b\\cos(x)\n\\] Are these values unique (i.e. is there more than one solution?)\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-5,max=5,value=1.0,step=0.2),\n    ui.input_slider(id=\"b\",label=\"b\",min=-5.0,max=5.0,value=1.0,step=0.2),\n    ui.input_slider(id=\"c\",label=\"c\",min=-5.0,max=10.0,value=5.0,step=0.02),            \n    ui.input_slider(id=\"d\",label=\"d\",min=-5.0,max=10.0,value=5.0,step=0.02),            \n    ),\n    ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        a =float(input.a())\n        b =float(input.b())\n        c =float((input.c()))\n        d =float((input.d()))\n\n        # Define discretised t domain\n        min_x=-10\n        max_x=10\n        x = np.linspace(min_x, max_x, 1000)\n        y_1 = a*np.sin(x)\n        y_2 = b*np.cos(x)\n        y_3=c*np.sin(x+d)\n\n        z=y_1+y_2\n        ax.plot(x, y_1,'--', x,y_2,'--',linewidth=1)\n        ax.plot(x,z,'-.',x,y_3,linewidth=6)\n        \n\n        min_y=-(np.abs(a)+np.abs(b)+np.abs(c))\n        max_y=-min_y\n        ax.set_ylim([min_y,max_y])\n        ax.set_xlim([min_x,max_x])\n        ax.grid(True)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 1: Sum of cosine and sine functions.\n\n\n\n\n\n\nYou may have come across compound angle formulae \\[\n\\sin(a+b)=\\sin(a)\\cos(b)+\\sin(b)\\cos(a)\n\\] and \\[\n\\cos(a+b)=\\cos(a)\\cos(b)-\\sin(a)\\sin(b).\n\\]\nIn Figure 2 you can use the unit circle to visualise why the above identities hold.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\ntitle_str=['All','Sine','Cosine']\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"a\",label=\"Angle b\",min=0,max=1.0,value=0.5,step=0.02),\n    ui.input_slider(id=\"b\",label=\"Angle a\",min=0.0,max=1.0,value=0.56,step=0.02),\n    ui.input_select(id=\"c\",label=\"Choose compound angle\",choices=title_str,selected=title_str[0]),           \n    ),\n    ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(figsize=[20,10])\n                \n        a =float(input.a())\n        b =float(input.b())\n        c =(input.c())\n\n        cos_a=np.cos(a)\n        cos_b=np.cos(b)\n        sin_a=np.sin(a)\n        sin_b=np.sin(b)\n\n        cos_apb=np.cos(a+b)\n        sin_apb=np.sin(a+b)\n\n\n        point1=[0.0,0.0]\n        point2=[cos_a*cos_b,cos_a*sin_b]\n        point3=[cos_apb,sin_apb]\n\n        triangle=np.array([point1,point2,point3,point1],dtype=float)\n\n\n        min_point_6=np.min([0.0,cos_apb])\n\n        point4=[min_point_6,0.0]\n        point5=[cos_a*cos_b,0.0]\n        point6=[cos_a*cos_b,sin_apb]\n        point7=[min_point_6,sin_apb]\n\n        rectangle=np.array([point4,point5,point6,point7,point4],dtype=float)\n\n\n        # Define discretised t domain\n     \n        ax.plot(triangle[:,0],triangle[:,1],linewidth=1)\n        ax.plot(rectangle[:,0],rectangle[:,1],linewidth=2)\n\n        ax.text(0.2*np.cos(a/2.0),0.2*np.sin(a/2.0),'a',)\n        ax.text(0.2*np.cos(a+b/2.0),0.2*np.sin(a+b/2.0),'b')\n        ax.text((point2[0]+point3[0])/2.0,(point2[1]+point3[1])/2.0+0.05,'$\\sin(b)$')\n        ax.text(point2[0]/2.0,point2[1]/2.0+0.05,'$\\cos(b)$',rotation=np.arctan2(point2[1],point2[0])/(2.0*np.pi)*360.0)\n        ax.text(cos_apb/2.0,sin_apb/2.0+0.05,'1')\n        \n        c1='b'\n        c2='r'\n        color_map=[c1,c1,c1,c1,c1,c1]\n\n        if c=='Sine':\n            color_map=['r','k','m',c1,c1,c1]\n            ax.plot([point4[0],point7[0]],[point4[1],point7[1]],'r',linewidth=6)\n            ax.plot([point5[0],point2[0]],[point5[1],point2[1]],'m',linewidth=6)\n            ax.plot([point6[0],point2[0]],[point6[1],point2[1]],'k',linewidth=6)\n        elif c=='Cosine':\n            color_map=[c1,c1,c1,'m','r','k']\n            ax.plot([point4[0],point5[0]],[point4[1],point5[1]],'r',linewidth=6)\n            ax.plot([point7[0],point3[0]],[point7[1],point3[1]],'m',linewidth=6)\n            ax.plot([point6[0],point3[0]],[point6[1],point3[1]],'k',linewidth=6)\n\n\n\n        \n       \n        ax.text(min_point_6-0.1,sin_apb/2.0-0.2,'$\\sin(a+b)$',color=color_map[0],rotation='vertical')\n        ax.text(point2[0]+0.05,(point2[1]+point3[1])/2.0,'$\\cos(a)\\sin(b)$',color=color_map[1])\n        ax.text(point2[0]+0.05,point2[1]/2.0,'$\\sin(a)\\cos(b)$',color=color_map[2])\n        ax.text(cos_apb/2.0-0.2,sin_apb+0.05,'$\\cos(a+b)$',color=color_map[3])\n        ax.text(cos_a*cos_b*0.25,-0.2+0.05,'$\\cos(a)\\cos(b)$',color=color_map[4])\n        ax.text((point2[0]+point3[0])/2.0,sin_apb+0.1,'$\\sin(a)\\sin(b)$',color=color_map[5])\n\n        circle1=plt.Circle(( 0.0 , 0.0 ), 1.0,alpha=0.05 )\n        ax.add_patch(circle1)\n\n\n        \n        \n        \n        ax.grid(True)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n        ax.set_xlim([-1.0,1.0])\n        ax.set_ylim([0.0,1.0])\n        plt.xticks([-1.0,0.0,1.0])\n        ax.set_aspect('equal')\n\napp = App(app_ui, server)\n\n\nFigure 2: Compound angle formulae.\n\n\n\n\n\n\nDid you know that many functions, \\(f(x)\\), defined on a domain \\(x\\in[0,L]\\) can be approximated by an infinite sum of sine functions of different frequencies, i.e. \\[\nf(x)\\sim A_1\\sin(k_1x)+A_2\\sin(k_2x)+A_3\\sin(k_3x) + A_4\n\\sin(k_4x) + ...\n\\]\nFor a given function \\(f(x)\\), the coefficients \\(A_0\\), \\(A_1\\) etc. can be chosen so that the sum provides an arbitrarily good approximation to the function.\nIn Figure 3 you can explore approximation to a number of functions that you may have previously encountered.\n\nChoose the linear function f(x)=x. Is the approximation good for \\(N=5\\)? What happens to the approximation as you increase \\(N\\)? Notice that the approximation does not converge to the correct value on the boundary \\(x=L\\). This is known as the Gibbs phenomenon. It is not an error but requires a more detailed study of Fourier series to understand!\nConsider the sawtooth function. Compare the accuracy of the series aproximation at the boundary \\(x=L\\) between the functions \\(f(x)=x\\) and the sawtooth function. Note that the approximation now appears to be converging to the value of \\(f\\) on the boundary \\(x=L\\).\nConsider the exponential function. Note that many more terms are needed in the expansion to obtain a reasonable level of accuracy.\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\ntitle_str=['x','sawtooth','x^2','x^2-2x+1','exp(x)','tan(x)',]\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.input_select(id=\"fun\",label=\"Choose f(x)\",choices=title_str,selected=[\"x\"]),\n    ui.input_slider(id=\"L\",label=\"L (domain length)\",min=1.0,max=20.0,value=10.0,step=1.0), \n    ui.input_slider(id=\"N\",label=\"N (num. terms in series)\",min=1,max=500,value=10,step=1),          \n    ),\n    ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        fun =(input.fun())\n        N =int(input.N())\n        L =float(input.L())\n\n        # Define discretised t domain\n   \n        x = np.linspace(0.0, L, 10000)\n        if fun == 'x':\n            f=x\n        elif fun == 'x^2':\n            f=x**2\n        elif fun=='x^2-2x+1':\n            f=x**2-2*x+1\n        elif fun=='exp(x)':\n            f=np.exp(x)\n        elif fun=='tan(x)':\n            f=np.tan(x)\n        elif fun=='sawtooth':\n            f=np.mod(x*5,L)\n\n        sum=0\n        for i in range(N+1):\n            k_i=i*np.pi/L\n\n            basis_fun=np.sin(k_i*x)\n            A_i= 2.0/L*np.trapz(f*basis_fun,x)\n            term_i=A_i*np.sin(k_i*x)\n            sum+=term_i \n\n        y_2 = sum\n\n        ax.plot(x, f,'--', x,y_2,'--')\n        \n\n        #min_y=-(np.abs(a)+np.abs(b)+np.abs(c))\n        #max_y=-min_y\n\n        min_y=np.max([np.min(f),-200.0])\n        max_y=np.min([np.max(f),200.0])\n\n        ax.set_ylim([min_y,max_y])\n        #ax.set_xlim([min_x,max_x])\n        ax.grid(True)\n        ax.legend(['f(x)','Approximation'])\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 3: Approximating a function as a sum of sinusoids.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, concepts from trigonometry are studies in core module Maths 1A and Maths 1B.\nAt Level 3 in the module Differential Equations Fourier series are introduced and used to study the solution of partial differential equations.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/TrigonometricIdentities.html#wave-function-forms",
    "href": "posts/TrigonometricIdentities.html#wave-function-forms",
    "title": "Trigonometric equations and Fourier series",
    "section": "",
    "text": "You may have encountered trigonometric expressions of the form \\[\na\\sin(x)+b\\cos(x),\n\\tag{1}\\]\nand shown that they can be expressed in the wave-function form \\[\nc\\sin(x+d).\n\\tag{2}\\]\nThis idea is explored in Figure 1: - the individual terms in Equation 1 are plotted using dashed lines for given values of parameters \\(a\\) and \\(b\\).\n- the sum on the right-hand side of Equation 1 is plotted using a dot-dashed line. - Equation 2 is plotted for given values of \\(c\\) and \\(d\\).\nCan you identify values of the parameters \\(c\\) and \\(d\\) such that \\[\nc\\sin(x+d)=a\\sin(x)+b\\cos(x)\n\\] Are these values unique (i.e. is there more than one solution?)\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"a\",label=\"a\",min=-5,max=5,value=1.0,step=0.2),\n    ui.input_slider(id=\"b\",label=\"b\",min=-5.0,max=5.0,value=1.0,step=0.2),\n    ui.input_slider(id=\"c\",label=\"c\",min=-5.0,max=10.0,value=5.0,step=0.02),            \n    ui.input_slider(id=\"d\",label=\"d\",min=-5.0,max=10.0,value=5.0,step=0.02),            \n    ),\n    ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        a =float(input.a())\n        b =float(input.b())\n        c =float((input.c()))\n        d =float((input.d()))\n\n        # Define discretised t domain\n        min_x=-10\n        max_x=10\n        x = np.linspace(min_x, max_x, 1000)\n        y_1 = a*np.sin(x)\n        y_2 = b*np.cos(x)\n        y_3=c*np.sin(x+d)\n\n        z=y_1+y_2\n        ax.plot(x, y_1,'--', x,y_2,'--',linewidth=1)\n        ax.plot(x,z,'-.',x,y_3,linewidth=6)\n        \n\n        min_y=-(np.abs(a)+np.abs(b)+np.abs(c))\n        max_y=-min_y\n        ax.set_ylim([min_y,max_y])\n        ax.set_xlim([min_x,max_x])\n        ax.grid(True)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 1: Sum of cosine and sine functions."
  },
  {
    "objectID": "posts/TrigonometricIdentities.html#compound-angle-identities",
    "href": "posts/TrigonometricIdentities.html#compound-angle-identities",
    "title": "Trigonometric equations and Fourier series",
    "section": "",
    "text": "You may have come across compound angle formulae \\[\n\\sin(a+b)=\\sin(a)\\cos(b)+\\sin(b)\\cos(a)\n\\] and \\[\n\\cos(a+b)=\\cos(a)\\cos(b)-\\sin(a)\\sin(b).\n\\]\nIn Figure 2 you can use the unit circle to visualise why the above identities hold.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\ntitle_str=['All','Sine','Cosine']\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"a\",label=\"Angle b\",min=0,max=1.0,value=0.5,step=0.02),\n    ui.input_slider(id=\"b\",label=\"Angle a\",min=0.0,max=1.0,value=0.56,step=0.02),\n    ui.input_select(id=\"c\",label=\"Choose compound angle\",choices=title_str,selected=title_str[0]),           \n    ),\n    ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(figsize=[20,10])\n                \n        a =float(input.a())\n        b =float(input.b())\n        c =(input.c())\n\n        cos_a=np.cos(a)\n        cos_b=np.cos(b)\n        sin_a=np.sin(a)\n        sin_b=np.sin(b)\n\n        cos_apb=np.cos(a+b)\n        sin_apb=np.sin(a+b)\n\n\n        point1=[0.0,0.0]\n        point2=[cos_a*cos_b,cos_a*sin_b]\n        point3=[cos_apb,sin_apb]\n\n        triangle=np.array([point1,point2,point3,point1],dtype=float)\n\n\n        min_point_6=np.min([0.0,cos_apb])\n\n        point4=[min_point_6,0.0]\n        point5=[cos_a*cos_b,0.0]\n        point6=[cos_a*cos_b,sin_apb]\n        point7=[min_point_6,sin_apb]\n\n        rectangle=np.array([point4,point5,point6,point7,point4],dtype=float)\n\n\n        # Define discretised t domain\n     \n        ax.plot(triangle[:,0],triangle[:,1],linewidth=1)\n        ax.plot(rectangle[:,0],rectangle[:,1],linewidth=2)\n\n        ax.text(0.2*np.cos(a/2.0),0.2*np.sin(a/2.0),'a',)\n        ax.text(0.2*np.cos(a+b/2.0),0.2*np.sin(a+b/2.0),'b')\n        ax.text((point2[0]+point3[0])/2.0,(point2[1]+point3[1])/2.0+0.05,'$\\sin(b)$')\n        ax.text(point2[0]/2.0,point2[1]/2.0+0.05,'$\\cos(b)$',rotation=np.arctan2(point2[1],point2[0])/(2.0*np.pi)*360.0)\n        ax.text(cos_apb/2.0,sin_apb/2.0+0.05,'1')\n        \n        c1='b'\n        c2='r'\n        color_map=[c1,c1,c1,c1,c1,c1]\n\n        if c=='Sine':\n            color_map=['r','k','m',c1,c1,c1]\n            ax.plot([point4[0],point7[0]],[point4[1],point7[1]],'r',linewidth=6)\n            ax.plot([point5[0],point2[0]],[point5[1],point2[1]],'m',linewidth=6)\n            ax.plot([point6[0],point2[0]],[point6[1],point2[1]],'k',linewidth=6)\n        elif c=='Cosine':\n            color_map=[c1,c1,c1,'m','r','k']\n            ax.plot([point4[0],point5[0]],[point4[1],point5[1]],'r',linewidth=6)\n            ax.plot([point7[0],point3[0]],[point7[1],point3[1]],'m',linewidth=6)\n            ax.plot([point6[0],point3[0]],[point6[1],point3[1]],'k',linewidth=6)\n\n\n\n        \n       \n        ax.text(min_point_6-0.1,sin_apb/2.0-0.2,'$\\sin(a+b)$',color=color_map[0],rotation='vertical')\n        ax.text(point2[0]+0.05,(point2[1]+point3[1])/2.0,'$\\cos(a)\\sin(b)$',color=color_map[1])\n        ax.text(point2[0]+0.05,point2[1]/2.0,'$\\sin(a)\\cos(b)$',color=color_map[2])\n        ax.text(cos_apb/2.0-0.2,sin_apb+0.05,'$\\cos(a+b)$',color=color_map[3])\n        ax.text(cos_a*cos_b*0.25,-0.2+0.05,'$\\cos(a)\\cos(b)$',color=color_map[4])\n        ax.text((point2[0]+point3[0])/2.0,sin_apb+0.1,'$\\sin(a)\\sin(b)$',color=color_map[5])\n\n        circle1=plt.Circle(( 0.0 , 0.0 ), 1.0,alpha=0.05 )\n        ax.add_patch(circle1)\n\n\n        \n        \n        \n        ax.grid(True)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n        ax.set_xlim([-1.0,1.0])\n        ax.set_ylim([0.0,1.0])\n        plt.xticks([-1.0,0.0,1.0])\n        ax.set_aspect('equal')\n\napp = App(app_ui, server)\n\n\nFigure 2: Compound angle formulae."
  },
  {
    "objectID": "posts/TrigonometricIdentities.html#fourier-series",
    "href": "posts/TrigonometricIdentities.html#fourier-series",
    "title": "Trigonometric equations and Fourier series",
    "section": "",
    "text": "Did you know that many functions, \\(f(x)\\), defined on a domain \\(x\\in[0,L]\\) can be approximated by an infinite sum of sine functions of different frequencies, i.e. \\[\nf(x)\\sim A_1\\sin(k_1x)+A_2\\sin(k_2x)+A_3\\sin(k_3x) + A_4\n\\sin(k_4x) + ...\n\\]\nFor a given function \\(f(x)\\), the coefficients \\(A_0\\), \\(A_1\\) etc. can be chosen so that the sum provides an arbitrarily good approximation to the function.\nIn Figure 3 you can explore approximation to a number of functions that you may have previously encountered.\n\nChoose the linear function f(x)=x. Is the approximation good for \\(N=5\\)? What happens to the approximation as you increase \\(N\\)? Notice that the approximation does not converge to the correct value on the boundary \\(x=L\\). This is known as the Gibbs phenomenon. It is not an error but requires a more detailed study of Fourier series to understand!\nConsider the sawtooth function. Compare the accuracy of the series aproximation at the boundary \\(x=L\\) between the functions \\(f(x)=x\\) and the sawtooth function. Note that the approximation now appears to be converging to the value of \\(f\\) on the boundary \\(x=L\\).\nConsider the exponential function. Note that many more terms are needed in the expansion to obtain a reasonable level of accuracy.\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\ntitle_str=['x','sawtooth','x^2','x^2-2x+1','exp(x)','tan(x)',]\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.input_select(id=\"fun\",label=\"Choose f(x)\",choices=title_str,selected=[\"x\"]),\n    ui.input_slider(id=\"L\",label=\"L (domain length)\",min=1.0,max=20.0,value=10.0,step=1.0), \n    ui.input_slider(id=\"N\",label=\"N (num. terms in series)\",min=1,max=500,value=10,step=1),          \n    ),\n    ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        fun =(input.fun())\n        N =int(input.N())\n        L =float(input.L())\n\n        # Define discretised t domain\n   \n        x = np.linspace(0.0, L, 10000)\n        if fun == 'x':\n            f=x\n        elif fun == 'x^2':\n            f=x**2\n        elif fun=='x^2-2x+1':\n            f=x**2-2*x+1\n        elif fun=='exp(x)':\n            f=np.exp(x)\n        elif fun=='tan(x)':\n            f=np.tan(x)\n        elif fun=='sawtooth':\n            f=np.mod(x*5,L)\n\n        sum=0\n        for i in range(N+1):\n            k_i=i*np.pi/L\n\n            basis_fun=np.sin(k_i*x)\n            A_i= 2.0/L*np.trapz(f*basis_fun,x)\n            term_i=A_i*np.sin(k_i*x)\n            sum+=term_i \n\n        y_2 = sum\n\n        ax.plot(x, f,'--', x,y_2,'--')\n        \n\n        #min_y=-(np.abs(a)+np.abs(b)+np.abs(c))\n        #max_y=-min_y\n\n        min_y=np.max([np.min(f),-200.0])\n        max_y=np.min([np.max(f),200.0])\n\n        ax.set_ylim([min_y,max_y])\n        #ax.set_xlim([min_x,max_x])\n        ax.grid(True)\n        ax.legend(['f(x)','Approximation'])\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 3: Approximating a function as a sum of sinusoids.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, concepts from trigonometry are studies in core module Maths 1A and Maths 1B.\nAt Level 3 in the module Differential Equations Fourier series are introduced and used to study the solution of partial differential equations.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/Mappings2D.html",
    "href": "posts/Mappings2D.html",
    "title": "D’Arcy Thompson and 2D mappings",
    "section": "",
    "text": "In D’Arcy Thompson’s book ‘On Growth and Form’ he considers how the shapes of related species can be understood using mathematical maps.The underlying idea is that the observed morphological form of an organism (i.e. what you see) is a function of the history of the growth rates of different parts of the organism during development. Although related species can quite different, their shape and size can be sometimes related by quite simple mathematical rules.\nIn Figure 1 you can see two different species of fish."
  },
  {
    "objectID": "posts/Mappings2D.html#explore-mappings-via-an-app",
    "href": "posts/Mappings2D.html#explore-mappings-via-an-app",
    "title": "D’Arcy Thompson and 2D mappings",
    "section": "Explore mappings via an app",
    "text": "Explore mappings via an app\nIn the app in Figure 2 you can explore mappings similar to those considered by D’Arcy Thompson. The default image initially used is a stock image used in image processing.\n\n\n\n\n\n\nInteractivity in the App:\n\n\n\n\nEach map depends on the value of a single parameter.\nA number of different maps are considered.\nYou can upload images from your device using the upload button.\nYou can download transformed images by right-clicking and saving.\n\n\n\nIf you save the images in Figure 1 to your computer (right click and ‘Save Image to Download’) you can upload them to the App and explore the effect of the different transformations.\nYou can also upload your own images (in .png or .jpg format).\n\n\n\n\n\n\n\n\nArgyropelecusOlfersi\n\n\n\n\n\n\n\nScarus\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 600\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport skimage as ski\nimport pyodide\nfrom skimage.transform import SimilarityTransform\nfrom skimage.transform import warp\nfrom skimage.transform import PiecewiseAffineTransform\nfrom skimage.transform import AffineTransform\nfrom skimage.io import imread\nimport io\nfrom pathlib import Path\nfrom skimage.transform import resize, rescale\n\ndef ChooseTransform(transform,im_shape,a,num_disc_points,old_centre):\n    rows=im_shape[0]\n    cols=im_shape[1]\n\n    src_cols = np.linspace(0, cols, num_disc_points)\n    src_rows = np.linspace(0, rows, num_disc_points)\n    src_rows, src_cols = np.meshgrid(src_rows, src_cols)\n    src = np.dstack([src_cols.flat, src_rows.flat])[0]\n    dst_rows = src[:, 1] \n    dst_cols = src[:, 0]\n\n    #['Identity','Y stretch','Pinch','Fish eye','Shear','Y squish','Radial']\n    # add sinusoidal oscillation to row coordinates\n    #transform='yscaleDarcy299Fig147'\n    if transform=='Identity':\n        dst_rows = src[:, 1] \n        dst_cols = src[:, 0]\n    elif transform=='Y stretch':\n        yscaleparam=a\n        dst_rows = dst_rows*yscaleparam\n        dst_cols = src[:, 0]\n    elif transform=='Pinch': #'yscaleDarcy299Fig151':\n        sc_factor=a\n        k_x=sc_factor*((dst_cols-cols/2.0)/cols)**1.0+1.0\n        dst_rows = k_x*(dst_rows-rows/2.0)+rows/2.0\n        #dst_cols = src[:, 0]\n    elif transform=='Fish eye': #'yscaleDarcy299Fig149':\n        dst_rows = ((dst_rows-rows/2.0)*(3.0-a*((dst_cols-cols/2.0)/(cols/2.0))**2.0))+rows/2.0\n        #dst_cols = (dst_cols-cols/2.0)*(dst_rows-rows/2.0)**2.0+cols/2.0\n\n        #dst_cols = src[:, 0]  \n\n        #dst_cols = src[:, 0]  \n    elif transform=='Shear': #'yscaleDarcy299Fig147':\n        k_y=-a\n        dst_cols = dst_cols+k_y*dst_rows\n        #dst_cols = src[:, 0]    \n    elif transform=='Y squish':\n        L=np.max(dst_rows)\n        dst_rows = (np.log(1.0+a*(dst_rows)/L))*L/np.log(2.0)\n        #dst_cols = src[:, 0]    \n    elif transform=='yscalepower':\n        L=np.max(dst_rows)\n        n=a\n        dst_rows = L*(dst_rows/L)**n\n        #dst_cols = src[:, 0]        \n    elif transform=='Radial':\n        dst_rows_max=np.max(dst_rows)\n        dst_cols_max=np.max(dst_cols)\n\n        centre=[cols/2.0,rows/2.0]\n        radius=np.sqrt((dst_rows-old_centre[0])**2+(dst_cols-old_centre[1])**2)\n        theta=np.arctan2(dst_rows-old_centre[0],dst_cols-old_centre[1])\n\n        R_typical=np.max(centre)\n        radius=R_typical*((radius.astype(float))/R_typical)**a\n        #theta=theta*1.0\n        dst_rows=radius*np.sin(theta)+old_centre[0]\n        dst_cols=radius*np.cos(theta)+old_centre[1]\n\n        #dst_rows=dst_rows/np.max(dst_rows)*dst_rows_max\n        #dst_cols=dst_cols/np.max(dst_cols)*dst_cols_max\n    elif transform =='thetascale':\n        dst_rows_max=np.max(dst_rows)\n        dst_cols_max=np.max(dst_cols)\n\n        radius=(radius.astype(float))**1.25\n        theta=theta*0.25\n        dst_rows=radius*np.sin(theta)+centre[0]\n        dst_cols=radius*np.cos(theta)+centre[1]\n\n\n    elif transform=='sine':\n        dst_rows = src[:, 1] - np.sin(np.linspace(0, 3 * np.pi, src.shape[0])) * 50\n        dst_cols = src[:, 0]\n        dst_rows *= 1.5\n        dst_rows -= 1.5 * 50\n\n\n    \n    dst = np.vstack([dst_cols, dst_rows]).T\n\n\n    # Calculate the corners of the rotated image\n    tform = PiecewiseAffineTransform()\n    tform.estimate(src, dst)\n\n    return tform, dst,src, rows, cols,dst_cols,dst_rows\n\n\n\n\n\nappdir = Path(__file__).parent\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"a\",label=\"Parameter\",min=-3.0,max=3,value=1.0,step=0.16),\n    \n    ui.input_select(id=\"trans\",label=\"Transform\",choices=['Identity','Y stretch','Pinch','Fish eye','Shear','Y squish','Radial'],selected=['Pinch']),\n    ui.input_file(id='input_file',label='Input file',width='1%',button_label='Upload',accept=['.png,.jpg','jpeg'])                 \n    ,width=3,),\n    ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    \n    @reactive.calc\n    def load_image():\n        im_index=1#input.d()\n        #load_image=1\n        if im_index==1:\n            image =  ski.data.coins()\n        image_orig=image[-1:0:-1,:]\n        return image_orig\n\n    @render.plot\n    def plot():\n\n        image= load_image()\n\n        def parsed_file():\n            file: list[FileInfo] | None = input.input_file()\n            if file is None:\n                return pd.DataFrame()\n            \n            return imread(  # pyright: ignore[reportUnknownMemberType]\n            file[0][\"datapath\"])\n\n\n        if input.input_file():\n            image = parsed_file()\n            #image=image[-1:0:-1]\n\n        if len(image.shape)==3:\n            im_num_voxels=float(image.shape[0]*image.shape[1])\n            target_num_voxels=100000.0\n            target_num_voxels=np.min([target_num_voxels,im_num_voxels])\n\n            rescale_factor= target_num_voxels/im_num_voxels\n            image=rescale(image,rescale_factor,channel_axis=2,anti_aliasing=True)\n            \n        old_centre=np.array((image.shape[0]/2.0,image.shape[1]/2.0))\n\n        fig,ax=plt.subplots(1,2,sharey=True,sharex=True)\n\n        # Input parameters\n        a =float(input.a())\n        trans=input.trans()\n        new_image=image\n        transform=trans\n        a_i=a\n        tform,dst,src,rows, cols,dst_cols,dst_rows= ChooseTransform(transform,new_image.shape,a_i,4,old_centre) \n\n        # Find corners\n        corners = np.array([[0, 0], [0, new_image.shape[0]], [new_image.shape[1], 0], [new_image.shape[1], new_image.shape[0]]])\n        tformed_corners = tform(corners)\n\n\n        minc = tformed_corners.min(axis=0)\n        maxc = tformed_corners.max(axis=0)\n\n        # Find dimensions of transformed box\n        output_shape = 2*(np.ceil(maxc)[::-1]-np.ceil(minc)[::-1]).astype(int)\n\n\n        # Calculate the translation required to move all points into positive coordinates\n        min_coords = dst.min(axis=0)\n        translation = -min_coords\n        tform_shift = AffineTransform(translation=translation)\n\n        # Apply the warp with translation to ensure positive coordinates\n        output_shape = (int(rows + 2*translation[1]), int(cols + 2*translation[0]))\n        new_image_trans = warp(new_image, tform_shift.inverse , output_shape=output_shape)\n    \n        # Define transform on new image\n        # Define the forward transform and transform the image\n        tform,dst,src,rows, cols,dst_cols,dst_rows= ChooseTransform(transform,new_image_trans.shape,a_i,30,old_centre)\n    \n        new_image = warp(new_image_trans,tform.inverse)\n\n        # Plot image + transform\n        ax[0].imshow(image)\n        ax[0].set_title('Original')\n        \n        ax[1].imshow(new_image)\n        ax[1].set_title('Transformed')\n\n        fig.subplots_adjust(wspace=0, hspace=0)\n        fig.tight_layout()\n        plt.show()\n    \n    \n\n\napp = App(app_ui, server)\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "posts/Mappings2D.html#composite-maps",
    "href": "posts/Mappings2D.html#composite-maps",
    "title": "D’Arcy Thompson and 2D mappings",
    "section": "Composite maps",
    "text": "Composite maps\nWe can build composite maps by using the output image from one transform as the input image for another. In Figure 3 you can explore the effect of combining two transforms successively. This allows for the construction of many interesting final images.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 600\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport skimage as ski\nimport pyodide\nfrom skimage.transform import SimilarityTransform\nfrom skimage.transform import warp\nfrom skimage.transform import PiecewiseAffineTransform\nfrom skimage.transform import AffineTransform\nfrom skimage.io import imread\nimport io\nfrom pathlib import Path\nfrom skimage.transform import resize, rescale\n\ndef ChooseTransform(transform,im_shape,a,num_disc_points,old_centre):\n    rows=im_shape[0]\n    cols=im_shape[1]\n\n    src_cols = np.linspace(0, cols, num_disc_points)\n    src_rows = np.linspace(0, rows, num_disc_points)\n    src_rows, src_cols = np.meshgrid(src_rows, src_cols)\n    src = np.dstack([src_cols.flat, src_rows.flat])[0]\n    dst_rows = src[:, 1] \n    dst_cols = src[:, 0]\n\n    #['Identity','Y stretch','Pinch','Fish eye','Shear','Y squish','Radial']\n    # add sinusoidal oscillation to row coordinates\n    #transform='yscaleDarcy299Fig147'\n    if transform=='Identity':\n        dst_rows = src[:, 1] \n        dst_cols = src[:, 0]\n    elif transform=='Y stretch':\n        yscaleparam=a\n        dst_rows = dst_rows*yscaleparam\n        dst_cols = src[:, 0]\n    elif transform=='Pinch': #'yscaleDarcy299Fig151':\n        sc_factor=a\n        k_x=sc_factor*((dst_cols-cols/2.0)/cols)**1.0+1.0\n        dst_rows = k_x*(dst_rows-rows/2.0)+rows/2.0\n        #dst_cols = src[:, 0]\n    elif transform=='Fish eye': #'yscaleDarcy299Fig149':\n        dst_rows = (dst_rows-rows/2.0)*(2.5-a*((dst_cols-cols/2.0)/(cols/2.0))**2.0)+rows/2.0\n        #dst_cols = (dst_cols-cols/2.0)*(dst_rows-rows/2.0)**2.0+cols/2.0\n\n        #dst_cols = src[:, 0]  \n\n        #dst_cols = src[:, 0]  \n    elif transform=='Shear': #'yscaleDarcy299Fig147':\n        k_y=-a\n        dst_cols = dst_cols+k_y*dst_rows\n        #dst_cols = src[:, 0]    \n    elif transform=='Y squish':\n        L=np.max(dst_rows)\n        dst_rows = (np.log(1.0+a*(dst_rows)/L))*L/np.log(2.0)\n        #dst_cols = src[:, 0]    \n    elif transform=='yscalepower':\n        L=np.max(dst_rows)\n        n=a\n        dst_rows = L*(dst_rows/L)**n\n        #dst_cols = src[:, 0]        \n    elif transform=='Radial':\n        dst_rows_max=np.max(dst_rows)\n        dst_cols_max=np.max(dst_cols)\n\n        centre=[cols/2.0,rows/2.0]\n        radius=np.sqrt((dst_rows-old_centre[0])**2+(dst_cols-old_centre[1])**2)\n        theta=np.arctan2(dst_rows-old_centre[0],dst_cols-old_centre[1])\n\n        R_typical=np.max(centre)\n        radius=R_typical*((radius.astype(float))/R_typical)**a\n        #theta=theta*1.0\n        dst_rows=radius*np.sin(theta)+old_centre[0]\n        dst_cols=radius*np.cos(theta)+old_centre[1]\n\n        #dst_rows=dst_rows/np.max(dst_rows)*dst_rows_max\n        #dst_cols=dst_cols/np.max(dst_cols)*dst_cols_max\n    elif transform =='thetascale':\n        dst_rows_max=np.max(dst_rows)\n        dst_cols_max=np.max(dst_cols)\n\n        radius=(radius.astype(float))**1.25\n        theta=theta*0.25\n        dst_rows=radius*np.sin(theta)+centre[0]\n        dst_cols=radius*np.cos(theta)+centre[1]\n\n\n    elif transform=='sine':\n        dst_rows = src[:, 1] - np.sin(np.linspace(0, 3 * np.pi, src.shape[0])) * 50\n        dst_cols = src[:, 0]\n        dst_rows *= 1.5\n        dst_rows -= 1.5 * 50\n\n\n    \n    dst = np.vstack([dst_cols, dst_rows]).T\n\n\n    # Calculate the corners of the rotated image\n\n\n    tform = PiecewiseAffineTransform()\n    tform.estimate(src, dst)\n\n    return tform, dst,src, rows, cols,dst_cols,dst_rows\n\n\nappdir = Path(__file__).parent\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"a1\",label=\"Parameter 1\",min=-3.0,max=3,value=1.0,step=0.16),\n    ui.input_slider(id=\"a2\",label=\"Parameter 2\",min=-3.0,max=3,value=1.0,step=0.16),\n    \n    \n    ui.input_select(id=\"trans1\",label=\"Transform 1\",choices=['Identity','Y stretch','Pinch','Fish eye','Shear','Y squish','Radial'],selected=['Pinch']),\n    ui.input_select(id=\"trans2\",label=\"Transform 2\",choices=['Identity','Y stretch','Pinch','Fish eye','Shear','Y squish','Radial'],selected=['Pinch']),\n    ui.input_file(id='input_file',label='Input file',width='1%',button_label='Upload',accept=['.png,.jpg','jpeg'])                 \n    ,width=3,),\n    ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    \n\n\n    @reactive.calc\n    def load_image():\n        im_index=1#input.d()\n        #load_image=1\n        if im_index==1:\n            image =  ski.data.coins()\n        image_orig=image[-1:0:-1,:]\n        return image_orig\n\n    @render.plot\n    def plot():\n\n        image= load_image()\n\n        def parsed_file():\n            file: list[FileInfo] | None = input.input_file()\n            if file is None:\n                return pd.DataFrame()\n            \n            return imread(  # pyright: ignore[reportUnknownMemberType]\n            file[0][\"datapath\"])\n\n\n        if input.input_file():\n            image = parsed_file()\n            #image=image[-1:0:-1]\n\n        if len(image.shape)==3:\n            im_num_voxels=float(image.shape[0]*image.shape[1])\n            target_num_voxels=100000.0\n            target_num_voxels=np.min([target_num_voxels,im_num_voxels])\n\n            rescale_factor= target_num_voxels/im_num_voxels\n            image=rescale(image,rescale_factor,channel_axis=2,anti_aliasing=True)\n\n        fig,ax=plt.subplots(1,2,sharey=True,sharex=True)\n\n        # Input parameters\n        a1 =float(input.a1())\n        a2 =float(input.a2())\n\n        trans1 =input.trans1()\n        trans2 =input.trans2()\n        trans=[trans1,trans2]\n\n        old_centre=np.array((image.shape[0]/2.0,image.shape[1]/2.0))\n       \n        trans=[trans1,trans2]\n        a=[a1,a2]\n\n        new_image=image\n        for tranform_i,a_i in zip(trans,a):\n            transform=tranform_i\n            tform,dst,src,rows, cols,dst_cols,dst_rows= ChooseTransform(transform,new_image.shape,a_i,4,old_centre) \n\n            # Find corners\n            corners = np.array([[0, 0], [0, new_image.shape[0]], [new_image.shape[1], 0], [new_image.shape[1], new_image.shape[0]]])\n            tformed_corners = tform(corners)\n\n\n            minc = tformed_corners.min(axis=0)\n            maxc = tformed_corners.max(axis=0)\n\n            # Find dimensions of transformed box\n            output_shape = 2*(np.ceil(maxc)[::-1]-np.ceil(minc)[::-1]).astype(int)\n\n\n            # Calculate the translation required to move all points into positive coordinates\n            min_coords = dst.min(axis=0)\n            translation = -min_coords\n            tform_shift = AffineTransform(translation=translation)\n\n            # Apply the warp with translation to ensure positive coordinates\n            output_shape = (int(rows + 2*translation[1]), int(cols + 2*translation[0]))\n            new_image_trans = warp(new_image, tform_shift.inverse , output_shape=output_shape)\n        \n            # Define transform on new image\n            # Define the forward transform and transform the image\n            tform,dst,src,rows, cols,dst_cols,dst_rows= ChooseTransform(transform,new_image_trans.shape,a_i,30,old_centre)\n       \n            new_image = warp(new_image_trans,tform.inverse)\n\n        # Plot image + transform\n        ax[0].imshow(image)\n        ax[0].set_title('Original')\n        \n        ax[1].imshow(new_image)\n        ax[1].set_title('Composite transformed')\n\n        fig.subplots_adjust(wspace=0, hspace=0)\n        fig.tight_layout()\n        plt.show()\n    \n    \n\n\napp = App(app_ui, server)\n\n\n\n\nFigure 3\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nSuppose we have an image, \\(I\\), and two mappings, \\(f\\) and \\(g\\).\nWe represent transformation of the image via the first transform as\n\\[\nI'=f \\circ I.\n\\]\nApplying the second transform yields \\[\nI''=g\\circ (f \\circ I).\n\\]\nWe might then ask:\n\nis the final image affected by the order in which you perform the transformations (i.e. is \\(f\\circ g = g\\circ f\\))?\ndoes an inverse mapping exist such that any transformation can be reversed via a further transformation? i.e. for a given \\(f\\) can we find a \\(g\\) such that \\[\nI''=g\\circ (f \\circ I)=I.\n\\]\n\nBy understanding whether such properties hold, we can classify different families of mappings and better understand why particular mappings behave the way that they do.\nAt Dundee, concepts from geometry are studied in core modules Maths 1A and Maths 1B.\nAt Level 3 in the module Differential Geometry students study generalisations of 2D mappings to arbitrarily curved spaces.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/PopulationDynamicsIntro.html",
    "href": "posts/PopulationDynamicsIntro.html",
    "title": "Introduction to population dynamics",
    "section": "",
    "text": "We can use calculus to study how populations change in time. In the examples below we consider an illustrative model of population dynamics in a class room. The developed concepts can be used to study population dynamics of infectious disease transmission.\n\n\nYou might have previously encountered differentiation. Suppose that \\(y\\) is some function of \\(x\\).\nConsider the differential equation\n\\[\n\\frac{dy}{dx}=1\n\\]\nUpon integration\n\\[\ny(x)=x+C\n\\] where \\(C\\) is an integration constant.\nWhat if \\[\n\\frac{dy}{dx}=x\n\\]\nCan you integrate this ordinary differential equation?"
  },
  {
    "objectID": "posts/PopulationDynamicsIntro.html#sec-background",
    "href": "posts/PopulationDynamicsIntro.html#sec-background",
    "title": "Introduction to population dynamics",
    "section": "",
    "text": "You might have previously encountered differentiation. Suppose that \\(y\\) is some function of \\(x\\).\nConsider the differential equation\n\\[\n\\frac{dy}{dx}=1\n\\]\nUpon integration\n\\[\ny(x)=x+C\n\\] where \\(C\\) is an integration constant.\nWhat if \\[\n\\frac{dy}{dx}=x\n\\]\nCan you integrate this ordinary differential equation?"
  },
  {
    "objectID": "posts/PopulationDynamicsIntro.html#constant-entry-rate",
    "href": "posts/PopulationDynamicsIntro.html#constant-entry-rate",
    "title": "Introduction to population dynamics",
    "section": "2.1 Constant entry rate",
    "text": "2.1 Constant entry rate\nLet’s consider a model for the number of people in a classroom at a given time. Let \\(t\\) represent time and \\(N(t)\\) represent the number of people in the room at time \\(t\\).\nSuppose that there are initially no people in the room, but people enter at a constant rate, \\(k\\).\nWe could formulate a model of population dynamics given by\n\\[\n\\frac{dN}{dt}=k, \\quad N(0)=0.\n\\]\n\nCan you integrate this ODE (hint: it is mathematically equivalent to the ODE introduced in Section 1.1)?\nCan you use the model to determine the amount of time taken for the number of people in the room to reach capacity, \\(N_C\\).\nThe app in Figure 1 allows you to explore the solution of the model. Can you identify what the entry rate needs to be such that the room reaches capacity of 40 people after 20 minutes?\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"k\",label=\"Entry rate (per minute)\",min=0.01,max=3,value=0.1,step=0.00001),\n    ui.input_slider(id=\"N0\",label=\"initial pop\",min=0.0,max=20.0,value=0.1,step=1.0),\n    \n    ui.input_slider(id=\"T\",label=\"Simulation time (minutes)\",min=0.0,max=60.0,value=20.0,step=0.5),\n    ui.input_slider(id=\"max_inf\",label=\"Max. num\",min=0.0,max=100.0,value=40.0,step=1.5),             \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        k=float(input.k())\n        N_0=float(input.N0())\n        T=float(input.T())\n        max_inf=float(input.max_inf())\n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(x,t,k,r):\n          rhs=np.zeros_like(x,dtype=float)\n          N=x[0]\n          dN_dt=k\n          rhs[0]=dN_dt\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[N_0]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_pop_model, init_cond,t,args=(k,1))\n\n        # Plot results\n        N=sol1[:,0]\n        \n        \n        ax.plot(t, N)\n        ax.plot(t,max_inf*np.ones_like(t),'--')\n        ax.legend(['N','Max. room occupancy'],loc='best')\n        ax.set_xlabel('$t$ (minutes)')\n        ax.set_ylim([0,max_inf*1.4])\n\n        #plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1"
  },
  {
    "objectID": "posts/PopulationDynamicsIntro.html#what-if-people-enter-the-room-at-a-constant-rate-but-also-leave-the-room-at-random",
    "href": "posts/PopulationDynamicsIntro.html#what-if-people-enter-the-room-at-a-constant-rate-but-also-leave-the-room-at-random",
    "title": "Introduction to population dynamics",
    "section": "2.2 What if people enter the room at a constant rate but also leave the room at random?",
    "text": "2.2 What if people enter the room at a constant rate but also leave the room at random?\nTaking the previous model as a starting point, we now assume that people leave the room at a rate proportional to the number of people in the room\nThe model equation is now given by\n\\[\n\\frac{dN}{dt}=k - dN, \\quad N(0)=0.\n\\]\nCan you integrate this ODE (hint: try a technique called separation of variables)?\nIf so, can you use the model to determine the amount of time taken for the number of people in the room to reach capacity, \\(N_C\\).\nThe app in Figure 2 allows you to explore the solution of the model. Can you identify what the entry rate needs to be such that the room reaches capacity of 40 people after 20 minutes given \\(d=0.1\\)?\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 600\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"k\",label=\"Entry rate (per minute)\",min=0.01,max=10,value=0.1,step=0.00001),\n    ui.input_slider(id=\"d\",label=\"exit rate (per minute)\",min=0.01,max=3,value=0.1,step=0.00001),\n    ui.input_slider(id=\"N0\",label=\"initial pop\",min=0.0,max=20.0,value=0.1,step=1.0),\n    \n    ui.input_slider(id=\"T\",label=\"Simulation time (minutes)\",min=0.0,max=60.0,value=20.0,step=0.5),\n    ui.input_slider(id=\"max_inf\",label=\"Max. num\",min=0.0,max=100.0,value=40.0,step=1.5),             \n          \n            ),\n\n        ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        k=float(input.k())\n        d=float(input.d())\n\n        N_0=float(input.N0())\n        T=float(input.T())\n        max_inf=float(input.max_inf())\n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(x,t,k,d):\n          rhs=np.zeros_like(x,dtype=float)\n          N=x[0]\n          dN_dt=k-d*N\n          rhs[0]=dN_dt\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[N_0]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_pop_model, init_cond,t,args=(k,d))\n\n        # Plot results\n        N=sol1[:,0]\n        \n        \n        ax.plot(t, N)\n        ax.plot(t,max_inf*np.ones_like(t),'--')\n        ax.legend(['N','Max. room occupancy'],loc='best')\n        ax.set_xlabel('$t$ (minutes)')\n        ax.set_ylim([0,max_inf*1.4])\n\n        #plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, core concepts from calculus (e.g. differential equations) are studied in the modules Maths 1A and Maths 1B and developed further in the modules Maths 2A and Maths 2B.\nAt Level 2 in the modules Computer algebra and dynamical systems and Introduction to Programming you would be introduced to techniques that are used to compute numerical solutions to differential equations.\nAt Level 3 in the module Differential Equations you would extend your knowledge of differential equations to include concepts such as Fourier Series and Partial Differential Equations. In the modules Mathematical Biology I and Mathematical Biology II you would also learn how to formulate and study mathematical models of biological systems.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/TheSIRModel.html",
    "href": "posts/TheSIRModel.html",
    "title": "Modelling the spread of infectious disease",
    "section": "",
    "text": "Infectious disease\nInfectious diseases can have severe health outcomes for individuals who contract them. They can also place an unmanageably large demand on the health service.\nInfectious diseases can be characterised using their basic reproduction number, \\(R_0\\).\n\nInfectious disease basic reproduction numbers Source.\n\n\nDisease\n\\(R_0\\)\n\n\n\n\nMeasles\n12-18\n\n\nChickenpox\n10-12\n\n\nRubella\n6-7\n\n\nCommon cold\n2-3\n\n\nCovid 19 (Omicron)\n9.5\n\n\n\n\n\nMathematical modelling of infectious diseases\nWe can use mathematics to study the dynamics of an infectious disease within a population. In the SIR model a population is split into three compartments:\n\n\\(S(t)\\) - size of susceptible population at time \\(t\\)\n\\(I(t)\\) - size of infected population at time \\(t\\)\n\\(R(t)\\) - size of recovered/post-infected population at time \\(t\\)\n\nThe SIR model has two parameters:\n\n\\(r\\) - infection rate\n\\(a\\) - recovery rate\n\nFrom a public health perspective, one could propose that there is some level of infectiousness, \\(I_{max}\\), which must be avoided. The challenge is to manage the disease such that \\(I(t)&lt;I_{max}\\) for all \\(t\\).\nIn the app in Figure 1 you can investigate how the values of the parameters \\(r\\) and \\(a\\) affect the trajectory of the infectious disease.\n\n\n\n\n\n\nTip\n\n\n\nPlease note that the app in Figure 1 is approximately 20 MB. If it does not display on your device:\n\nwait a few moments (it is downloading the Python code that will run the app)\nrefresh your browser.\n\ntry running on a faster connection/ more powerful device.\n\nIf it still does not load, here is a screenshot.\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"r\",label=\"r\",min=0.00001,max=0.001,value=0.001,step=0.00001),\n    ui.input_slider(id=\"S0\",label=\"Initial susceptible pop. (S(0))\",min=1000.0,max=8000.0,value=4000.1,step=5.0),\n    ui.input_slider(id=\"a\",label=\"a\",min=0.01,max=0.2,value=0.05,step=0.001),            \n    ui.input_slider(id=\"I0\",label=\"Initial infectious pop. (I(0)) \",min=0.0,max=17.0,value=17.0,step=0.5),  \n    ui.input_slider(id=\"T\",label=\"Simulation time\",min=0.0,max=70.0,value=40.0,step=0.5),\n    ui.input_slider(id=\"max_inf\",label=\"Max. infectiousness\",min=0.0,max=10000.0,value=2500.0,step=100.5),             \n          \n            ),\n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        S_0=float(input.S0())\n        a=float(input.a())\n        I_0=float(input.I0())\n        T=float(input.T())\n        max_inf=float(input.max_inf())\n\n        R_0=r*S_0/a\n        \n        # Define rhs of LV ODEs\n        def rhs_sir_model(x,t,r,a):\n          rhs=np.zeros_like(x,dtype=float)\n          S=x[0]\n          I=x[1]\n          R=x[2]\n\n          \n\n          dS_dt=-r*I*S\n          dI_dt=r*I*S-a*I\n          dR_dt=a*I\n\n          rhs[0]=dS_dt\n          rhs[1]=dI_dt\n          rhs[2]=dR_dt\n\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[S_0,I_0,0.0]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_sir_model, init_cond,t,args=(r,a))\n\n        # Plot results\n        S=sol1[:,0]\n        I=sol1[:,1]\n        R=sol1[:,2]\n        \n        ax.plot(t, S, 'b',t,I,'r',t,R,'k')\n        ax.plot(t,max_inf*np.ones_like(t),'--')\n        ax.legend(['S','I','R','Max. allowed infectiousness'],loc='best')\n        ax.set_xlabel('$t$')\n        ax.set_title('R_0 =' + str(R_0))\n\n        #plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1: The sizes of the different populations are plotted against time, \\(t\\). The model parameters are defined using the sliders on the left-hand side. The differential equations are in Equation 1.\n\n\n\n\n\nExercises with the app\n\ncan you determine what value the infectivity parameter, \\(r\\), must go below in order that \\(I(t)&lt;I_{max}\\)?\nsuppose that covid omicron in a susceptible population of \\(S_0=5000\\) has a recovery rate \\(a=0.05\\). Can you estimate the value of the infectivity parameter, \\(r\\), such that \\(R_0=9.5\\)?\nwhich parameters in the app best represent the effect of vaccination of a section of the population?\n\n\n\nThe SIR model equations\nThe SIR model is formulated as a system of ordinary differential equations.\nOn this page we consider a simpler case of a single population.\nThe governing equations in the SIR model are: \\[\n\\begin{aligned}\n\\frac{dS}{dt}&=-rIS, \\\\\n\\frac{dI}{dt}&=rIS-aI, \\\\\n\\frac{dR}{dt}&=aI.\n\\end{aligned}\n\\tag{1}\\]\nThe initial conditions are:\n\\[\n\\begin{aligned}\nS(t=0)&=S_0, \\\\\nI(t=0)&=I_0, \\\\\nR(t=0)&=R_0.\n\\end{aligned}\n\\]\nIn the app in Figure 1 Equation 1 are solved numerically for a given parameter set and the solution is plotted.\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, the mathematical tools needed are developed in modules:\n\nMaths 1A, 1B, 2A and 2B (Core maths modules)\nComputer algebra and dynamical systems\nMathematical Biology I\nMathematical Biology II\n\nAt Levels 2, 3 and 4 you will learn how to use computer programming to explore and communicate mathematical concepts.\nYou can find out more about these modules here."
  },
  {
    "objectID": "posts/IntersectingLines.html",
    "href": "posts/IntersectingLines.html",
    "title": "Intersecting lines and linear algebra",
    "section": "",
    "text": "Intersecting lines in two dimensional space\nConsider the equations of two straight lines given by \\[\ny=m_1x+c_1\n\\tag{1}\\] and \\[\ny=m_2x+c_2,\n\\tag{2}\\] where \\(m_1\\), \\(m_2\\), \\(c_1\\) and \\(c_2\\) are constants.\nIn Figure 1 you can play with the slopes and intercepts of the lines. Can you spot a condition that holds on the slopes such that the straight lines do not intersect?\nProblems such as the intersection of straight lines can be formulated using linear algebra. In the title of Figure 1 the determinant of a matrix (defined below) is reported for given values of the slopes and intercept. Can you spot a relationship between the value of the matrix determinant and the geometric properties of the lines?\n\n\n\n\n\n\nTip\n\n\n\nPlease note that the app in Figure 1 is approximately 20 MB. If it does not display on your device:\n\nwait a moment (it is downloading the Python code that will run the app)\nrefresh your browser.\n\nIf it still does not load, here is a screenshot.\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n    ui.input_slider(id=\"m_1\",label=\"m_1\",min=-5,max=5,value=1.0,step=0.2),\n    ui.input_slider(id=\"c_1\",label=\"c_1\",min=-5.0,max=5.0,value=1.0,step=0.2),\n    ui.input_slider(id=\"m_2\",label=\"m_2\",min=-5.0,max=10.0,value=5.0,step=0.2),            \n    ui.input_slider(id=\"c_2\",label=\"c_2\",min=-5.0,max=10.0,value=5.0,step=0.2),            \n    ),\n    ui.panel_main(ui.output_plot(\"plot\"),),\n    ),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n                \n        m_1=float(input.m_1())\n        c_1=float(input.c_1())\n        m_2=float((input.m_2()))\n        c_2=float((input.c_2()))\n\n        # Define discretised t domain\n        x = np.linspace(-10, 10, 100)\n        y_1 = m_1*x+c_1\n        y_2 = m_2*x+c_2\n\n        ax.plot(x, y_1, x,y_2)\n        matrix=np.zeros((2,2))\n        matrix[0,0]=m_1\n        matrix[0,1]=1.0\n        matrix[1,0]=m_2\n        matrix[1,1]=1.0\n\n        matrix=np.matrix(matrix)\n\n        determinant=np.linalg.det(matrix)\n        ax.set_title('$\\det{A}$ = ' +str(determinant))\n        ax.set_ylim([-10,10])\n        ax.set_xlim([-10,10])\n        ax.grid(True)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n    \napp = App(app_ui, server)\n\n\nFigure 1: A plot of two lines in 2D plane.\n\n\n\nTo find the intersection of the lines we can rearrange Equation 1 and Equation 2 to obtain \\[\n\\begin{aligned}\nm_1x-y&=-c_1, \\\\\nm_2x-y&=-c_2.\n\\end{aligned}\n\\] The equations can be written in matrix-vector form as \\[\nA \\mathbf{x}=\\mathbf{b},\n\\] where \\[\nA=\\begin{pmatrix} m_1 & -1 \\\\ m_2 & -1\\end{pmatrix},\n\\] and \\[\n\\mathbf{b}=\\begin{pmatrix} -c_1 \\\\ -c_2\\end{pmatrix},\n\\] with \\[\n\\mathbf{x}=\\begin{pmatrix} x \\\\ y\\end{pmatrix}.\n\\]\nThe matrix determinant is defined to be \\[\n\\det{A}=-m_1 +m_2.\n\\]\nHence when the slopes of the lines are equal, the matrix determinant is zero. In this case the lines are parallel and there is either:\n\nno intersection (the lines have distinct intercepts)\nan infinite family of intersections (the lines also have the same intercept).\n\n\n\nIntersecting lines in three dimensional space\nWe will now explore the intersection of two lines in 3D space.\nConsider a line in 3D with direction vector [1,1,1] that passes through the origin. The equation for the line can be written in parametric form as \\[\n\\mathbf{r}_1= \\lambda_1 [1,1,1]^T, \\quad \\lambda_1 \\in \\Re.\n\\]\nConsider a second line defined such that \\[\n\\mathbf{r}_2= \\lambda_2 \\mathbf{t}+ \\mathbf{c}, \\quad \\lambda_2 \\in \\Re.\n\\]\nIn Figure 2 you can play with the direction vector, \\(\\mathbf{t}\\), and the point \\(\\mathbf{c}\\) of the second line.\nIn the app set \\(c=[c_1,c_2,c_3]^T=[0,0,0]^T\\). Can you demonstrate that\n\nwhen \\(t=[t_1,t_2,t_3]^T=[1,-1,0]^T\\) that the lines intersect at the origin?\nwhen \\(t=[t_1,t_2,t_3]^T=[1,1,1]^T\\) the minimum distance between the lines is reported as nan (not a number)?\n\nTo compute the shortest distance between the two lines we can identify the points on each of the lines (parameters \\(\\lambda^*\\) and \\(\\mu^*\\)) that define closest approach. The equations to define \\(\\lambda^*\\) and \\(\\mu^*\\) can be written in matrix-vector form as \\[\nA \\mathbf{x}=\\mathbf{b},\n\\tag{3}\\] where \\[\nA=\\begin{pmatrix} \\mathbf{s}\\cdot\\mathbf{s} & -\\mathbf{t}\\cdot \\mathbf{s} \\\\ \\mathbf{t}\\cdot \\mathbf{s} & -\\mathbf{t}\\cdot \\mathbf{t}\\end{pmatrix},\n\\] and \\[\n\\mathbf{b}=\\begin{pmatrix} \\mathbf{c}\\cdot \\mathbf{s} \\\\ \\mathbf{c}\\cdot \\mathbf{t}\\end{pmatrix},\n\\] with \\[\n\\mathbf{x}=\\begin{pmatrix} \\lambda^* \\\\ \\mu^*\\end{pmatrix}.\n\\] Here \\(\\mathbf{s}\\) represents the direction vector for the first line.\nIf a solution to Equation 3 can be found then it is straightforward to calculate the shortest distance, \\(d\\), between the straight lines.\n\n\n\n\n\n\nTip\n\n\n\nPlease note that the app in Figure 2 is approximately 20 MB. If it does not display on your device:\n\nwait a moment (it is downloading the Python code that will run the app)\nrefresh your browser.\n\nIf it still does not work, here is a screenshot.\n\n\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    \n    ui.input_slider(id=\"t_1\",label=\"t_1\",min=-5.0,max=10.0,value=5.0,step=0.2),            \n    ui.input_slider(id=\"t_2\",label=\"t_2\",min=-5.0,max=10.0,value=2.0,step=0.2),     \n    ui.input_slider(id=\"t_3\",label=\"t_3\",min=-5.0,max=10.0,value=1.0,step=0.2),         \n    ui.input_slider(id=\"c_1\",label=\"c_1\",min=-10.0,max=10.0,value=-5.0,step=0.2),  \n    ui.input_slider(id=\"c_2\",label=\"c_2\",min=-10.0,max=10.0,value=5.0,step=0.2),\n    ui.input_slider(id=\"c_3\",label=\"c_3\",min=-10.0,max=10.0,value=5.0,step=0.2),\n    ui.input_slider(id=\"azim_ang\",label=\"Rotate view\",min=-180.0,max=180.0,value=0.0,step=0.1), \n            ),        \n\n        ui.output_plot(\"plot\"),\n    ),\n)\n\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        ax = plt.figure().add_subplot(projection='3d')\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        s_1=1.0\n        s_2=1.0\n        s_3=1.0\n   \n        t_1=float((input.t_1()))\n        t_2=float((input.t_2()))\n        t_3=float((input.t_3()))\n        c_1=float((input.c_1()))\n        c_2=float((input.c_2()))\n        c_3=float((input.c_3()))\n        azim_ang=float((input.azim_ang()))\n\n        \n\n        # Define discretised t domain\n\n        # L1:r=s*lam+[0,0,0]\n        # L2:r=t*lam+[c_1,c_2,c_3]\n        #  Define  points on lines (need to used scatter as rendering of plot in 3d using matplotlib id a problem)\n        lam=np.linspace(-15.0,15.0,5000)\n        L1_x=lam*[s_1]+[0.0] \n        L1_y=lam*[s_2]+[0.0] \n        L1_z=lam*[s_3]+[0.0]\n        L2_x=lam*[t_1]+c_1 \n        L2_y=lam*[t_2]+c_2 \n        L2_z=lam*[t_3]+c_3\n\n\n        # define direction vectors of lines\n        c_0_vec=np.array([0,0,0])\n        c_2_vec=np.array([c_1,c_2,c_3])\n        s_vec=np.array([s_1,s_2,s_3] )\n        t_vec=np.array([t_1,t_2,t_3])  \n        # Find lambdas that define closest point on each lines\n        #lam_2=np.dot(c_2_vec-c_0_vec,s_vec-t_vec)/(np.dot(t_vec,t_vec)-np.dot(t_vec,s_vec))\n\n        A=np.array([[np.dot(s_vec,s_vec), -np.dot(t_vec,s_vec)],[np.dot(s_vec,t_vec), -np.dot(t_vec,t_vec)]])\n        b=np.array([np.dot(c_2_vec-c_0_vec,s_vec), np.dot(c_2_vec-c_0_vec,t_vec)])\n\n        determinant=np.linalg.det(A)\n\n        #A=np.array([[1,0],[0,1]])\n        #b=np.array([1,1])\n        x=np.dot(np.linalg.inv(A),b)\n\n        lam_1=x[0]\n        lam_2=x[1]    \n\n        # Expression for closest points\n        cp_1=lam_1*s_vec+c_0_vec\n        cp_2=lam_2*t_vec+c_2_vec\n        \n        # min distance\n        min_dist=np.linalg.norm(cp_2-cp_1)\n\n        #fig = plt.figure()\n        ax.scatter(L1_x,L1_y,L1_z)\n        ax.scatter(L2_x,L2_y,L2_z,'k*')\n        ax.plot([cp_1[0], cp_2[0]],[cp_1[1], cp_2[1]],[cp_1[2], cp_2[2]],'k')\n        ax.set_title('d = ' + str(np.round(min_dist,3))+ ', $\\det(A)$ = ' + str(np.round(determinant,3)))\n        my_matrix=np.array2string(A, suppress_small=True, formatter={'float': '{:0.4f}'.format})\n        \n        ax.text(-5,5,5.0, '$A=$'+my_matrix)\n        #ax.plot([L2_1[0],L2_2[0]], [L2_1[1],L2_2[1]],[L2_1[2],L2_2[2]],'r',alpha=0.8,linewidth=6)\n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$y$')\n        ax.set_zlabel('$z$')\n\n        ax.set_xlim([-10,10])\n\n        ax.set_ylim([-10,10])\n        ax.set_zlim([-10,10])\n        #ax.view_init(elev=30, azim=45.0, roll=15)\n        ax.view_init(elev=30, azim=azim_ang)\n\n        #determinant=np.linalg.det(matrix)\n\n\n\n\n\n        \n        #from matplotlib import rc\n        #rc('text', usetex=True)\n        #my_matrix = \"$$A=\\\\  \\\\begin{array}{ll} 2 & 3 \\\\ 4 & 5 \\\\end{array} \\\\$$\"\n        #text(my_matrix, (1,1))\n       \n        #ax.text(-10,40, '$A=$'+my_matrix)\n        #ax.annotate('$A$ = ' + matrix, xy = (-10, 40), fontsize = 16, xytext = (-10, 40), arrowprops = dict(facecolor = 'red'),color = 'g')\n        \n\n       # ax.annotate(\n    #\"$\\begin{matrix} a & b  \\\\ d & e  \\end{matrix} $\",\n   # (0.25, 0.25),\n   # textcoords='axes fraction', size=20)\n\n        \n\n        #text_x=0.25*(min_x+max_x)\n        #text_y=np.mean(y)\n        #title_Str= = ' '.join(map(str, (roots)))\n        #title_Str=[(\"R\"+ str(j) +\" = \" + str(roots[j]) ) for j in range(len(roots))]\n        #title_Str = str(title_Str)[1:-1]\n\n        #ax.set_title(title_Str)\n        #ax.set_title([(\"R\"+ str(j) +\" = \" + str(roots[j]) ) for j in range(len(roots))])\n\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 2: An app to explore the intersection between two straight lines in 3D. The blue line passes thorugh the origin and has direction vector \\([1,1,1]\\). The red line is controlled by the parameters in the left column. The black line connects the points on each line at which the distance between the lines is minimised. The minimal distance between the lines is reported in the title.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAt Dundee, the parametric equations of lines, spheres and planes are studied in the module Maths 1B.\nConcepts from geometry and linear algebra are generalised in the modules Maths 2A and Maths 2B.\nAt Level 3 in the module Differential Geometry geometrical concepts and tools that are essential for understanding classical and modern physics and engineering are further developed.\nAt Levels 2, 3 and 4 you will learn how to use computer programming to explore and communicate mathematical concepts.\nYou can find out more about these modules here."
  },
  {
    "objectID": "MathsWeekScotland2024/Worksheet.html",
    "href": "MathsWeekScotland2024/Worksheet.html",
    "title": "D’Arcy Thompson and 2D mappings Worksheet",
    "section": "",
    "text": "We can represent a point, \\(P\\), in the plane using a vector with components representing its \\(x\\) and \\(y\\) coordinates, i.e. \\[\n\\mathbf{v}_P=[x_P,y_P]\n\\] represent a point with coordinates \\(x_P\\) and \\(y_P\\).\nA transformation is performed by defining a new point, \\(P'\\), with new cooridnates that are some functions of the old coordinates, i.e. \\[\n\\mathbf{v}_{P'}=[x_{P'},y_{P'}]=[f(x_{P},y_{P}),g(x_{P},y_{P})].\n\\] where \\(f(.,.)\\) and \\(g(.,.)\\) are functions that will represent a particular transformation."
  },
  {
    "objectID": "MathsWeekScotland2024/Worksheet.html#linear-transformation",
    "href": "MathsWeekScotland2024/Worksheet.html#linear-transformation",
    "title": "D’Arcy Thompson and 2D mappings Worksheet",
    "section": "Linear transformation",
    "text": "Linear transformation\n\nTranslation\nSuppose that \\(f\\) and \\(g\\) are defined such that \\[\nf(x,y)=x+t_x\n\\] and \\[\ng(x,y)=y+t_y\n\\]\nwhere \\(t_x\\) and \\(t_y\\) are constants.\n\nCompute the transformation of the point \\(P(1,2)\\) in the case \\((t_x,t_y)=(3,0)\\).\nIdentify the inverse of the transformation in 1.\n\n\n\n\n\n\n\n\n\n\n\n\nScalings\nConsider a scaling transformation defined such that \\[\nf(x,y)=a*x\n\\] and \\[\ng(x,y)=b*y\n\\] where \\(b\\) is a constant.\n\nCompute the transformation of the point \\(P(2,1)\\) in the case \\(b=2\\).\nIdentify the inverse of the transformation in 1. Are there values of \\(b\\) for which an inverse does not exist?\n\n\n\n\n\n\n\n\n\n\n\n\nRotation\nNow consider a transformation \\[\nf(x,y)=\\cos\\theta x -\\sin\\theta y\n\\] and \\[\ng(x,y)=\\sin\\theta x +\\cos\\theta y\n\\]\nwhere \\(\\theta\\) is a constant value.\n\nCompute the transformation of the point \\(P(2,0)\\) in the case \\(\\theta=90\\deg (\\frac{\\pi}{2} rad)\\).\nIdentify the inverse of the transformation in 1.\n\n\n\n\n\n\n\n\n\n\n\n\nShear\n\\[\nf(x,y)=x+ay\n\\] and \\[\ng(x,y)= y\n\\] where \\(a\\) is a positive constant.\n\nCompute the transformation of the point \\(P(0,2)\\) in the case \\(a=2\\).\n\n\n\n\n\n\n\n\n\n\n\n\nA general representation\nIf you have been introduced to vectors and matrices then you may spot that the above transformations can be represented as a matrix multiplication of a vector.\nConsider the matrix \\[\nA=\n\\begin{pmatrix}\na_{11} & a_{12} \\\\ a_{21} & a_{22}\n\\end{pmatrix}.\n\\]\nDefine \\[\n\\mathbf{v}_{P'}=A\\mathbf{v}_P\n\\]\nCan you identify values of the parameters \\(a_{11}\\), \\(a_{12}\\) etc. that descibe the rotation, shear and scaling transformations?"
  },
  {
    "objectID": "Slides/STEMDayDecember2024/STEMDayDec2024.html#skills-developed-in-maths-degrees",
    "href": "Slides/STEMDayDecember2024/STEMDayDec2024.html#skills-developed-in-maths-degrees",
    "title": "STEM Day 2024",
    "section": "Skills developed in maths degrees",
    "text": "Skills developed in maths degrees\n\nStudents become logical numerate problem solvers\nDevelop technical mathematical skills\nLearn how to apply mathematics to different problems\nDevelop computer programming skills\nDevelop communication skills"
  },
  {
    "objectID": "Slides/STEMDayDecember2024/STEMDayDec2024.html#stem-skills-are-valuable",
    "href": "Slides/STEMDayDecember2024/STEMDayDec2024.html#stem-skills-are-valuable",
    "title": "STEM Day 2024",
    "section": "STEM skills are valuable",
    "text": "STEM skills are valuable"
  },
  {
    "objectID": "Slides/STEMDayDecember2024/STEMDayDec2024.html#teaching-delivery",
    "href": "Slides/STEMDayDecember2024/STEMDayDec2024.html#teaching-delivery",
    "title": "STEM Day 2024",
    "section": "Teaching delivery",
    "text": "Teaching delivery\n\nTwo teaching semesters in the academic year\n3 or 4 modules in each semester\nIn each module (some combination of):\n\nlectures\ntutorials\nworkshops\ncomputer classes"
  },
  {
    "objectID": "Slides/STEMDayDecember2024/STEMDayDec2024.html#final-year-project",
    "href": "Slides/STEMDayDecember2024/STEMDayDec2024.html#final-year-project",
    "title": "STEM Day 2024",
    "section": "Final year project",
    "text": "Final year project\n\ndevelop independent problem solving skills\nwork on an exciting mathematical topic\ndevelop programming and presentation skills\nTopics include:\n\nThe $25,000,000,000 eigenvector\nThe Mathematics of monopoly\nHow Sat Navs work?"
  },
  {
    "objectID": "Slides/STEMDayDecember2024/STEMDayDec2024.html#estimate-pi-using-monte-carlo-techniques",
    "href": "Slides/STEMDayDecember2024/STEMDayDec2024.html#estimate-pi-using-monte-carlo-techniques",
    "title": "STEM Day 2024",
    "section": "Estimate \\(\\pi\\) using Monte Carlo techniques",
    "text": "Estimate \\(\\pi\\) using Monte Carlo techniques\n\n\nProbability of uniformly sampled point falling in circle is\n\\[\n\\frac{\\textrm{Area circle}}{\\textrm{Area square}}=\\frac{\\pi}{4}\n\\]\n\n\n\n\n\n\n\n\n\nFigure 1"
  },
  {
    "objectID": "Slides/STEMDayDecember2024/STEMDayDec2024.html#estimate-definite-integral-using-monte-carlo-method",
    "href": "Slides/STEMDayDecember2024/STEMDayDec2024.html#estimate-definite-integral-using-monte-carlo-method",
    "title": "STEM Day 2024",
    "section": "Estimate definite integral using Monte Carlo method",
    "text": "Estimate definite integral using Monte Carlo method\n\n\nEstimate the definite integral \\[\n\\int_a^b f(x)\\textrm{d}x.\n\\]\nProb. of uniformly sampled point falling in shaded region \\[\n\\frac{\\textrm{Area shaded}}{\\textrm{Area square}}\n\\]\n\n\n\n\n\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "Slides/STEMDayDecember2024/STEMDayDec2024.html#method",
    "href": "Slides/STEMDayDecember2024/STEMDayDec2024.html#method",
    "title": "STEM Day 2024",
    "section": "Method",
    "text": "Method\n\nReal life sampling (rice grains)\nGet a computer to generate samples\n\nSee printed worksheet for further details."
  },
  {
    "objectID": "Slides/STEMDayDecember2024/STEMDayDec2024.html#what-have-we-learned",
    "href": "Slides/STEMDayDecember2024/STEMDayDec2024.html#what-have-we-learned",
    "title": "STEM Day 2024",
    "section": "What have we learned?",
    "text": "What have we learned?\n\nWe can study mathematics using experiential learning\nWe can program algorithms to help understand mathematical concepts\n\n\n\n\n\nMathematics, University of Dundee"
  },
  {
    "objectID": "Slides/STEMExpo2025/STEMExpo2025.html#skills-developed-in-maths-degrees",
    "href": "Slides/STEMExpo2025/STEMExpo2025.html#skills-developed-in-maths-degrees",
    "title": "STEM Day 2025",
    "section": "Skills developed in maths degrees",
    "text": "Skills developed in maths degrees\n\nStudents become logical numerate problem solvers\nDevelop technical mathematical skills\nLearn how to apply mathematics to different problems\nDevelop computer programming skills\nDevelop communication skills"
  },
  {
    "objectID": "Slides/STEMExpo2025/STEMExpo2025.html#stem-skills-are-valuable",
    "href": "Slides/STEMExpo2025/STEMExpo2025.html#stem-skills-are-valuable",
    "title": "STEM Day 2025",
    "section": "STEM skills are valuable",
    "text": "STEM skills are valuable"
  },
  {
    "objectID": "Slides/STEMExpo2025/STEMExpo2025.html#teaching-delivery",
    "href": "Slides/STEMExpo2025/STEMExpo2025.html#teaching-delivery",
    "title": "STEM Day 2025",
    "section": "Teaching delivery",
    "text": "Teaching delivery\n\nTwo teaching semesters in the academic year\n3 or 4 modules in each semester\nIn each module (some combination of):\n\nlectures\ntutorials\nworkshops\ncomputer classes"
  },
  {
    "objectID": "Slides/STEMExpo2025/STEMExpo2025.html#final-year-project",
    "href": "Slides/STEMExpo2025/STEMExpo2025.html#final-year-project",
    "title": "STEM Day 2025",
    "section": "Final year project",
    "text": "Final year project\n\ndevelop independent problem solving skills\nwork on an exciting mathematical topic\ndevelop programming and presentation skills\nTopics include:\n\nThe $25,000,000,000 eigenvector\nThe Mathematics of monopoly\nHow Sat Navs work?"
  },
  {
    "objectID": "Slides/STEMExpo2025/STEMExpo2025.html#estimate-pi-using-monte-carlo-techniques",
    "href": "Slides/STEMExpo2025/STEMExpo2025.html#estimate-pi-using-monte-carlo-techniques",
    "title": "STEM Day 2025",
    "section": "Estimate \\(\\pi\\) using Monte Carlo techniques",
    "text": "Estimate \\(\\pi\\) using Monte Carlo techniques\n\n\nProbability of uniformly sampled point falling in circle is\n\\[\n\\frac{\\textrm{Area circle}}{\\textrm{Area square}}=\\frac{\\pi}{4}\n\\]\n\n\n\n\n\n\n\n\n\nFigure 1"
  },
  {
    "objectID": "Slides/STEMExpo2025/STEMExpo2025.html#estimate-definite-integral-using-monte-carlo-method",
    "href": "Slides/STEMExpo2025/STEMExpo2025.html#estimate-definite-integral-using-monte-carlo-method",
    "title": "STEM Day 2025",
    "section": "Estimate definite integral using Monte Carlo method",
    "text": "Estimate definite integral using Monte Carlo method\n\n\nEstimate the definite integral \\[\n\\int_a^b f(x)\\textrm{d}x.\n\\]\nProb. of uniformly sampled point falling in shaded region \\[\n\\frac{\\textrm{Area shaded}}{\\textrm{Area square}}\n\\]\n\n\n\n\n\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "Slides/STEMExpo2025/STEMExpo2025.html#method",
    "href": "Slides/STEMExpo2025/STEMExpo2025.html#method",
    "title": "STEM Day 2025",
    "section": "Method",
    "text": "Method\n\nReal life sampling (rice grains)\nGet a computer to generate samples\n\nSee printed worksheet for further details."
  },
  {
    "objectID": "Slides/STEMExpo2025/STEMExpo2025.html#what-have-we-learned",
    "href": "Slides/STEMExpo2025/STEMExpo2025.html#what-have-we-learned",
    "title": "STEM Day 2025",
    "section": "What have we learned?",
    "text": "What have we learned?\n\nWe can study mathematics using experiential learning\nWe can program algorithms to help understand mathematical concepts\n\n\n\n\n\nMathematics, University of Dundee"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#why-mathematics",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#why-mathematics",
    "title": "Grove Academy Talk",
    "section": "Why Mathematics?",
    "text": "Why Mathematics?\n\nroute into many numerate professions\ndiverse career opportunities\nlearn a language that can be applied in many contexts\nwell paid jobs\nlearn skills for the digital age\n\n\n\nBecause you enjoy it!"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#what-happens-on-a-mathematics-degree",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#what-happens-on-a-mathematics-degree",
    "title": "Grove Academy Talk",
    "section": "What happens on a Mathematics degree?",
    "text": "What happens on a Mathematics degree?\n\n\n\nBuild on Higher/Advanced Higher\nLearn how to apply mathematics to real world problems\nDevelop programming skills needed to solve mathematical problems\nDevelop communication skills\n\n\n\n\n\nLearn to become a logical numerate problem solver"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#logical-numerate-problem-solvers-are-valued",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#logical-numerate-problem-solvers-are-valued",
    "title": "Grove Academy Talk",
    "section": "Logical numerate problem solvers are valued",
    "text": "Logical numerate problem solvers are valued\n\n\n\n\n\n\nwww.ima.org"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#what-have-recent-dundee-graduates-gone-on-to-do",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#what-have-recent-dundee-graduates-gone-on-to-do",
    "title": "Grove Academy Talk",
    "section": "What have recent Dundee graduates gone on to do?",
    "text": "What have recent Dundee graduates gone on to do?\n\n\n\nActuaries\nAccountants\nData analysts\nEngineers\nTrade analysts\n\n\n\nApp. developers\nTeachers\nAcademia\nProgrammers"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#how-is-mathematics-taught-at-uni",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#how-is-mathematics-taught-at-uni",
    "title": "Grove Academy Talk",
    "section": "How is Mathematics taught at Uni?",
    "text": "How is Mathematics taught at Uni?\n\ndevelop core syllabus (e.g. algebra and calculus)\nlearn about new mathematical topics (e.g. statistics, dynamical systems, differential geometry, operational research …)\nlectures (50 minute, twice a week)\nweekly tutorials (usually associated with worksheets)\ncomputer labs (develop programming skills)"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#flex-your-mathematical-muscles-with-a-final-year-project",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#flex-your-mathematical-muscles-with-a-final-year-project",
    "title": "Grove Academy Talk",
    "section": "Flex your mathematical muscles with a final year project",
    "text": "Flex your mathematical muscles with a final year project\n\ndevelop independent problem solving skills\ndevelop programming and presentation skills\n\n\n\n\nThe $25,000,000,000 eigenvector\nThe mathematics of monopoly\nHow sat. navs work?"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#explore-how-mathematics-underpins-cryptography",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#explore-how-mathematics-underpins-cryptography",
    "title": "Grove Academy Talk",
    "section": "Explore how mathematics underpins cryptography",
    "text": "Explore how mathematics underpins cryptography\n\nHow to banks securely transfer data to your phone?\nHow can governments securely communicate sensitive information?\n\nhttps://dundeemath.github.io/Admissions/posts/Cryptography.html"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#decryption-using-hash-functions",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#decryption-using-hash-functions",
    "title": "Grove Academy Talk",
    "section": "Decryption using hash functions",
    "text": "Decryption using hash functions\n\nHash functions provide a way to encrypt/decrypt messages\nBoth encrytion/decryption use the same shared secret number\n\n9995fc19ee935e80d28b19db3709a9ce414ec1bd29cd006115114fbd6bd2f6e5cb84aec0d6468233e1\nDecryptUsingThisLink\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 300\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nimport base64\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"shared_secret\",label=\"Shared secret\",min=10,max=3000,value=31,step=1),\n    ui.input_text(id='text',label=\"Message to decrypt\",value=\"8968d20bbc5b\"),\n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n\n    \n    def decrypt_message(key, iv, ciphertext):\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        decryptor = cipher.decryptor()\n        plaintext = decryptor.update(ciphertext) + decryptor.finalize()\n        return plaintext\n\n\n\n    @render.table\n    def result():\n        # list of strings\n        shared_secret=int(input.shared_secret())\n        encrypted_text=str(input.text())\n\n        encrypted_text=bytes.fromhex(encrypted_text)\n\n\n\n\n        #text=text.encode(encoding=\"utf-8\")\n        #encrypted_text = encrypted_text.encode('ISO-8859-1')\n\n        shared_secret_bytes=shared_secret.to_bytes(16,'big')\n        derived_key = HKDF(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=None,\n            info=b\"diffie-hellman-key-exchange\",\n        ).derive(shared_secret_bytes)\n        \n        \n        iv=5\n        iv=iv.to_bytes(16, 'big')\n                \n        decrypted_message = decrypt_message(derived_key, iv, encrypted_text)\n\n       \n        data_dict = {\n            'Decrypted Message':[decrypted_message]\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\napp = App(app_ui, server)\n\n\nFigure 1"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#encrypting-a-message",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#encrypting-a-message",
    "title": "Grove Academy Talk",
    "section": "Encrypting a message",
    "text": "Encrypting a message\nYou can also encrypt a message.\nYou’ll need to use the same shared secret to perform the decryption.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 300\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"shared_secret\",label=\"shared secret\",min=10,max=3000,value=23,step=1),\n    ui.input_text(id='text',label=\"Message to encrypt\",value=\"Yarrrr\"),\n         \n     \n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def encrypt_message(key, plaintext):\n        iv=5\n        iv=iv.to_bytes(16, 'big')\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        encryptor = cipher.encryptor()\n        ciphertext = encryptor.update(plaintext) + encryptor.finalize()\n        return iv,ciphertext\n    \n\n\n\n    @render.table\n    def result():\n        # list of strings\n        shared_secret=int(input.shared_secret())\n        text=input.text()\n        # Step 1: Generate Diffie-Hellman Parameters and Keys\n       \n\n        #shared_secret=int(np.mod(g**(a*b),p))\n        shared_secret_bytes=shared_secret.to_bytes(16,'big')\n        #shared_secret=g**(a*b)\n        derived_key = HKDF(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=None,\n            info=b\"diffie-hellman-key-exchange\",\n        ).derive(shared_secret_bytes)\n        \n        # Step 4: Encrypt a Message Using AES\n        message = text.encode(encoding=\"utf-8\")\n        iv, ciphertext = encrypt_message(derived_key, message)\n\n         # Decrypt the message\n        data_dict = {\n            'Encrypted Message':[ciphertext.hex()],\n            'Encrypted Message':[ciphertext.hex()],\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\n   \napp = App(app_ui, server)\n\n\nFigure 2"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#there-are-two-problems-with-our-encryption",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#there-are-two-problems-with-our-encryption",
    "title": "Grove Academy Talk",
    "section": "There are two problems with our encryption",
    "text": "There are two problems with our encryption\n\nBrute force - messages can be decrypted using trial and error\nEncryption requires both parties to share a secret number? How can this be safely achieved in practice?"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#modular-arithmetic",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#modular-arithmetic",
    "title": "Grove Academy Talk",
    "section": "Modular arithmetic",
    "text": "Modular arithmetic\nIn modular arithmetic we define a finite set of numbers and perform arithmetic operations on them.\n\n\n\\[ 2+3=5\\] \\[ 5+4=9\\]\n\\[ 11+ 3= ??\\]\nIn mathematical notation, 14 is congruent to 2 mod 12 \\[\n14 \\equiv 2 \\pmod{12}.\n\\]"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#modular-arithmetic-1",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#modular-arithmetic-1",
    "title": "Grove Academy Talk",
    "section": "Modular arithmetic",
    "text": "Modular arithmetic\nIn general\n\\[\na \\pmod p\n\\] means the remainder when \\(a\\) is divided by \\(p\\).\nSo \\[\n13 \\pmod{12} = ??\n\\]\n\\[\n27 \\pmod{12} = ??\n\\]"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#more-modular-arithmetic-operations",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#more-modular-arithmetic-operations",
    "title": "Grove Academy Talk",
    "section": "More modular arithmetic operations",
    "text": "More modular arithmetic operations\nWhat is \\[\n2^3 \\pmod 7 =?\n\\]\n\nNotably\n\\[\n(g^a)^b \\pmod p =  (g^b)^a \\pmod p\n\\]\n\n\nThis result underpins an import secret-sharing algorithm known as the Diffie-Hellman key exchange algorithm."
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#generating-a-shared-secret",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#generating-a-shared-secret",
    "title": "Grove Academy Talk",
    "section": "Generating a shared secret",
    "text": "Generating a shared secret\nTwo parties: \\(\\textrm{\\textcolor{red}{Alice}}\\) and \\(\\textrm{\\textcolor{blue}{Bob}}\\).\nSelect and share the following: prime number, \\(p\\), and generator \\(g\\) (primitive root of p).\nEach choose their own private keys \\(\\textcolor{red}{x_A}\\) and \\(\\textcolor{blue}{x_B}\\).\n\\(\\textrm{\\textcolor{red}{Alice}}\\) computes public key \\[\ny_A=g^{\\textcolor{red}{x_A}} \\pmod p\n\\]\n\\(\\textrm{\\textcolor{blue}{Bob}}\\) computes public key\n\\[\ny_B=g^{\\textcolor{blue}{x_B}} \\pmod p\n\\]\nThey publicly exchange public keys.\nThen \\(\\textrm{\\textcolor{red}{Alice}}\\) computes\n\\[\n(y_B)^{\\textcolor{red}{x_A}}=(g^{\\textcolor{blue}{x_B}})^{\\textcolor{red}{x_A}}= g^{\\textcolor{red}{x_A}\\textcolor{blue}{x_B}}=s \\pmod{p}\n\\]"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#generating-a-shared-secret-1",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#generating-a-shared-secret-1",
    "title": "Grove Academy Talk",
    "section": "Generating a shared secret",
    "text": "Generating a shared secret\nMeanwhile, \\(\\textrm{\\textcolor{blue}{Bob}}\\) computes \\[\n(y_A)^{\\textcolor{blue}{x_B}}=(g^{\\textcolor{red}{x_A}})^{\\textcolor{blue}{x_B}}= g^{\\textcolor{red}{x_A}\\textcolor{blue}{x_B}}=s \\pmod{p}\n\\]\nHence they both hold the same shared secret, \\(s\\).\nThey can use this for encryption/decryption of messages."
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#demonstration-using-app",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#demonstration-using-app",
    "title": "Grove Academy Talk",
    "section": "Demonstration using app",
    "text": "Demonstration using app\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 650\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"p\",label=\"p\",min=10,max=3000,value=23,step=1),\n    ui.input_slider(id=\"g\",label=\"g (generator)\",min=0,max=15.0,value=5,step=1),\n    ui.input_slider(id=\"a\",label=\"Private key Alice\",min=1,max=10,value=2,step=1),\n    ui.input_slider(id=\"b\",label=\"Private key Bob\",min=1,max=10,value=3,step=1), \n    \n         \n     \n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n        \n\n\n\n    @render.table\n    def result():\n        # list of strings\n        p=int(input.p())\n        g=int(input.g())\n        a=int(input.a())\n        b=int(input.b())\n        # Step 1: Generate Diffie-Hellman Parameters and \n\n\n        alice_public_key=int(np.mod(g**(a),p))\n        bob_public_key=int(np.mod(g**(b),p))\n\n        shared_secret=int(np.mod(g**(a*b),p))\n        \n     \n        data_dict = {\n            'p': [p],\n            'g': [g],\n            'Alice public key': [alice_public_key],\n            'Bob public key': [bob_public_key],\n            'Shared secret': [shared_secret],\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\napp = App(app_ui, server)\n\n\nFigure 3"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#why-is-it-safe",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#why-is-it-safe",
    "title": "Grove Academy Talk",
    "section": "Why is it safe?",
    "text": "Why is it safe?\nPublicly shared info: \\(p\\), \\(g\\), \\(y_A=g^{\\textcolor{red}{x_A}}\\), \\(y_B=g^{\\textcolor{blue}{x_B}}\\).\n. . . To identify the shared secret, a hacker needs to solve \\[\ng^{\\textcolor{red}{x_A}}=y_A \\pmod p.\n\\] for the unknown \\(x_A\\).\n\nGiven \\(\\textcolor{red}{x_A}\\), then they can compute the shared secret\n\\[\ns=y_B^{\\textcolor{red}{x_A}}=g^{\\textcolor{red}{x_A} \\textcolor{blue}{x_B}}.\n\\]"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#prime-numbers-and-primitive-roots",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#prime-numbers-and-primitive-roots",
    "title": "Grove Academy Talk",
    "section": "Prime numbers and primitive roots",
    "text": "Prime numbers and primitive roots\nA prime number, \\(p\\), has factors \\(p\\) and 1.\nSuppose that \\(g\\) is a primitive root of \\(p\\). \\(g\\) has the property that \\[\ng^{k} \\pmod p\n\\] generates all the numbers less than \\(p\\).\nSo if \\(p=5\\), 3 is a primitive root as\n\\[\n3^2\\equiv 4 \\pmod 5, \\ \\ 3^3\\ \\equiv 2 \\pmod 5,\n\\]\n\\[\n3^4\\equiv 1 \\pmod 5, \\ \\ 3^5 \\equiv 3 \\pmod 5.\n\\]"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#the-discrete-logarithm-problem",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#the-discrete-logarithm-problem",
    "title": "Grove Academy Talk",
    "section": "The discrete logarithm problem",
    "text": "The discrete logarithm problem\nThe problem \\[\ng^{x_A}=y_A \\pmod p.\n\\]\nis hard to solve.\nChoose \\(p\\) to be a prime number and \\(g\\) to be a primitive root of \\(p\\).\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 400\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"p\",label=\"p (prime number)\",min=5,max=300,value=23,step=1),\n    ui.input_slider(id=\"g\",label=\"g (generator)\",min=0,max=30,value=5,step=1),\n    ui.input_slider(id=\"s\",label=\"Public key\",min=1,max=100,value=5,step=1),      \n            ),\n\n        \n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    \n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        p=int(input.p())\n        g=int(input.g())\n        s=int(input.s())\n        \n    \n    \n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$f$')\n\n       \n        a_vec=np.linspace(0,p-1,p,dtype='uint64')\n        function_mod = np.mod(np.power(g, a_vec), p)\n\n        #function_mod=[pow(g,a,p) for a in a_vec]\n    \n\n        ax.plot(a_vec,function_mod,'x',a_vec,np.ones_like(a_vec)*s,'r--')\n\n        fig.tight_layout()\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 4"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#encryption-with-diffie-hellman--putting-it-all-together",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#encryption-with-diffie-hellman--putting-it-all-together",
    "title": "Grove Academy Talk",
    "section": "Encryption with Diffie Hellman -putting it all together",
    "text": "Encryption with Diffie Hellman -putting it all together\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"p\",label=\"p (prime number)\",min=10,max=3000,value=23,step=1),\n    ui.input_slider(id=\"g\",label=\"g (generator)\",min=0,max=15.0,value=5,step=1),\n    ui.input_slider(id=\"a\",label=\"Private key Bob\",min=1,max=10,value=2,step=1),\n    ui.input_slider(id=\"b\",label=\"Private key Alice\",min=1,max=10,value=3,step=1), \n    ui.input_text(id='text',label=\"Message to encrypt\",value=\"sin(x)\"),\n         \n     \n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def encrypt_message(key, plaintext):\n        iv=5\n        iv=iv.to_bytes(16, 'big')\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        encryptor = cipher.encryptor()\n        ciphertext = encryptor.update(plaintext) + encryptor.finalize()\n        return iv,ciphertext\n    \n    def decrypt_message(key, iv, ciphertext):\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        decryptor = cipher.decryptor()\n        plaintext = decryptor.update(ciphertext) + decryptor.finalize()\n        return plaintext\n\n\n\n    @render.table\n    def result():\n        # list of strings\n        p=int(input.p())\n        g=int(input.g())\n        a=int(input.a())\n        text=input.text()\n        b=int(input.b())\n        # Step 1: Generate Diffie-Hellman Parameters and Keys\n        parameters = dh.generate_parameters(generator=2, key_size=512)\n\n        # Generate private/public key pairs for two parties\n        private_key_a = parameters.generate_private_key()\n        private_key_b = parameters.generate_private_key()\n\n        # Generate public keys\n        public_key_a = private_key_a.public_key()\n        public_key_b = private_key_b.public_key()\n\n        # Step 2: Derive Shared Secret\n        shared_key_a = private_key_a.exchange(public_key_b)\n        shared_key_b = private_key_b.exchange(public_key_a)\n\n        # Validate shared keys are identical\n        assert shared_key_a == shared_key_b, \"Shared keys are not equal!\"\n\n        shared_secret=int(np.mod(g**(a*b),p))\n        shared_secret_bytes=shared_secret.to_bytes(16,'big')\n        #shared_secret=g**(a*b)\n        derived_key = HKDF(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=None,\n            info=b\"diffie-hellman-key-exchange\",\n        ).derive(shared_secret_bytes)\n        \n        # Step 4: Encrypt a Message Using AES\n        message = text.encode(encoding=\"utf-8\")\n        iv, ciphertext = encrypt_message(derived_key, message)\n        print(\"Ciphertext:\", ciphertext.hex())\n\n        # Decrypt the message\n        decrypted_message = decrypt_message(derived_key, iv, ciphertext)\n        data_dict = {\n            'p': [p],\n            'g': [g],\n            'Message': [text],\n            'Shared secret Alice': [shared_secret],\n            'Encrypted Message':[ciphertext.hex()],\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\n   \napp = App(app_ui, server)\n\n\nFigure 5"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#decryption",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#decryption",
    "title": "Grove Academy Talk",
    "section": "Decryption",
    "text": "Decryption\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 300\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nimport base64\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"shared_secret\",label=\"Shared secret\",min=10,max=3000,value=31,step=1),\n    ui.input_text(id='text',label=\"Message to decrypt\",value=\"8968d20bbc5b\"),\n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n\n    \n    def decrypt_message(key, iv, ciphertext):\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        decryptor = cipher.decryptor()\n        plaintext = decryptor.update(ciphertext) + decryptor.finalize()\n        return plaintext\n\n\n\n    @render.table\n    def result():\n        # list of strings\n        shared_secret=int(input.shared_secret())\n        encrypted_text=str(input.text())\n\n        encrypted_text=bytes.fromhex(encrypted_text)\n\n\n\n\n        #text=text.encode(encoding=\"utf-8\")\n        #encrypted_text = encrypted_text.encode('ISO-8859-1')\n\n        shared_secret_bytes=shared_secret.to_bytes(16,'big')\n        derived_key = HKDF(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=None,\n            info=b\"diffie-hellman-key-exchange\",\n        ).derive(shared_secret_bytes)\n        \n        \n        iv=5\n        iv=iv.to_bytes(16, 'big')\n                \n        decrypted_message = decrypt_message(derived_key, iv, encrypted_text)\n\n       \n        data_dict = {\n            'Decrypted Message':[decrypted_message]\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\napp = App(app_ui, server)\n\n\nFigure 6"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#some-reasons-to-study-mathematics",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#some-reasons-to-study-mathematics",
    "title": "Grove Academy Talk",
    "section": "Some reasons to study mathematics",
    "text": "Some reasons to study mathematics\n\nHave fun whilst you learn to to become logical numerate problem solver\nExcellent career opportunities post graduation\nHigher salaries than many other disciplines\nExcellent teaching and student community"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#cryptography",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#cryptography",
    "title": "Grove Academy Talk",
    "section": "Cryptography",
    "text": "Cryptography\n\nMathematics underpins modern encryption\nNecessary to keep data safe online\nThe security of modern cryptographic algorithms is strongly dependent on number theory and group theory."
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#apps",
    "href": "Slides/ApplicantVisitOnlineMarch2025/GroveTalk.html#apps",
    "title": "Grove Academy Talk",
    "section": "Apps",
    "text": "Apps\n\nApps used today are published online\nThey are written in Python\nIn a maths degree you will learn when and why algorithms work\nImplement algorithms"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#why-mathematics",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#why-mathematics",
    "title": "Applicant visit talk",
    "section": "Why Mathematics?",
    "text": "Why Mathematics?\n\nBecome a logical numerate problem solver\nLearn about exciting new areas of mathematics\nLearn how to apply mathematics to real world problems\nDevelop computer programming skills\nDevelop communication skills"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#logical-numerate-problem-solvers-are-valued",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#logical-numerate-problem-solvers-are-valued",
    "title": "Applicant visit talk",
    "section": "Logical numerate problem solvers are valued",
    "text": "Logical numerate problem solvers are valued"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#mathematics-degrees",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#mathematics-degrees",
    "title": "Applicant visit talk",
    "section": "Mathematics degrees",
    "text": "Mathematics degrees\n\nSingle honours Mathematics degrees\nJoint Honours (e.g. with Accountancy, Economics, Physics, Life Sciences, Psychology)\nFlexibility in structure of degree pathways"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#teaching-delivery",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#teaching-delivery",
    "title": "Applicant visit talk",
    "section": "Teaching delivery",
    "text": "Teaching delivery\n\nTwo teaching semesters in the academic year\n3 or 4 modules in each semester\nIn each module (some combination of):\n\nlectures\ntutorials\nworkshops\ncomputer classes"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#final-year-project",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#final-year-project",
    "title": "Applicant visit talk",
    "section": "Final year project",
    "text": "Final year project\n\ndevelop independent problem solving skills\nwork on an exciting mathematical topic\ndevelop programming and presentation skills\nTopics include:\n\nThe $25,000,000,000 eigenvector\nThe Mathematics of monopoly\nHow Sat Navs work?"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#explore-how-mathematics-underpins-cryptography",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#explore-how-mathematics-underpins-cryptography",
    "title": "Applicant visit talk",
    "section": "Explore how mathematics underpins cryptography",
    "text": "Explore how mathematics underpins cryptography\n\nHow to banks securely transfer data to your phone?\nHow can governments securely communicate sensitive information?\n\nhttps://dundeemath.github.io/Admissions/posts/Cryptography.html"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#decryption-using-hash-functions",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#decryption-using-hash-functions",
    "title": "Applicant visit talk",
    "section": "Decryption using hash functions",
    "text": "Decryption using hash functions\n\nHash functions provide a way to encrypt/decrypt messages\nBoth encrytion/decryption use the same shared secret number\n\n9995fc19ee935e80d28b19db3709a9ce414ec1bd29cd006115114fbd6bd2f6e5cb84aec0d6468233e1\nDecryptUsingThisLink\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 300\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nimport base64\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"shared_secret\",label=\"Shared secret\",min=10,max=3000,value=31,step=1),\n    ui.input_text(id='text',label=\"Message to decrypt\",value=\"8968d20bbc5b\"),\n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n\n    \n    def decrypt_message(key, iv, ciphertext):\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        decryptor = cipher.decryptor()\n        plaintext = decryptor.update(ciphertext) + decryptor.finalize()\n        return plaintext\n\n\n\n    @render.table\n    def result():\n        # list of strings\n        shared_secret=int(input.shared_secret())\n        encrypted_text=str(input.text())\n\n        encrypted_text=bytes.fromhex(encrypted_text)\n\n\n\n\n        #text=text.encode(encoding=\"utf-8\")\n        #encrypted_text = encrypted_text.encode('ISO-8859-1')\n\n        shared_secret_bytes=shared_secret.to_bytes(16,'big')\n        derived_key = HKDF(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=None,\n            info=b\"diffie-hellman-key-exchange\",\n        ).derive(shared_secret_bytes)\n        \n        \n        iv=5\n        iv=iv.to_bytes(16, 'big')\n                \n        decrypted_message = decrypt_message(derived_key, iv, encrypted_text)\n\n       \n        data_dict = {\n            'Decrypted Message':[decrypted_message]\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\napp = App(app_ui, server)\n\n\nFigure 1"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#encrypting-a-message",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#encrypting-a-message",
    "title": "Applicant visit talk",
    "section": "Encrypting a message",
    "text": "Encrypting a message\nYou can also encrypt a message.\nYou’ll need to use the same shared secret to perform the decryption.\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 300\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"shared_secret\",label=\"shared secret\",min=10,max=3000,value=23,step=1),\n    ui.input_text(id='text',label=\"Message to encrypt\",value=\"Yarrrr\"),\n         \n     \n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def encrypt_message(key, plaintext):\n        iv=5\n        iv=iv.to_bytes(16, 'big')\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        encryptor = cipher.encryptor()\n        ciphertext = encryptor.update(plaintext) + encryptor.finalize()\n        return iv,ciphertext\n    \n\n\n\n    @render.table\n    def result():\n        # list of strings\n        shared_secret=int(input.shared_secret())\n        text=input.text()\n        # Step 1: Generate Diffie-Hellman Parameters and Keys\n       \n\n        #shared_secret=int(np.mod(g**(a*b),p))\n        shared_secret_bytes=shared_secret.to_bytes(16,'big')\n        #shared_secret=g**(a*b)\n        derived_key = HKDF(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=None,\n            info=b\"diffie-hellman-key-exchange\",\n        ).derive(shared_secret_bytes)\n        \n        # Step 4: Encrypt a Message Using AES\n        message = text.encode(encoding=\"utf-8\")\n        iv, ciphertext = encrypt_message(derived_key, message)\n\n         # Decrypt the message\n        data_dict = {\n            'Encrypted Message':[ciphertext.hex()],\n            'Encrypted Message':[ciphertext.hex()],\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\n   \napp = App(app_ui, server)\n\n\nFigure 2"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#there-are-two-problems-with-our-encryption",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#there-are-two-problems-with-our-encryption",
    "title": "Applicant visit talk",
    "section": "There are two problems with our encryption",
    "text": "There are two problems with our encryption\n\nBrute force - messages can be decrypted using trial and error\nEncryption requires both parties to share a secret number? How can this be safely achieved in practice?"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#modular-arithmetic",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#modular-arithmetic",
    "title": "Applicant visit talk",
    "section": "Modular arithmetic",
    "text": "Modular arithmetic\nIn modular arithmetic we define a finite set of numbers and perform arithmetic operations on them.\n\n\n\\[ 2+3=5\\] \\[ 5+4=9\\]\n\\[ 11+ 3= ??\\]\nIn mathematical notation, 14 is congruent to 2 mod 12 \\[\n14 \\equiv 2 \\pmod{12}.\n\\]"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#modular-arithmetic-1",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#modular-arithmetic-1",
    "title": "Applicant visit talk",
    "section": "Modular arithmetic",
    "text": "Modular arithmetic\nIn general\n\\[\na \\pmod p\n\\] means the remainder when \\(a\\) is divided by \\(p\\).\nSo \\[\n13 \\pmod{12} = ??\n\\]\n\\[\n27 \\pmod{12} = ??\n\\]"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#more-modular-arithmetic-operations",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#more-modular-arithmetic-operations",
    "title": "Applicant visit talk",
    "section": "More modular arithmetic operations",
    "text": "More modular arithmetic operations\nWhat is \\[\n2^3 \\pmod 7 =?\n\\]\n\nNotably\n\\[\n(g^a)^b \\pmod p =  (g^b)^a \\pmod p\n\\]\n\n\nThis result underpins an import secret-sharing algorithm known as the Diffie-Hellman key exchange algorithm."
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#generating-a-shared-secret",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#generating-a-shared-secret",
    "title": "Applicant visit talk",
    "section": "Generating a shared secret",
    "text": "Generating a shared secret\nTwo parties: \\(\\textrm{\\textcolor{red}{Alice}}\\) and \\(\\textrm{\\textcolor{blue}{Bob}}\\).\nSelect and share the following: prime number, \\(p\\), and generator \\(g\\) (primitive root of p).\nEach choose their own private keys \\(\\textcolor{red}{x_A}\\) and \\(\\textcolor{blue}{x_B}\\).\n\\(\\textrm{\\textcolor{red}{Alice}}\\) computes public key \\[\ny_A=g^{\\textcolor{red}{x_A}} \\pmod p\n\\]\n\\(\\textrm{\\textcolor{blue}{Bob}}\\) computes public key\n\\[\ny_B=g^{\\textcolor{blue}{x_B}} \\pmod p\n\\]\nThey publicly exchange public keys.\nThen \\(\\textrm{\\textcolor{red}{Alice}}\\) computes\n\\[\n(y_B)^{\\textcolor{red}{x_A}}=(g^{\\textcolor{blue}{x_B}})^{\\textcolor{red}{x_A}}= g^{\\textcolor{red}{x_A}\\textcolor{blue}{x_B}}=s \\pmod{p}\n\\]"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#generating-a-shared-secret-1",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#generating-a-shared-secret-1",
    "title": "Applicant visit talk",
    "section": "Generating a shared secret",
    "text": "Generating a shared secret\nMeanwhile, \\(\\textrm{\\textcolor{blue}{Bob}}\\) computes \\[\n(y_A)^{\\textcolor{blue}{x_B}}=(g^{\\textcolor{red}{x_A}})^{\\textcolor{blue}{x_B}}= g^{\\textcolor{red}{x_A}\\textcolor{blue}{x_B}}=s \\pmod{p}\n\\]\nHence they both hold the same shared secret, \\(s\\).\nThey can use this for encryption/decryption of messages."
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#demonstration-using-app",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#demonstration-using-app",
    "title": "Applicant visit talk",
    "section": "Demonstration using app",
    "text": "Demonstration using app\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 650\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"p\",label=\"p\",min=10,max=3000,value=23,step=1),\n    ui.input_slider(id=\"g\",label=\"g (generator)\",min=0,max=15.0,value=5,step=1),\n    ui.input_slider(id=\"a\",label=\"Private key Alice\",min=1,max=10,value=2,step=1),\n    ui.input_slider(id=\"b\",label=\"Private key Bob\",min=1,max=10,value=3,step=1), \n    \n         \n     \n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n        \n\n\n\n    @render.table\n    def result():\n        # list of strings\n        p=int(input.p())\n        g=int(input.g())\n        a=int(input.a())\n        b=int(input.b())\n        # Step 1: Generate Diffie-Hellman Parameters and \n\n\n        alice_public_key=int(np.mod(g**(a),p))\n        bob_public_key=int(np.mod(g**(b),p))\n\n        shared_secret=int(np.mod(g**(a*b),p))\n        \n     \n        data_dict = {\n            'p': [p],\n            'g': [g],\n            'Alice public key': [alice_public_key],\n            'Bob public key': [bob_public_key],\n            'Shared secret': [shared_secret],\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\napp = App(app_ui, server)\n\n\nFigure 3"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#why-is-it-safe",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#why-is-it-safe",
    "title": "Applicant visit talk",
    "section": "Why is it safe?",
    "text": "Why is it safe?\nPublicly shared info: \\(p\\), \\(g\\), \\(y_A=g^{\\textcolor{red}{x_A}}\\), \\(y_B=g^{\\textcolor{blue}{x_B}}\\).\n. . . To identify the shared secret, a hacker needs to solve \\[\ng^{\\textcolor{red}{x_A}}=y_A \\pmod p.\n\\] for the unknown \\(x_A\\).\n\nGiven \\(\\textcolor{red}{x_A}\\), then they can compute the shared secret\n\\[\ns=y_B^{\\textcolor{red}{x_A}}=g^{\\textcolor{red}{x_A} \\textcolor{blue}{x_B}}.\n\\]"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#prime-numbers-and-primitive-roots",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#prime-numbers-and-primitive-roots",
    "title": "Applicant visit talk",
    "section": "Prime numbers and primitive roots",
    "text": "Prime numbers and primitive roots\nA prime number, \\(p\\), has factors \\(p\\) and 1.\nSuppose that \\(g\\) is a primitive root of \\(p\\). \\(g\\) has the property that \\[\ng^{k} \\pmod p\n\\] generates all the numbers less than \\(p\\).\nSo if \\(p=5\\), 3 is a primitive root as\n\\[\n3^2\\equiv 4 \\pmod 5, \\ \\ 3^3\\ \\equiv 2 \\pmod 5,\n\\]\n\\[\n3^4\\equiv 1 \\pmod 5, \\ \\ 3^5 \\equiv 3 \\pmod 5.\n\\]"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#the-discrete-logarithm-problem",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#the-discrete-logarithm-problem",
    "title": "Applicant visit talk",
    "section": "The discrete logarithm problem",
    "text": "The discrete logarithm problem\nThe problem \\[\ng^{x_A}=y_A \\pmod p.\n\\]\nis hard to solve.\nChoose \\(p\\) to be a prime number and \\(g\\) to be a primitive root of \\(p\\).\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 400\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"p\",label=\"p (prime number)\",min=5,max=300,value=23,step=1),\n    ui.input_slider(id=\"g\",label=\"g (generator)\",min=0,max=30,value=5,step=1),\n    ui.input_slider(id=\"s\",label=\"Public key\",min=1,max=100,value=5,step=1),      \n            ),\n\n        \n        ui.output_plot(\"plot\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    \n\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        p=int(input.p())\n        g=int(input.g())\n        s=int(input.s())\n        \n    \n    \n        ax.set_xlabel('$x$')\n        ax.set_ylabel('$f$')\n\n       \n        a_vec=np.linspace(0,p-1,p,dtype='uint64')\n        function_mod = np.mod(np.power(g, a_vec), p)\n\n        #function_mod=[pow(g,a,p) for a in a_vec]\n    \n\n        ax.plot(a_vec,function_mod,'x',a_vec,np.ones_like(a_vec)*s,'r--')\n\n        fig.tight_layout()\n        plt.grid()\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 4"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#encryption-with-diffie-hellman--putting-it-all-together",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#encryption-with-diffie-hellman--putting-it-all-together",
    "title": "Applicant visit talk",
    "section": "Encryption with Diffie Hellman -putting it all together",
    "text": "Encryption with Diffie Hellman -putting it all together\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 500\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"p\",label=\"p (prime number)\",min=10,max=3000,value=23,step=1),\n    ui.input_slider(id=\"g\",label=\"g (generator)\",min=0,max=15.0,value=5,step=1),\n    ui.input_slider(id=\"a\",label=\"Private key Bob\",min=1,max=10,value=2,step=1),\n    ui.input_slider(id=\"b\",label=\"Private key Alice\",min=1,max=10,value=3,step=1), \n    ui.input_text(id='text',label=\"Message to encrypt\",value=\"sin(x)\"),\n         \n     \n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n    def encrypt_message(key, plaintext):\n        iv=5\n        iv=iv.to_bytes(16, 'big')\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        encryptor = cipher.encryptor()\n        ciphertext = encryptor.update(plaintext) + encryptor.finalize()\n        return iv,ciphertext\n    \n    def decrypt_message(key, iv, ciphertext):\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        decryptor = cipher.decryptor()\n        plaintext = decryptor.update(ciphertext) + decryptor.finalize()\n        return plaintext\n\n\n\n    @render.table\n    def result():\n        # list of strings\n        p=int(input.p())\n        g=int(input.g())\n        a=int(input.a())\n        text=input.text()\n        b=int(input.b())\n        # Step 1: Generate Diffie-Hellman Parameters and Keys\n        parameters = dh.generate_parameters(generator=2, key_size=512)\n\n        # Generate private/public key pairs for two parties\n        private_key_a = parameters.generate_private_key()\n        private_key_b = parameters.generate_private_key()\n\n        # Generate public keys\n        public_key_a = private_key_a.public_key()\n        public_key_b = private_key_b.public_key()\n\n        # Step 2: Derive Shared Secret\n        shared_key_a = private_key_a.exchange(public_key_b)\n        shared_key_b = private_key_b.exchange(public_key_a)\n\n        # Validate shared keys are identical\n        assert shared_key_a == shared_key_b, \"Shared keys are not equal!\"\n\n        shared_secret=int(np.mod(g**(a*b),p))\n        shared_secret_bytes=shared_secret.to_bytes(16,'big')\n        #shared_secret=g**(a*b)\n        derived_key = HKDF(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=None,\n            info=b\"diffie-hellman-key-exchange\",\n        ).derive(shared_secret_bytes)\n        \n        # Step 4: Encrypt a Message Using AES\n        message = text.encode(encoding=\"utf-8\")\n        iv, ciphertext = encrypt_message(derived_key, message)\n        print(\"Ciphertext:\", ciphertext.hex())\n\n        # Decrypt the message\n        decrypted_message = decrypt_message(derived_key, iv, ciphertext)\n        data_dict = {\n            'p': [p],\n            'g': [g],\n            'Message': [text],\n            'Shared secret Alice': [shared_secret],\n            'Encrypted Message':[ciphertext.hex()],\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\n   \napp = App(app_ui, server)\n\n\nFigure 5"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#decryption",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#decryption",
    "title": "Applicant visit talk",
    "section": "Decryption",
    "text": "Decryption\n\n\n\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 300\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport sympy as sp\nimport pandas as pd\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dh\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nimport base64\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n    ui.input_slider(id=\"shared_secret\",label=\"Shared secret\",min=10,max=3000,value=31,step=1),\n    ui.input_text(id='text',label=\"Message to decrypt\",value=\"8968d20bbc5b\"),\n            ),\n\n        ui.output_table(\"result\"),\n    ),\n)\n\ndef server(input, output, session):\n    \n\n\n    \n    def decrypt_message(key, iv, ciphertext):\n        cipher = Cipher(algorithms.AES(key), modes.CFB(iv))\n        decryptor = cipher.decryptor()\n        plaintext = decryptor.update(ciphertext) + decryptor.finalize()\n        return plaintext\n\n\n\n    @render.table\n    def result():\n        # list of strings\n        shared_secret=int(input.shared_secret())\n        encrypted_text=str(input.text())\n\n        encrypted_text=bytes.fromhex(encrypted_text)\n\n\n\n\n        #text=text.encode(encoding=\"utf-8\")\n        #encrypted_text = encrypted_text.encode('ISO-8859-1')\n\n        shared_secret_bytes=shared_secret.to_bytes(16,'big')\n        derived_key = HKDF(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=None,\n            info=b\"diffie-hellman-key-exchange\",\n        ).derive(shared_secret_bytes)\n        \n        \n        iv=5\n        iv=iv.to_bytes(16, 'big')\n                \n        decrypted_message = decrypt_message(derived_key, iv, encrypted_text)\n\n       \n        data_dict = {\n            'Decrypted Message':[decrypted_message]\n            }\n\n        # Create a DataFrame\n        df = pd.DataFrame(data_dict)\n        # Calling DataFrame constructor on list\n        return df\n\napp = App(app_ui, server)\n\n\nFigure 6"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#some-reasons-to-study-mathematics",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#some-reasons-to-study-mathematics",
    "title": "Applicant visit talk",
    "section": "Some reasons to study mathematics",
    "text": "Some reasons to study mathematics\n\nHave fun whilst you learn to to become logical numerate problem solver\nExcellent career opportunities post graduation\nHigher salaries than many other disciplines\nExcellent teaching and student community"
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#cryptography",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#cryptography",
    "title": "Applicant visit talk",
    "section": "Cryptography",
    "text": "Cryptography\n\nMathematics underpins modern encryption\nNecessary to keep data safe online\nThe security of modern cryptographic algorithms is strongly dependent on number theory and group theory."
  },
  {
    "objectID": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#apps",
    "href": "Slides/ApplicantVisitOnlineMarch2025/ApplicantVisitOnlineMarch2025.html#apps",
    "title": "Applicant visit talk",
    "section": "Apps",
    "text": "Apps\n\nApps used today are published online\nThey are written in Python\nIn a maths degree you will learn when and why algorithms work\nImplement algorithms"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "These pages are hosted by Mathematics staff at the University of Dundee. They are intended to support ongoing student recruitment and outreach activities."
  }
]